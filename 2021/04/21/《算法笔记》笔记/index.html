<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-atom.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="[TOC]">
<meta property="og:type" content="article">
<meta property="og:title" content="《算法笔记》总结">
<meta property="og:url" content="http://yoursite.com/2021/04/21/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="kongkong&#39;s Blog">
<meta property="og:description" content="[TOC]">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309090058765.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309090139568.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309131148866.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309132227795.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309133417940.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309133715663.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309134048706.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309134154099.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210311163608746.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309224829582.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210310212428242.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210313210932268.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210313212311647.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210313212311647.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210313212537246.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210313213046547.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210315144750560.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210315152211196.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316082007789.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316084246846.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316091304532.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316091330893.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316091619664.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316125810982.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316125722792.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316131651669.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316133601904.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316141313149.png">
<meta property="og:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316141352442.png">
<meta property="article:published_time" content="2021-04-21T01:50:12.924Z">
<meta property="article:modified_time" content="2021-04-21T02:16:05.456Z">
<meta property="article:author" content="Minghao Feng">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309090058765.png">

<link rel="canonical" href="http://yoursite.com/2021/04/21/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>《算法笔记》总结 | kongkong's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">kongkong's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/kongkongNG" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/21/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/morty.png">
      <meta itemprop="name" content="Minghao Feng">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongkong's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《算法笔记》总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-21 09:50:12 / 修改时间：10:16:05" itemprop="dateCreated datePublished" datetime="2021-04-21T09:50:12+08:00">2021-04-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/04/21/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/21/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<a id="more"></a>
<h2 id="0-起步"><a href="#0-起步" class="headerlink" title="0 起步"></a>0 起步</h2><p>基本数据类型：变量，强制转换，符号常量（define），const</p>
<p>顺序结构：赋值，scanf/printf，getchar/putchar，typedef，<strong>math</strong>函数</p>
<ul>
<li><p>区分double型的scanf和printf<br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309090058765.png" alt="image-20210309090058765"></p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309090139568.png" alt="image-20210309090139568"></p>
</li>
<li><p>常用math函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fabs</span><span class="params">(<span class="keyword">double</span> x)</span></span>;	<span class="comment">// 取绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> x)</span></span>;	<span class="comment">// 四舍五入，返回的double需用(int)取整</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> x)</span></span>;	<span class="comment">// 向下取整</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>;	<span class="comment">// 向上取整</span></span><br><span class="line"><span class="comment">// 以上两个函数对负数也有效，如floor(-5.2) = -6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> r, <span class="keyword">double</span> p)</span></span>;	<span class="comment">// 返回r^p</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;	<span class="comment">// 返回x的算术平方根</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> x)</span></span>;	<span class="comment">// 返回以e为底的对数</span></span><br><span class="line"><span class="comment">// 换底公式处理任何底的对数: log_a(b) = log(b) / log(a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三角函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sin</span><span class="params">(<span class="keyword">double</span> x)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> x)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">tan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;	</span><br><span class="line"><span class="comment">// 参数要求弧度制 如1/3 * pi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反三角函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">asin</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">acos</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>选择结构：if，switch</p>
<p>循环结构：while，do while，for，break/continue</p>
<p>数组：memset，字符数组，string.h头文件，<strong>sscanf/sprintf</strong>（字符串格式转换）</p>
<ul>
<li><p>```c++</p>
<h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <cstring></h1><p>memset(数组名, 值, sizeof(数组名));    // 值只能0或-1，因为是按字节赋值</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  <span class="comment">// 将数据输入到字符串</span></span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">12345</span>;</span><br><span class="line">  <span class="keyword">char</span> <span class="keyword">str</span>[<span class="number">6</span>];</span><br><span class="line">  sprintf(<span class="keyword">str</span>, <span class="string">"%d"</span>, n);</span><br><span class="line">  <span class="comment">// 执行后str为"12345"</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从字符串中提取输入</span></span><br><span class="line">  <span class="keyword">char</span> <span class="keyword">str</span>[<span class="number">6</span>] = <span class="string">"12345"</span>;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  sscanf(<span class="keyword">str</span>, <span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="comment">// 执行后n = 12345</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>函数：嵌套、递归</p>
<p>指针：指针与数组、<strong>引用<code>&amp;</code></strong></p>
<ul>
<li>引用不产生副本，而是给原变量起别名</li>
<li>指针引用（如<code>int* &amp;r</code>），在需要改指针存储的<code>unsigned int</code>型地址本身时使用</li>
</ul>
<p>结构体：访问元素<code>.</code>/<code>-&gt;</code>，构造函数</p>
<p>输入字符串汇总：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);		<span class="comment">// scanf读入一个char[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((str[i]=getchar())!=<span class="string">'\n'</span>)		<span class="comment">// getchar读入一行char[]</span></span><br><span class="line">    i++;</span><br><span class="line"></span><br><span class="line">gets(str);	<span class="comment">// gets读入一行char[]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.getline(str, MAXN);	<span class="comment">// cin读入一行char[], 读取直到遇到\n为止</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2;</span><br><span class="line">getline(<span class="built_in">cin</span>, str2);	<span class="comment">// cin读入一行string</span></span><br></pre></td></tr></table></figure>
<p>文件输入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 打开文件，如果没有则新建</span></span><br><span class="line"><span class="keyword">char</span> fileName[<span class="number">10</span>] = <span class="string">"tmp.txt"</span>;</span><br><span class="line"><span class="keyword">char</span> mode[<span class="number">3</span>] = <span class="string">"r+"</span>;	<span class="comment">// r只读，w只写，r+可读可写</span></span><br><span class="line">FILE *fp = fopen(filename, mode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件关闭</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">( FILE *fp )</span></span>;	<span class="comment">// 错误返回EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件读</span></span><br><span class="line"><span class="comment">// fgetc</span></span><br><span class="line"><span class="keyword">while</span> ((c = fgetc(fp)) != EOF)		<span class="comment">// 返回读取的字符</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//fgets</span></span><br><span class="line"><span class="keyword">char</span> buff[maxn];</span><br><span class="line"><span class="keyword">while</span> (fgets(buf, maxn, fp))	 <span class="comment">// 读一行存进buf，也可以用char*接收返回值</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// fscanf</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;n) != EOF)	<span class="comment">// 注意结合sscanf理解“流”</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件写</span></span><br><span class="line">fputc( <span class="keyword">int</span> c, fp);</span><br><span class="line"><span class="built_in">fputs</span>(str, fp);		<span class="comment">// 末尾无\n，puts有</span></span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">"%s"</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他</span></span><br><span class="line">rewind(fp);		<span class="comment">// 文件指向开头</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> <span class="keyword">int</span> offset, <span class="keyword">int</span> whence)</span></span>;	<span class="comment">// 文件指针移动</span></span><br><span class="line"><span class="comment">// whence可以是：SEEK_SET开头，SEEK_CUR当前，SEEK_END末尾</span></span><br></pre></td></tr></table></figure>
<p>C语言字符判断函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isalpha</span>(c);	<span class="comment">// 是否为字母</span></span><br><span class="line"><span class="built_in">isdigit</span>(c);	<span class="comment">// 是否为数字</span></span><br><span class="line"><span class="built_in">isalnum</span>(c);	<span class="comment">// 是否为英文或数字</span></span><br><span class="line"><span class="built_in">isupper</span>(c);	<span class="comment">// 是否为大写</span></span><br><span class="line"><span class="built_in">islower</span>(c);	<span class="comment">// 是否为小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否为分割文本的空白符（空格' '和水平制表符'\t'）</span></span><br><span class="line">isblank(c);	</span><br><span class="line"><span class="comment">// 是否为空白符（' '、水平制表符'\t'、换行符'\n'、垂直制表符'\v'、换页'\f'以及回车'\r'。）</span></span><br><span class="line"><span class="built_in">isspace</span>(c);</span><br></pre></td></tr></table></figure>
<h2 id="1-算法初步"><a href="#1-算法初步" class="headerlink" title="1 算法初步"></a>1 算法初步</h2><h3 id="1-1-排序"><a href="#1-1-排序" class="headerlink" title="1.1 排序"></a>1.1 排序</h3><p>c++ <code>sort</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">sort([首元素地址], [尾元素的下一个地址], [比较函数cmp(非必填)]);	<span class="comment">// 默认升序</span></span><br><span class="line"><span class="comment">// 简单cmp函数</span></span><br><span class="line"><span class="comment">// bool cmp(e1, e2)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 		return e1 &lt; e2; // 小元素在前、升序</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>c <code>qsort</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmpfunc</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * a, <span class="keyword">const</span> <span class="keyword">void</span> * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> ( *([类型]*)a - *([类型]*)b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">qsort([数组], n, <span class="keyword">sizeof</span>([类型]), cmp);</span><br></pre></td></tr></table></figure>
<p>写cmp函数的原则：</p>
<ul>
<li><strong>希望元素按什么顺序排列，就直接按照大小次序返回即可；</strong></li>
</ul>
<h3 id="1-2-递归"><a href="#1-2-递归" class="headerlink" title="1.2 递归"></a>1.2 递归</h3><p>典例：全排列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs(0)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 递归边界</span></span><br><span class="line">    <span class="keyword">if</span> (index == n - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>, a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 递归式</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!flag[i])</span><br><span class="line">		&#123;</span><br><span class="line">			a[index] = i;	<span class="comment">// 常用技巧: 用层数做数组下标记录结果</span></span><br><span class="line">			vis[i] = <span class="literal">true</span>;</span><br><span class="line">			dfs(index + <span class="number">1</span>);</span><br><span class="line">			vis[i] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>n皇后问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心思想：排列 + 判断方案是否合法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (index == n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 方案数</span></span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="comment">// 打印方案</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">			(i == n - <span class="number">1</span>)? <span class="built_in">putchar</span>(<span class="string">'\n'</span>) : <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="comment">// 枚举待选择的位置：index下标放入i </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> pre = <span class="number">0</span>; pre &lt; index; pre++)	<span class="comment">// 枚举已有的位置 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 如果在对角线上</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(index - pre) == <span class="built_in">abs</span>(i - ans[pre]))</span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 若这种方案目前合法 </span></span><br><span class="line">			<span class="keyword">if</span> (flag)	</span><br><span class="line">			&#123;</span><br><span class="line">				vis[i] = <span class="literal">true</span>;</span><br><span class="line">				ans[index] = i;</span><br><span class="line">				dfs(index + <span class="number">1</span>);</span><br><span class="line">				vis[i] = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-贪心"><a href="#1-3-贪心" class="headerlink" title="1.3 贪心"></a>1.3 贪心</h3><p>局部最优推得全局最优</p>
<ul>
<li>简单贪心：分布背包</li>
<li>区间贪心<ul>
<li>活动选择、区间选点问题</li>
</ul>
</li>
</ul>
<h3 id="1-4二分"><a href="#1-4二分" class="headerlink" title="1.4二分"></a>1.4二分</h3><ul>
<li><p>查找序列<strong>是否存在</strong>满足条件的元素（常规二分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格递增序列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == x)	<span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &gt; x) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>	left = mid + <span class="number">1</span>;		<span class="comment">// A[mid] &lt; x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">// 查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>查找序列<strong>第一个满足</strong>条件的元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列从左到右先不满足，后满足</span></span><br><span class="line"><span class="comment">// 若存在，返回的是元素的位置</span></span><br><span class="line"><span class="comment">// 若不存在，返回的是“假设存在，它应在的位置”</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)	<span class="comment">// 此时才有区间</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (条件成立)	<span class="comment">// 满足条件，则第一个满足的在[left, mid]之间</span></span><br><span class="line">            right = mid		<span class="comment">// 因为mid也满足，所以不是mid-1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;	<span class="comment">// left==right时退出循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于左开右闭的区间<code>(left, right]</code>，二分条件就是<code>while ((left + 1 &lt; right)</code></p>
<p>对于左闭右开<code>[left, right)</code>，二分条件是<code>while (left &lt; right - 1)</code></p>
</li>
<li><p>二分拓展</p>
<ul>
<li><p>计算单调函数<code>f(x)=0</code>的根（近似）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// f(x)递增</span></span><br><span class="line"><span class="keyword">double</span> f(<span class="keyword">double</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ...; <span class="comment">// 函数值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> left, <span class="keyword">double</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (right - left &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(mid) &gt; <span class="number">0</span>) 	<span class="comment">// 若递减，把&gt;改为&lt;</span></span><br><span class="line">            right = mid;	<span class="comment">// 往[left, mid]逼近</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            left = mid;		<span class="comment">// 往[mid, right]逼近</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>快速幂（求$a^b\%m$，O(logb)）</p>
<p>递归写法</p>
<ol>
<li>如果b是奇数（$b \&amp; 1$），$a^b = a * a^{b - 1}$</li>
<li>如果b是偶数，$a^b = a^{b/2} * a^{b / 2}$</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(logb)</span></span><br><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a, LL b, LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)	<span class="comment">// 奇数</span></span><br><span class="line">        <span class="keyword">return</span> a * binaryPow(a, b - <span class="number">1</span>, m) % m;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LL mul = binaryPow(a, b / <span class="number">2</span>, m);</span><br><span class="line">        <span class="keyword">return</span> mul * mul % m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代写法：</p>
<p>b可以写成若干二次幂的和，如$2^{13} = 2^{(1101)_2} = 2^8 <em> 2^4 </em> 2^1$</p>
<p>当二次幂$i$号位被选中（中间的式子），那么$a^{2i}$就被选中（右边的式子）</p>
<ol>
<li>判断b的二进制末尾是否为1，是则令ans*a</li>
<li>a自乘，相当于进入下一位的判断和计算</li>
<li>b右移一位，和2的作用类似</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a, LL b, LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)	<span class="comment">// b的二进制末尾为1</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans * a % m;	<span class="comment">// 用b的二进制计算幂</span></span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % m;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;		<span class="comment">// b右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>​                注：任何正整数对1取模一定为0</p>
<h3 id="1-5-Two-Pointer"><a href="#1-5-Two-Pointer" class="headerlink" title="1.5 Two Pointer"></a>1.5 Two Pointer</h3><p>Two Pointer即双指针，用两个指针（或下标）一同访问一个序列，加快速度</p>
<h4 id="1-5-1-归并排序"><a href="#1-5-1-归并排序" class="headerlink" title="1.5.1 归并排序"></a>1.5.1 归并排序</h4><p>two pointer思想：merge中，两个数组两个指针</p>
<p>2-路归并排序的核心是将两个有序的数组合并为一个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span> L2, <span class="keyword">int</span> R2)</span>		<span class="comment">// [L1,R1]是左半边，L2=R1+1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = L1, j = L2;</span><br><span class="line">    <span class="keyword">int</span> temp[MAXN], index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= R1 &amp;&amp; j &lt;= R2)		<span class="comment">// 合并</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt;= A[j])</span><br><span class="line">            temp[index++] = A[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[index++] = A[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= R1)</span><br><span class="line">        temp[index++] = A[i++];		<span class="comment">// 加入剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= R2)</span><br><span class="line">        temp[index++] = A[j++];		<span class="comment">// 加入剩余元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        A[L1 + i] = temp[i];		<span class="comment">// 合并后的序列赋值回A</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序O(nlogn)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(A, left, mid);		<span class="comment">// 排左子区间</span></span><br><span class="line">        mergeSort(A, mid + <span class="number">1</span>, right);	<span class="comment">// 排右子区间</span></span><br><span class="line">        merge(A, left, mid, mid + <span class="number">1</span>, right);	<span class="comment">// 合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-2快排"><a href="#1-5-2快排" class="headerlink" title="1.5.2快排"></a>1.5.2快排</h4><p>two pointer思想：partition中，一个数组、首尾双指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randPartition</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 随机轴 </span></span><br><span class="line">    <span class="comment">// rand()生成一个[0, RAND_MAX]的数</span></span><br><span class="line">    <span class="comment">// [0, RAND_MAX]-&gt;[0, 1]-&gt;[0, right-left]-&gt;[left, right]</span></span><br><span class="line">	<span class="keyword">int</span> p = (<span class="keyword">int</span>)round(<span class="number">1.0</span> * rand() / RAND_MAX * (right - left) + left);</span><br><span class="line">	swap(A[left], A[p]);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 切分，左边比轴小，右边比轴大</span></span><br><span class="line">	<span class="keyword">int</span> temp = A[left];</span><br><span class="line">	<span class="keyword">while</span>(left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; A[right] &gt; temp) right--;	<span class="comment">// 右往左找比轴小的</span></span><br><span class="line">		A[left] = A[right];	</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; A[left] &lt;= temp) left++;		<span class="comment">// 左往右找比轴大的</span></span><br><span class="line">		A[right] = A[left];	</span><br><span class="line">	&#125;</span><br><span class="line">	A[left] = temp;		<span class="comment">// left = right</span></span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line">	<span class="keyword">if</span> (L &lt; R)</span><br><span class="line">	&#123;</span><br><span class="line">		pivot = randPartition(L, R);	<span class="comment">// 切分</span></span><br><span class="line">		quickSort(L, pivot - <span class="number">1</span>);	<span class="comment">// 排左区间</span></span><br><span class="line">		quickSort(pivot + <span class="number">1</span>, R);	<span class="comment">// 排右区间</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));	<span class="comment">// 随机种子 </span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-其他高效技巧"><a href="#1-6-其他高效技巧" class="headerlink" title="1.6 其他高效技巧"></a>1.6 其他高效技巧</h3><ul>
<li><p>打表</p>
</li>
<li><p>递推（有时思考一下递推式比简单暴力高效很多）<br>“有几个PAT”：计算一个给定字符串包含多少个PAT</p>
<p>暴力计算会超时，但利用组合的思想，计算A左边的P数，乘以A右边的T数，就能得到一个A形成的PAT个数</p>
<p>例如 APPAPT，中间的A左边2个P，右边1个T，总共能形成2*1=2个PAT，将所有A的结果相加得到最终结果</p>
</li>
<li><p><strong>随机选择算法</strong>（求第K大的数）<br>此处有文字游戏：如1 2 3 4 5 6，有两种理解：1）第一大 1，第二大 2；2）第一大 6，第二大 5</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 期望时间O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">randSelect</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = randPartition(left, right);	<span class="comment">// 使用快排的randPartition</span></span><br><span class="line">	<span class="keyword">int</span> M = p - left + <span class="number">1</span>;	<span class="comment">// 位置p在[left,right]中排在第M位</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (K == M) </span><br><span class="line">        <span class="keyword">return</span> A[p];	<span class="comment">// 找到第K大元素</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (K &lt; M) </span><br><span class="line">        <span class="keyword">return</span> randSelect(A, left, p - <span class="number">1</span>, K);	<span class="comment">// 在左子区间</span></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> randSelect(A, p + <span class="number">1</span>, right, K - M);	<span class="comment">// 在右子区间的第K-M位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-数学问题"><a href="#2-数学问题" class="headerlink" title="2 数学问题"></a>2 数学问题</h2><h3 id="简单数学"><a href="#简单数学" class="headerlink" title="简单数学"></a>简单数学</h3><ul>
<li>数字黑洞</li>
</ul>
<h3 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小公倍数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">    <span class="comment">// 可能溢出，也可写为 return a / gcd(a, b) * b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分数四则运算"><a href="#分数四则运算" class="headerlink" title="分数四则运算"></a>分数四则运算</h3><h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><p>素数：不能被其他数整除的数（<code>n%i!=0</code>）</p>
<p>求素数表</p>
<ul>
<li><p>遍历1-sqrt(n)，复杂度为O(n * sqrt(n))</p>
</li>
<li><p>质数筛</p>
<ul>
<li><p>埃氏(O(nloglogn))：对每个质数，筛去其倍数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">// i既可能是待存质数，同时也作为筛 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) </span><br><span class="line">		&#123;</span><br><span class="line">			p[++p[<span class="number">0</span>]] = i;	<span class="comment">// p[0]为cnt</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= MAXN; j += i)</span><br><span class="line">				vis[j] = <span class="literal">true</span>;</span><br><span class="line">		&#125;	 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>欧拉筛(O(n))：在埃氏筛的基础上，每个合数只被其最小质因子筛去，避免重复</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 存质数 </span></span><br><span class="line">		<span class="keyword">if</span> (!vis[i])</span><br><span class="line">			p[++p[<span class="number">0</span>]] = i;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 筛：筛去i * p[j]</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p[<span class="number">0</span>] &amp;&amp; i * p[j] &lt;= MAXN; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i * p[j]] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>)	<span class="comment">// 以后会由质因子筛到，避免重复 </span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键语句<code>if ((i % p[j]) == 0) break;</code>的理解：</p>
<ol>
<li>当$i \% p[j]$时，令$i = k <em> p[j]$，继续往下执行，即筛$i </em> p[j+1]$，而此时有$i <em> p[j+1] = p[j] </em> k <em> p[j+1]$，即$i </em> p[j+1]$会在$i’=k <em> p[j+1]$时由$p[j]$筛掉，此时属于重复操作，违背由<em>*最小质因子</em></em>筛去的法则。对于$p[j+2], … p[j+m]$类同，因而中断循环</li>
</ol>
<p>注意！！！<code>i % p[j]</code><strong><code>== 0</code></strong>才表示<code>p[j]</code>整除<code>i</code>！！！</p>
</li>
</ul>
</li>
</ul>
<h3 id="大整数运算"><a href="#大整数运算" class="headerlink" title="大整数运算"></a>大整数运算</h3><p>由于大整数运算从低位开始，而字符串读入从高位，因此在转换时要记得<strong>反置</strong></p>
<ul>
<li><p>大整数结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigN</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num[MAXN];</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 初始化函数</span></span><br><span class="line">	BigN()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">		len = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BigN <span class="title">add</span><span class="params">(BigN a, BigN b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BigN c;</span><br><span class="line">	<span class="keyword">int</span> carry = <span class="number">0</span>;	<span class="comment">// 进位</span></span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len || i &lt; b.len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		res = a.num[i] + b.num[i] + carry;</span><br><span class="line">		c.num[c.len++] = res % <span class="number">10</span>;</span><br><span class="line">		carry = res / <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 末尾进位</span></span><br><span class="line">	<span class="keyword">if</span> (carry != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		c.num[c.len++] = carry;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>减法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设a &gt; b，如果a &lt; b需交换a、b并在前面加-号</span></span><br><span class="line"><span class="function">BigN <span class="title">sub</span><span class="params">(BigN a, BigN b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BigN c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len || i &lt; b.len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a.num[i] &lt; b.num[i])</span><br><span class="line">		&#123;</span><br><span class="line">			a.num[i] += <span class="number">10</span>;</span><br><span class="line">			a.num[i+<span class="number">1</span>] -= <span class="number">1</span>;	<span class="comment">// 由于a &gt; b，if不会在i=len时成立，所以不会越界 </span></span><br><span class="line">		&#125;</span><br><span class="line">		c.num[c.len++] = a.num[i] - b.num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (c.len &gt; <span class="number">1</span> &amp;&amp; c.num[c.len<span class="number">-1</span>] == <span class="number">0</span>) 	<span class="comment">// 去除高位0但保留至少1位数</span></span><br><span class="line">        c.len--;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>高精度与低精度的乘法</p>
<ol>
<li>从低位遍历大整数，每位与低精度相乘，并加上已有进位</li>
<li>取个位数为结果，多位</li>
<li>循环直至遍历所有位，记得考虑最后的进位</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BigN <span class="title">mult</span><span class="params">(BigN a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BigN c;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a.num[i] * b + carry; <span class="comment">// 每位与低精度相乘，并加上已有进位</span></span><br><span class="line">        c.num[c.len++] = temp % <span class="number">10</span>;	<span class="comment">// 取个位数为结果</span></span><br><span class="line">        carry = temp / <span class="number">10</span>;	<span class="comment">// 高位为进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (carry != <span class="number">0</span>)	<span class="comment">// 最后的多位进位</span></span><br><span class="line">    &#123;</span><br><span class="line">        c.num[c.len++] = carry % <span class="number">10</span>;</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>高精度与低精度除法<br>注意：唯一从字符串反置后的高位开始遍历的计算（加减乘都是从低位），实际就是直接按输入的序</p>
<ol>
<li>商的位数和被除数（左边）的位数一一对应</li>
<li>遍历被除数的每一位，余数（初始化为0）和每次选取的位组成新的临时被除数</li>
<li>若除不了（小于除数），结果为0，进入下一位；若能除，记录商，更新余数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BigN <span class="title">divide</span><span class="params">(BigN a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BigN c;</span><br><span class="line">    c.len = a.len;	<span class="comment">// 商和被除数每一位一一对应</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)	<span class="comment">// 从高位开始遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp * <span class="number">10</span> + a.num[i];	<span class="comment">// 本次选择的位与上一位遗留的余数组合</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; b)	c.num[i] = <span class="number">0</span>;	<span class="comment">// 不够除，该位为0</span></span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">// 够除</span></span><br><span class="line">        &#123;</span><br><span class="line">            c.num[i] = temp / b;	<span class="comment">// 商</span></span><br><span class="line">            temp = temp % b;	<span class="comment">// 该位遗留的余数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r = temp;	<span class="comment">// 最终余数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (c.len &gt; <span class="number">1</span> &amp;&amp; c.num[c.len - <span class="number">1</span>] == <span class="number">0</span>) c.len--;	<span class="comment">// 去除高位0但至少保留1位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h3><ul>
<li><p>求<code>n!</code>中有多少个质因子<code>p</code>O(logn)<br>结论：<code>n!</code>中有$\frac{n}{p}+\frac{n}{p^2}+\frac{n}{p^3}+…$个质因子<code>p</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可用于计算<code>n!</code>末尾有多少个0：计算质因子5的个数</p>
</li>
<li><p>求组合数$C_{n}^{m}$</p>
<ol>
<li><p><del>定义计算（阶乘）</del>（long long也只能承受n&lt;20的数据）</p>
</li>
<li><p>递推公式：$C_n^m = C_{n-1}^m + C_{n-1}^{m-1}$，$C_n^0 = C_n^n = 1$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || n == m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> C(n<span class="number">-1</span>, m) + C(n<span class="number">-1</span>, m<span class="number">-1</span>);	<span class="comment">// 可以储存计算结果防止重复计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用定义，边除边乘，$C_{n+m-i}^{i}=\frac{(n-m+1)<em>(n-m+2)</em>…<em>(n-m+i)}{1</em>2<em>…</em>i}$一定是整数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans * (n - m + i) / i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="C-标准模板库STL"><a href="#C-标准模板库STL" class="headerlink" title="C++标准模板库STL"></a>C++标准模板库STL</h2><ul>
<li><p>注1：<br>无特殊说明，一般</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;[STL名字]&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<p>即可使用</p>
</li>
<li><p>注2：<br>STL嵌套，如果出现<code>&gt;&gt;</code>，记得在中间加空格：<code>&gt; &gt;</code>，否则c++11会将其识别为移位</p>
</li>
<li><p>注3：<br>STL的<code>find()</code>一般用<code>if (stl.find(x) != stl.end())</code>进行判断，<code>string</code>特殊，可以用<code>string::npos</code></p>
</li>
<li><p>```c++<br>count(stl.begin(), stl.end(), value);    // 计算value在stl中的个数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### vector</span><br><span class="line"></span><br><span class="line">- 定义</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  vector&lt;typename&gt; name;	// 一维变长</span><br><span class="line">  vector&lt;vector&lt;typename&gt;&gt; name;	// 二维变长</span><br><span class="line">  vector&lt;typename&gt; arrName[arrSize];	// 第一维定长，第二维变长</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素访问</p>
<ul>
<li>使用下标：<code>v[i]</code></li>
<li>迭代器：<ul>
<li><code>vector&lt;typename&gt;::iterator it</code>：类似指针，用<code>*it</code>访问元素</li>
<li><code>vi.begin()</code>, <code>vi.end()</code>：左闭右开。（只有vector和string可以使用<code>vi.begin()+i</code>的写法</li>
</ul>
</li>
</ul>
</li>
<li><p>常用函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi.push_back(x);	<span class="comment">// O(1)</span></span><br><span class="line">vi.pop_back();	<span class="comment">// O(1), 删除尾元素</span></span><br><span class="line">vi.<span class="built_in">size</span>();	<span class="comment">// O(1), 返回unsigned类型</span></span><br><span class="line">vi.<span class="built_in">clear</span>(); <span class="comment">// O(n), 清除vector中所有元素</span></span><br><span class="line">vi.insert(it, x);	<span class="comment">// O(n), 向it处插入一个元素</span></span><br><span class="line">vi.erase(it);	<span class="comment">// O(n), 删除it处的元素</span></span><br><span class="line">vi.erase(first, last)	<span class="comment">// O(n), 删除[first, last)内的所有元素, first, last为迭代器</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>内部自动有序且不含重复元素的<strong>集合</strong></p>
<ul>
<li><p>定义：和vector类似</p>
</li>
<li><p>元素访问<br>只能通过迭代器：<code>set&lt;typename&gt;::iterator it</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能按以下方式枚举，不支持*(it+i)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st.insert(x);	<span class="comment">// O(logn), 自动递增排序和去重</span></span><br><span class="line">st.<span class="built_in">find</span>(value);	<span class="comment">// O(logn), 返回值为value的迭代器it</span></span><br><span class="line">st.count(value);	<span class="comment">// 如果value在集合中，返回1，否则返回0</span></span><br><span class="line">st.erase(it);	<span class="comment">// O(1), 删除元素</span></span><br><span class="line">st.erase(value);	<span class="comment">// O(logn), 删除元素</span></span><br><span class="line">st.erase(first, last);	<span class="comment">/// O(n)</span></span><br><span class="line">st.<span class="built_in">size</span>();	<span class="comment">// O(1)</span></span><br><span class="line">st.<span class="built_in">clear</span>();	<span class="comment">// O(n)</span></span><br></pre></td></tr></table></figure></li>
<li>拓展：<code>multiset</code>, <code>unordered_set</code></li>
</ul>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用字符串常量初始化</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"abcd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字符数组初始化</span></span><br><span class="line"><span class="keyword">char</span> c[MAXN];</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(c)</span></span>;</span><br><span class="line"><span class="built_in">string</span> str1 = c;</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素访问</p>
<ul>
<li><p>直接像字符数组一样访问</p>
</li>
<li><p>直接输入输出，只能用<code>cin</code>和<code>cout</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用printf输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str.c_str());</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span>::iterator it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>常用函数</p>
<ul>
<li><p>operator+=（字符串拼接）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str3 = str1 + str2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>compare operator，按字典序比较</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (str1 &gt;= str2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str.length(); str.<span class="built_in">size</span>();	<span class="comment">// O(1), 二者基本相同</span></span><br><span class="line">str.insert(pos, str2);	<span class="comment">// O(N), 在pos下标处插入str2</span></span><br><span class="line">str.insert(it, first, last);	<span class="comment">//	O(N), 在原字符串it处插入串[first, last)</span></span><br><span class="line">str.erase(it);	<span class="comment">// O(N), 删除it指向的元素</span></span><br><span class="line">str.erase(first, last);</span><br><span class="line">str.erase(pos, length);	<span class="comment">// 从pos处删除length个字符(含本身)</span></span><br><span class="line">str.<span class="built_in">clear</span>();	<span class="comment">// O(1), 清空</span></span><br><span class="line">str.substr(pos, len);	<span class="comment">// O(len), 返回从pos开始、长度为len的子串</span></span><br><span class="line">str.<span class="built_in">find</span>(str2); <span class="comment">// O(nm), 如果str2是字串, 返回其在str第一次出现的位置, 否则返回string::npos(unsigned_int型, 值为-1)</span></span><br><span class="line">str.<span class="built_in">find</span>(str2, pos);	<span class="comment">// 从pos处开始匹配str2</span></span><br><span class="line"><span class="comment">// 常用写法：if (str.find(str2) != string::npos) 如果能找到, 则...</span></span><br><span class="line">str.replace(pos, len, str2); <span class="comment">// O(n), 把str从pos处开始、长度为len的子串替换为str2</span></span><br><span class="line">str.replace(first, last, str2);	<span class="comment">// 把str的[first, last)子串替换为str2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map内的键会按从小到大顺序自动排序（因为是基于红黑树实现），键唯一</p>
<p>注：</p>
<p>​    map无法按value排序，只能将<code>pair</code>放进<code>vector</code>里，对<code>vector</code>排序</p>
<ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;type1, type2&gt; mp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问</p>
<ul>
<li><p>直接使用下标（新值会覆盖旧值）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp[<span class="string">'c'</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过迭代器访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;type1, type2&gt;::iterator it;</span><br><span class="line">it-&gt;first;	<span class="comment">// 访问键</span></span><br><span class="line">it-&gt;second;	<span class="comment">// 访问值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>常用函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it = mp.<span class="built_in">find</span>(key);	<span class="comment">// O(logN), 返回键为key的迭代器it</span></span><br><span class="line">mp.insert(make_pair(value1, value2));</span><br><span class="line">mp.erase(it);	<span class="comment">// O(1), 删除元素</span></span><br><span class="line">mp.erase(key);	<span class="comment">// O(logN), 根据键删除</span></span><br><span class="line">mp.erase(first, last);	<span class="comment">// 删除一个区间的元素</span></span><br><span class="line">mp.<span class="built_in">size</span>();	<span class="comment">// O(1)</span></span><br><span class="line">mp.<span class="built_in">clear</span>(); <span class="comment">// O(N)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>拓展</p>
<ul>
<li><code>multimap</code>：一个键对多个值</li>
<li><code>unordered_map</code>：只映射不排序，比纯<code>map</code>快很多</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>hashmap可当作bool数组使用</li>
<li>map会自动初始化</li>
</ul>
</li>
</ul>
<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>先进先出</p>
<ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;type&gt; q;</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素访问<br>只能用<code>q.front()</code>或<code>q.back()</code>访问队首或队尾元素<br>（ps：访问前先使用<code>empty()</code>判断队是否空）</p>
</li>
<li><p>常用函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">q.push();	<span class="comment">// O(1)</span></span><br><span class="line">q.front(); q.back();	<span class="comment">// O(1)</span></span><br><span class="line">q.pop();	<span class="comment">// O(1) 队首出队</span></span><br><span class="line">q.empty();	<span class="comment">// O(1) 队列是否空</span></span><br><span class="line">q.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>拓展</p>
<ul>
<li>双端队列<code>deque</code>：首尾皆可插入和删除</li>
<li>优先队列<code>priority_queue</code>：堆实现，最大元素置于队首</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>通常通过重新定义一个队列来完成清空<code>O(1)</code></li>
</ul>
</li>
</ul>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>用堆实现，队首元素是当前队列中优先级最高的一个</p>
<ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">priority_queue&lt;type&gt; name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素访问<br>只能通过<code>top()</code>来访问队首元素（优先级最高）<br>（ps：使用<code>top()</code>前要用<code>empty()</code>判断队是否空）</p>
</li>
<li><p>常用函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pq.push(x);	<span class="comment">// O(logN), 入队</span></span><br><span class="line">pq.top();	<span class="comment">// O(1)</span></span><br><span class="line">pq.pop();	<span class="comment">// O(logN), 令队首元素出队</span></span><br><span class="line">pq.empty();	<span class="comment">// O(1), 队是否空</span></span><br><span class="line">pq.<span class="built_in">size</span>();	<span class="comment">// O(1)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优先级设置</strong></p>
<ul>
<li><p>基本数据类型<br>默认为大顶堆。小顶堆写法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt; [type], <span class="built_in">vector</span>&lt;[type]&gt;, greater&lt;[type]&gt; &gt; pq;</span><br></pre></td></tr></table></figure>
<p><code>vector&lt;[type]</code>：承载堆的容器；<code>greater&lt;[type]&gt;</code>：小于对应大优先级</p>
</li>
<li><p>结构体优先级</p>
<p>写在结构体内：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="comment">// 重载小于号</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> fruit&amp; f1, <span class="keyword">const</span> fruit&amp; f2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &lt; f2.price;	<span class="comment">// 价格大的优先级大, 相当大顶堆</span></span><br><span class="line">        <span class="comment">// return f1.price &gt; f2.price // 价格小的优先级大，即小顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;fruit&gt; pq;</span><br></pre></td></tr></table></figure>
<p>（<code>friend</code>友元允许非成员函数访问类/结构体的所有成员）</p>
<p>写在结构体外：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> fruit&amp; f1, <span class="keyword">const</span> fruit&amp; f2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &gt; f2.price;	<span class="comment">// 小顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;fruit, <span class="built_in">vector</span>&lt;fruit&gt;, cmp&gt; pq;</span><br></pre></td></tr></table></figure>
<p>注意：结构体指针的比较需另写struct cmp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Node* n1, <span class="keyword">const</span> Node* n2)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n1-&gt;v &gt; n2-&gt;v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Node*, <span class="built_in">vector</span>&lt;Node*&gt;, cmp&gt; pq;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>后进先出</p>
<ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;type&gt; name</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素访问<br><code>st.top()</code></p>
</li>
<li><p>常用函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">st.push(x);		<span class="comment">// O(1)</span></span><br><span class="line">st.top();		<span class="comment">// O(1)</span></span><br><span class="line">st.pop();		<span class="comment">// O(1)</span></span><br><span class="line">st.empty();		<span class="comment">// O(1)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他</p>
<ul>
<li>通常通过重新定义一个栈来完成栈的清空<code>O(1)</code></li>
</ul>
</li>
</ul>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>将两个元素合成为一个</p>
<ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line">pair&lt;type1, type2&gt; name;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">pair&lt;type1, type2&gt; p(value1, value2);</span><br><span class="line"><span class="comment">//临时构建</span></span><br><span class="line">pair&lt;type1, type2&gt;(value1, value2);	<span class="comment">// 方法一</span></span><br><span class="line">make_pair(value1, value2);		<span class="comment">// 方法二</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>元素访问</p>
<p>只有两个元素：<code>p.first</code>，<code>p.second</code></p>
</li>
<li><p>常用函数</p>
<ul>
<li>比较操作<br>直接使用比较符号如<code>&gt;=, !=</code>。首先比较<code>first</code>，只有当<code>first</code>相等时才去比较<code>second</code><br>（可类似<code>priority_queue</code>重写<code>&lt;</code>号）</li>
</ul>
</li>
<li><p>常见用途<br>作为map的键值对插入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.insert(make_pair(value1, value2));s</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="algorithm头文件下的常用函数"><a href="#algorithm头文件下的常用函数" class="headerlink" title="algorithm头文件下的常用函数"></a>algorithm头文件下的常用函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x, y为整数</span></span><br><span class="line"><span class="built_in">max</span>(x, y);</span><br><span class="line"><span class="built_in">min</span>(x, y);</span><br><span class="line"><span class="built_in">abs</span>(x);		<span class="comment">// 若想获取浮点数的绝对值，使用math头文件下的fabs</span></span><br><span class="line"></span><br><span class="line">swap(x, y);	<span class="comment">// 交换x和y的值</span></span><br><span class="line"></span><br><span class="line">reverse(it1, it2);	<span class="comment">// 使数组或STL的[it1, it2)之间的元素反转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span> a[N];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d%d%d..."</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]...);   </span><br><span class="line">&#125; <span class="keyword">while</span> (next_permutation(it1, it2));	<span class="comment">// 给出序列[it1, it2)在全排列中的下一个序列</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fill</span>(it1, it2, value);	<span class="comment">// 给数组或容器的某一段区间赋值value, 区别memset</span></span><br><span class="line"></span><br><span class="line">sort(it1, it2, cmp);	<span class="comment">// 默认升序</span></span><br><span class="line"></span><br><span class="line">lower_bound(it1, it2, val);	<span class="comment">// 寻找[it1, it2)内第一个值大于等于val的元素位置，返回指针/迭代器</span></span><br><span class="line">upper_bound(it1, it2, val);	<span class="comment">// 返回第一个大于val的元素位置</span></span><br><span class="line"><span class="comment">// ps: 如果没有该元素，返回的是可供插入的位置，即假设元素存在时其所在的位置</span></span><br><span class="line"><span class="comment">// 		若只想获得下标，令返回值减去数组首地址即可</span></span><br></pre></td></tr></table></figure>
<h2 id="数据结构专题"><a href="#数据结构专题" class="headerlink" title="数据结构专题"></a>数据结构专题</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;	<span class="comment">// 数据域</span></span><br><span class="line">    node* next;	<span class="comment">// 指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;	<span class="comment">// 用数组下标表示指针域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>空间分配</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C malloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">node* p = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line"></span><br><span class="line"><span class="comment">// c++ new</span></span><br><span class="line">node* p = <span class="keyword">new</span> node;</span><br></pre></td></tr></table></figure>
<p>(申请较大动态数组时可能会失败)</p>
<p><strong>内存泄漏</strong>：使用<code>malloc</code>或<code>new</code>分配的空间，使用后没有释放，直到程序结束前一直占据。</p>
<p>内存泄漏会导致内存消耗过快而最终五内存可使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C free</span></span><br><span class="line"><span class="built_in">free</span>(p);	<span class="comment">// p为指针变量，free释放p指向的空间，并将p指向NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="keyword">delete</span>(p);</span><br></pre></td></tr></table></figure>
<p><code>malloc</code>与<code>free</code>成对出现；<code>new</code>与<code>delete</code>成对出现</p>
</li>
<li><p>创建与增删</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node *p, *head;</span><br><span class="line">	</span><br><span class="line">	head = <span class="keyword">new</span> node;	<span class="comment">// 使用头节点，相当于数组的下标0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = <span class="keyword">new</span> node;</span><br><span class="line">		p-&gt;val = arr[i];</span><br><span class="line">		p-&gt;next = head-&gt;next;</span><br><span class="line">		head-&gt;next = p;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* head, <span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node* p = head;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// p移动到pos的前一个元素位置 </span></span><br><span class="line">	<span class="comment">// (p从head开始，i从0开始，i到达pos-1时，p也到达第pos-1个元素) </span></span><br><span class="line">    <span class="comment">// 使用头节点即可不用讨论在链表头插入的情况</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pos - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>; i++, p = p-&gt;next);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span> || i &gt; pos - <span class="number">1</span>)	<span class="comment">// i小于1或大于表长</span></span><br><span class="line">		<span class="keyword">return</span>;	</span><br><span class="line">    </span><br><span class="line">	node* q = <span class="keyword">new</span> node;</span><br><span class="line">	q-&gt;val = val;</span><br><span class="line">	q-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = q;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删(删除某一位置上的元素)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(node* head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node* p = head;</span><br><span class="line">	node* q = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 同insert寻找前元</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos - <span class="number">1</span>; i++, p = p-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	q = p-&gt;next;	<span class="comment">// 要删除q</span></span><br><span class="line">	p-&gt;next = q-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span>(q);	<span class="comment">// 与new成对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态链表排序<br>将有效结点前置，按升序排序。之后即可用数组下标访问链表，数组序即为排序后的链表序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义有效位</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, addr;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> valid;	<span class="comment">// 为true表示在链表上</span></span><br><span class="line">&#125;ls[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node&amp; n1, <span class="keyword">const</span> node&amp; n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n1.valid &amp;&amp; n2.valid)	<span class="comment">// 都是有效结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> n1.data &lt; n2.data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> n1.valid &gt; n2.valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort需要排所有元素（包括无效的）</span></span><br><span class="line">sort(ls, ls+maxn, cmp);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="搜索专题"><a href="#搜索专题" class="headerlink" title="搜索专题"></a>搜索专题</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>找“岔路口”与“死胡同”</p>
<p>比如背包问题，对每个物品，有选或不选两种选择即“岔路口”；物品重量总和超过V或已完成n个物品选择，就到达“死胡同”</p>
<p>用递归即可写出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> sumW, <span class="keyword">int</span> sumC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == n)	<span class="comment">// 完成选择 </span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    dfs(index + <span class="number">1</span>, sumW, sumC);	<span class="comment">// 岔路1：选</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sumW + w[index] &lt;= V)	<span class="comment">// 如果重量超过，到达死胡同</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sumC + c[index] &gt; <span class="built_in">max</span>) </span><br><span class="line">            <span class="built_in">max</span> = sumC + c[index];</span><br><span class="line">        </span><br><span class="line">        dfs(index + <span class="number">1</span>, sumW + w[index], sumC + c[index]);	<span class="comment">// 岔路2：不选</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>访问完所有邻接点，再往下层</p>
<p>一般用队列实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);	<span class="comment">// 起点入队</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取队首元素q.front();</span></span><br><span class="line">        <span class="comment">// *****访问*****</span></span><br><span class="line">        q.pop();	<span class="comment">// 队首出队</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (当前元素的邻接点x)</span><br><span class="line">            q.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迷宫问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增量数组</span></span><br><span class="line"><span class="keyword">int</span> X[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Y[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.push(S);</span><br><span class="line">    inq[S.x][S.y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取队首</span></span><br><span class="line">        node top = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (top.x == T.x &amp;&amp; top.y == T.y) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> top.<span class="built_in">step</span>;	<span class="comment">// 遇到终点返回, 此时就是最小步数</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 利用增量数组访问四个方向上的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> newX = top.x + X[i];</span><br><span class="line">            <span class="keyword">int</span> newY = top.y + Y[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(newX, newY) &amp;&amp; !inq[newX][newY])	<span class="comment">// 点合法且没入过队</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">Node <span class="title">node</span><span class="params">(newX, newY)</span></span>;</span><br><span class="line">                node.<span class="built_in">step</span> = top.<span class="built_in">step</span> + <span class="number">1</span>;	<span class="comment">// 步数增加</span></span><br><span class="line">                q.push(node);	<span class="comment">// 结点入队</span></span><br><span class="line">                inq[newX][newY] = <span class="literal">true</span>;	<span class="comment">// 标记结点已入过队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注<code>inq[x][y]</code>的含义是判断结点是否入过队，而非结点是否已被访问。如果使用后者定义会导致重复入队，进而造成重复访问</li>
<li><p>迷宫问题考虑的重点是：检查下一次可以走到的位置以及它们是否合法</p>
</li>
<li><p><a href="http://codeup.cn/problem.php?cid=100000609&amp;pid=2" target="_blank" rel="noopener">8数码难题</a>的启发</p>
<ul>
<li>将数字排列的矩阵，转换为一串整型数字，当作状态，用于剪枝。已到过该状态就无需再入队</li>
<li><code>sprintf</code>和<code>sscanf</code>处理字符串和数字间的转换</li>
</ul>
</li>
</ul>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>一些定义与概念</p>
<ul>
<li>结点、根结点、叶子结点、子树、边</li>
<li>层次：根节点为第1层，往下增；<ul>
<li>深度：即层数</li>
<li>高度：从最底层叶子结点（高度为1）向上逐层累加至该结点</li>
</ul>
</li>
<li>度<ul>
<li>结点的度：该结点子树的棵数，叶子结点的度为0</li>
<li>树的度：树中结点的最大的度</li>
</ul>
</li>
<li>祖先、子孙：自己既是自己的祖先结点，也是自己的子孙结点</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>概念</p>
<ul>
<li>递归定义：要么没有根节点，是一棵空树；要么由根节点、左子树、右子树组成，子树都是二叉树<br>（与度为2的树的区别：不能随意交换左右子树的位置）</li>
<li>满二叉树：每层结点个数都达到最大</li>
<li>完全二叉树：除最后一层，其余层节点数都达到最大</li>
</ul>
<p>定义与增删改查</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;</span><br><span class="line">    node* lch;</span><br><span class="line">    node* rch;</span><br><span class="line">&#125;;</span><br><span class="line">node* root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建节点</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">typename</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* p = <span class="keyword">new</span> node;</span><br><span class="line">    p-&gt;data = x;</span><br><span class="line">    p-&gt;lch = <span class="literal">NULL</span>; p-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改查</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* p, <span class="keyword">typename</span> x, <span class="keyword">typename</span> newData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == x)</span><br><span class="line">        root-&gt;data = newData;</span><br><span class="line">    </span><br><span class="line">    search(root-&gt;lch, x, newData);</span><br><span class="line">    search(root-&gt;rch, x, newData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（注意*root带引用）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">typename</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = newNode(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (xxx)	<span class="comment">// 根据性质</span></span><br><span class="line">        insert(root-&gt;lch, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        insert(root-&gt;rch, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">typename</span> data[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完全二叉树的递归创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* root = newNode(x);</span><br><span class="line">    root-&gt;lch = create(<span class="number">2</span> * x);		<span class="comment">// 递归创建左子树</span></span><br><span class="line">    root-&gt;rch = create(<span class="number">2</span> * x + <span class="number">1</span>);	<span class="comment">// 递归创建右子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序 中-左-右</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;x);</span><br><span class="line">    </span><br><span class="line">    preOrder(root-&gt;lch);</span><br><span class="line">    preOrder(root-&gt;rch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序 左中右</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    inOrder(root-&gt;lch);</span><br><span class="line">     <span class="comment">// 访问</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;x);</span><br><span class="line">    </span><br><span class="line">    inOrder(root-&gt;rch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序 左右中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    postOrder(root-&gt;lch);</span><br><span class="line">    postOrder(root-&gt;rch);</span><br><span class="line">    <span class="comment">// 访问</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">layerOrder</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">    </span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node* now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 访问</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (now-&gt;lch != <span class="literal">NULL</span>) q.push(now-&gt;lch);</span><br><span class="line">        <span class="keyword">if</span> (now-&gt;rch != <span class="literal">NULL</span>) q.push(now-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二叉树静态实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用数组下标代表指针，-1表示NULL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;</span><br><span class="line">    <span class="keyword">int</span> lch;</span><br><span class="line">    <span class="keyword">int</span> rch;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建结点</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node[index].data = v;</span><br><span class="line">    Node[index].lch = Node[index].rch = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其余的与指针表示一致</span></span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>有些题按层序标了号，要求计算一些特性，此时可能无需建树（只需假想一棵树），利用下标计算：<br>当前结点: x，<strong>左子: 2x</strong>，<strong>右子: 2x+1</strong>，<br>判断超出范围：2x &gt; n</li>
</ul>
<h3 id="一般的树"><a href="#一般的树" class="headerlink" title="一般的树"></a>一般的树</h3><p>尽量考虑静态写法，maxn为结点数上限</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sreuct node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typename</span> data;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;	<span class="comment">// 子结点下标</span></span><br><span class="line">&#125; Node[maxn];</span><br></pre></td></tr></table></figure>
<p>从树的遍历看DFS与BFS</p>
<ul>
<li>DFS：合法的DFS都能画出树的形式，“死胡同”等价于叶子结点；“岔路口”等价于非叶子结点，DFS遍历过程即树的<strong>先序遍历</strong>过程<br>从树的角度引入对状态的剪枝</li>
<li>BFS：即对树的层序遍历</li>
</ul>
<p>需要再看看的题目</p>
<ul>
<li>codeup_611_b 子结点计算</li>
<li>codeup_611_d 树重建（主要看指针方式存储树的创建）</li>
</ul>
<h3 id="二叉查找树-BST"><a href="#二叉查找树-BST" class="headerlink" title="二叉查找树 BST"></a>二叉查找树 BST</h3><p>也叫<strong>二叉排序树</strong></p>
<p>递归定义：</p>
<ul>
<li>要么是一棵空树</li>
<li>要么由根节点、左右子树构成，左子树上的结点小于根结点，右子树上的结点大于根节点</li>
</ul>
<p>性质：</p>
<ul>
<li>对二叉查找树进行<strong>中序遍历</strong>，遍历结果是<strong>有序</strong>的</li>
</ul>
<p>编码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找 O(h)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(node* root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)	<span class="comment">// 查找失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x == root-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> search(root-&gt;lch, x);	<span class="comment">// 小于则往左找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> search(root-&gt;rch, x);	<span class="comment">// 大于则往右找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入 O(h)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span>	<span class="comment">// 没有修改根节点的值, 而是为对应层的root赋予新的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)	<span class="comment">// 查找失败，即插入的位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = newNode(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x == root-&gt;data)	<span class="comment">// 查找成功，已存在该点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root-&gt;data)</span><br><span class="line">        insert(root-&gt;lch, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        insert(root-rch, x);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立</span></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        insert(root, data[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除比较难，单独记录一下：</p>
<p>删除结点v的基本思路是：使v的<strong>前驱</strong>（左子树的最大结点，即左子树最右结点）或<strong>后继</strong>（右子树的最小结点，即右子树的最左结点）覆盖v，然后递归删除前驱或后继</p>
<p>编码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">findMax</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Q: 为什么这里传指针，还能修改呢？</span></span><br><span class="line">	<span class="comment">// A: 因为没有改指针里的内容，将node*看成unsigned int，实际上传进来的是拷贝</span></span><br><span class="line">	<span class="keyword">while</span> (root-&gt;rch != <span class="literal">NULL</span>)</span><br><span class="line">		root = root-&gt;rch;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node* <span class="title">findMin</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (root-&gt;lch != <span class="literal">NULL</span>)</span><br><span class="line">		root = root-&gt;lch;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(node* root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)	<span class="comment">// 找不到，删除失败</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x == root-&gt;data)	<span class="comment">// 找到结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lch == <span class="literal">NULL</span> &amp;&amp; root-&gt;rch == <span class="literal">NULL</span>)	<span class="comment">// 叶子结点直接删除</span></span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;lch != <span class="literal">NULL</span>)	<span class="comment">// 左子树非空</span></span><br><span class="line">        &#123;</span><br><span class="line">			node* pre = findMax(root-&gt;lch);	<span class="comment">// 找到前驱	</span></span><br><span class="line">            root-&gt;data = pre-&gt;data;	<span class="comment">// 覆盖待删除结点</span></span><br><span class="line">            deleteNode(root-&gt;lch, pre-&gt;data);	<span class="comment">// 在左子树继续删除pre</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">// 右子树非空</span></span><br><span class="line">        &#123;</span><br><span class="line">            node* next = findMin(root-&gt;rch);</span><br><span class="line">            root-&gt;data = next-&gt;data;</span><br><span class="line">            deleteNode(root-&gt;rch, next-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root-&gt;data)	<span class="comment">// 小，往左找</span></span><br><span class="line">        deleteNode(root-&gt;lch, x);</span><br><span class="line">    <span class="keyword">else</span>						<span class="comment">// 大，往右找</span></span><br><span class="line">        deleteNode(root-&gt;rch, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：一直删除前驱或后继会导致树退化成一条链，解决办法有：</p>
<ol>
<li>交替删除前驱或后继</li>
<li>记录高度，总是优先在高度较高的一棵子树里删除结点</li>
</ol>
<h3 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树 AVL树"></a>平衡二叉树 AVL树</h3><p>使树高在每次插入后保持O(logn)级别</p>
<h4 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h4><p><strong>平衡因子</strong>：左子树与右子树的高度差（ps：高度从叶子开始计算，叶子为1）</p>
<p>为记录平衡因子，需要在树的结构中增加变量height：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    Node* lch, rch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* node = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="number">1</span>;	<span class="comment">// 初始树高为1</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取树高</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)	<span class="comment">// 空结点的高度为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算平衡因子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getHeight(root-&gt;lch) - getHeight(root-&gt;rch));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新树高</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 需要#include &lt;algorithm&gt;</span></span><br><span class="line">    root-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(getHeight(root-&gt;lch), getHeight(root-&gt;rch)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AVL树的重点是插入，需要考虑平衡的调整：</p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><ul>
<li><p>左旋：</p>
<ol>
<li>使B的左子树♦成为A的右子树</li>
<li>使A成为B的左子树、更新高度</li>
<li>根节点设置为B</li>
</ol>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309131148866.png" alt="image-20210309131148866"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftRotation</span><span class="params">(Node* &amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* temp = root-&gt;rch;</span><br><span class="line">    </span><br><span class="line">    root-&gt;rch = temp-&gt;lch;	<span class="comment">// 步骤1</span></span><br><span class="line">    temp-&gt;lch = root;		<span class="comment">// 步骤2</span></span><br><span class="line">    updateHeight(root);		<span class="comment">// 顺序别反，root此时是temp的子树</span></span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;			<span class="comment">// 步骤3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右旋</p>
<ol>
<li>使A的右子树成为B的左子树</li>
<li>使B成为A的右子树、更新高度</li>
<li>根节点设置为A</li>
</ol>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309132227795.png" alt="image-20210309132227795" style="zoom:80%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上就是把左旋的lch和rch颠倒</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rightRotation</span><span class="params">(Node* &amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* temp = root-&gt;lch;</span><br><span class="line">    </span><br><span class="line">    root-&gt;lch = temp-&gt;rch;		<span class="comment">// 步骤1</span></span><br><span class="line">    temp-&gt;rch = root;			<span class="comment">// 步骤2</span></span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;				<span class="comment">// 步骤3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>AVL插入即BST插入+平衡调整</p>
<p>平衡调整：将最靠近插入结点的失衡结点调整到正常</p>
<p>四种情况（左插LL、LR，右插RR、RL）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>树形</th>
<th>判定条件</th>
<th>调整方法</th>
<th>示图</th>
</tr>
</thead>
<tbody>
<tr>
<td>LL</td>
<td>BF(root) = 2, <br />BF(root-&gt;lch)  = 1</td>
<td>对root右旋</td>
<td><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309133417940.png" alt="image-20210309133417940" style="zoom:50%;" /></td>
</tr>
<tr>
<td>LR</td>
<td>BF(root) = 2, <br />BF(root-&gt;lch) = -1</td>
<td>对root-&gt;lch左旋，再对root右旋</td>
<td><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309133715663.png" alt="image-20210309133715663" style="zoom:50%;" /></td>
</tr>
<tr>
<td>RR</td>
<td>BF(root) = -2, <br />BF(root-&gt;rch) = -1</td>
<td>对root左旋</td>
<td><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309134048706.png" alt="image-20210309134048706" style="zoom:50%;" /></td>
</tr>
<tr>
<td>RL</td>
<td>BF(root) = -2,<br />BF(root-&gt;rch) = 1</td>
<td>对root-&gt;rch右旋，再对root左旋</td>
<td><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309134154099.png" alt="image-20210309134154099" style="zoom:50%;" /></td>
</tr>
</tbody>
</table>
</div>
<p>编码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = newNode(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x &lt; root-&gt;data)	<span class="comment">// 左插</span></span><br><span class="line">    &#123;</span><br><span class="line">        insert(root-&gt;lch, x);</span><br><span class="line">        updateHeight(root);		<span class="comment">// 插入后别忘了更新树高</span></span><br><span class="line">        <span class="keyword">if</span> (getBalanceFactor(root) == <span class="number">2</span>)	<span class="comment">// 失衡：左高于右</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (getBalanceFactor(root-&gt;lch) == <span class="number">1</span>)	<span class="comment">// LL</span></span><br><span class="line">            &#123;</span><br><span class="line">                rightRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (getBalanceFactor(root-&gt;lch) == <span class="number">-1</span>)	<span class="comment">// LR</span></span><br><span class="line">            &#123;</span><br><span class="line">                leftRotation(root-&gt;lch);</span><br><span class="line">                rightRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">// 大于或等于root，右插</span></span><br><span class="line">    &#123;</span><br><span class="line">        insert(root-&gt;rch, x);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        <span class="keyword">if</span> (getBalanceFactor(root) == <span class="number">-2</span>)	<span class="comment">// 失衡：右高于左</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (getBalanceFactor(root-&gt;rch) == <span class="number">-1</span>)	<span class="comment">// RR</span></span><br><span class="line">            &#123;</span><br><span class="line">                leftRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (getBalanceFactor(root-&gt;rch) == <span class="number">1</span>)	<span class="comment">// RL</span></span><br><span class="line">            &#123;</span><br><span class="line">                rightRotation(root-&gt;rch);</span><br><span class="line">                leftRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>知道如何插入后，AVL树的建立与查找就和BST无异了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意易错点：</p>
<ul>
<li><code>search</code>不要想复杂了，查找树按照大小选择子树查找，如果找不到，就是查找失败，无需考虑其他树上有没有该结点</li>
<li>涉及对root本身的修改要记得用指针引用<code>Node* &amp;root</code>，这里有<code>leftRotation</code>, <code>rightRotation</code>和<code>insert</code></li>
<li><code>insert</code>之后要记得<code>updateHeight</code></li>
</ul>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>结点的路径长度：从根结点到该结点所经过的边数</p>
<p>叶子的<strong>带权路径长度</strong>：叶子的权值乘以路径长度</p>
<p>树的带权路径长度：所有叶子结点的带权路径长度之和</p>
<p><strong>哈夫曼树</strong>：树的带权路径最小的二叉树（最优二叉树）</p>
<p>构建过程：</p>
<ol>
<li>初始n个结点，视为n棵只有1个结点的树</li>
<li>合并其中<strong>权值最小</strong>的两棵树，生成两棵子树的父结点，权值为两个根结点之和</li>
<li>重复步骤2，直到只剩下一棵树为止，这棵树即哈夫曼树，根结点的权值为最小带权路径长度</li>
</ol>
<p>哈夫曼树的构建思想核心为：反复选择两个<strong>最小的元素</strong>，合并，直到剩下一个元素。有时无需构建树，只需通过合并，得到最终带权路径长度即可。</p>
<p>哈夫曼编码：</p>
<ul>
<li>对任何一个叶子结点，其编号一定不会成为其他任何结点编号的前缀</li>
<li>左0右1</li>
<li>按频次作为权值，字符串编码为01串的长度即树的带权路径长度</li>
</ul>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210311163608746.png" alt="image-20210311163608746"></p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>定义</p>
<ul>
<li><p>并（Union）：合并两个集合；</p>
</li>
<li><p>查（Find）：查找，判断两个元素是否在同一集合；</p>
</li>
<li><p>集（Set）：集合</p>
</li>
</ul>
<p>性质：</p>
<ul>
<li>并查集产生的每个集合都是一棵树（因为只对不同集合进行合并，集合内不会有环）</li>
</ul>
<p>实现：</p>
<ul>
<li>用数组<code>father[i]</code>记录结点i的父节点；若<code>i=father[i]</code>，说明i是根节点。一个集合只有一个根结点，其是集合的标志</li>
</ul>
<p>编码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line">    fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="comment">//int findFather(int x)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    while (x != fa[x])</span></span><br><span class="line"><span class="comment">//        x = fa[x];</span></span><br><span class="line"><span class="comment">//    return x;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">// 使用路径压缩的查找根节点方法 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = x;</span><br><span class="line">    <span class="keyword">while</span> (root != fa[root])	<span class="comment">// 找到根结点</span></span><br><span class="line">        root = fa[root];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])		<span class="comment">// 回溯x走过的结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = x;</span><br><span class="line">        fa[tmp] = root;		<span class="comment">// 将它们的父节点都标记为根结点</span></span><br><span class="line">        x = fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span> (faA != faB)			<span class="comment">// 若根节点不同</span></span><br><span class="line">        fa[faA] = faB;		<span class="comment">// 将一方的根结点指向另一方的根结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合个数 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">   	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[i] == i)		<span class="comment">// 集合的标志是根结点，只需数根结点的个数</span></span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充路径压缩的示意图：</p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309224829582.png" alt="image-20210309224829582" style="zoom: 80%;" /></p>
<p>并查集模型的应用：</p>
<ul>
<li>输入一条边的两个点（双向边），使用<code>union</code>就能将两个点并在一个集合下，进而计数集合的个数或集合内元素个数</li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>定义</p>
<ul>
<li><p>堆是一棵<strong>完全二叉树</strong></p>
</li>
<li><p>大顶堆：树中每个结点的值都不小于孩子</p>
</li>
<li><p>小顶堆：不大于</p>
</li>
</ul>
<p>实现方式：用数组来存储完全二叉树，这样结点就按<strong>层序</strong>存储在数组中。第一个结点存于下标1，第i号的左孩子是<strong>2i</strong>，右孩子是<strong>2i+1</strong>，父亲是<strong>i/2</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> heap[MAXN];</span><br></pre></td></tr></table></figure>
<p>ps：如果不是强调自己实现堆，在可用STL的情况下，尽量用优先队列，不要造轮子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq;		<span class="comment">// 大顶堆</span></span><br><span class="line">priority_queue&lt; <span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; pq_s;	<span class="comment">// 小顶堆</span></span><br></pre></td></tr></table></figure>
<h3 id="向下调整"><a href="#向下调整" class="headerlink" title="向下调整"></a>向下调整</h3><ol>
<li>当前结点与其孩子比较，将其中权值大的孩子与V交换</li>
<li>继续让V与孩子比较，直到孩子的权值都比V小或没有孩子结点</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(logn)</span></span><br><span class="line"><span class="comment">// 对heap数组[low, high]范围进行调整</span></span><br><span class="line"><span class="comment">// low为预调整的结点下标，high为堆最后一个元素的下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = <span class="number">2</span> * i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high)	<span class="comment">// 存在孩子（左子不在右子肯定不在）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= hight &amp;&amp; heap[j+<span class="number">1</span>] &gt; heap[j])	<span class="comment">// 若存在右子，且右子大于左子</span></span><br><span class="line">            j = j + <span class="number">1</span>;		<span class="comment">// 令j为右子下标, j相当于max(左子, 右子)的下标</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (heap[j] &gt; heap[i])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(heap[j], heap[i]);	<span class="comment">// 交换</span></span><br><span class="line">            i = j;		<span class="comment">//	继续向下比较</span></span><br><span class="line">            j = <span class="number">2</span> * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;	<span class="comment">// 没有比结点i小的子结点，结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>完全二叉树的叶子结点个数为$\lceil \frac{n}{2} \rceil$,因此在$[1, \lfloor \frac{n}{2} \rfloor]$范围内的都是非叶子结点，</p>
<blockquote>
<p>n个结点的完全二叉树有性质 </p>
<p>1）n0+n1+n2=n（其中n0表示度为0的结点）<br>2）n0=n2+1</p>
<p>3）n1 = 0 或 1</p>
<p>综上可得n0 = $\lceil \frac{n}{2} \rceil$</p>
</blockquote>
<p>从$\lfloor \frac{n}{2} \rfloor$倒着枚举，对遍历到的结点$i$进行$[i, n]$范围的调整。</p>
<p>倒着调整是因为，每次调整一个结点后，当前子树中权值最大的结点就会处于子树的根结点位置（这正是向下调整的逻辑），轮到父节点调整时，又可以直接使用这一结果，保证了<strong>每个结点都是以其为根结点的子树的权值最大点</strong></p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210310212428242.png" alt="image-20210310212428242" style="zoom:67%;" /></p>
<p>记住结论即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        downAdjust(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除堆顶"><a href="#删除堆顶" class="headerlink" title="删除堆顶"></a>删除堆顶</h3><p>思路：用最后一个结点覆盖堆顶结点（根结点），然后对根结点向下调整</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(logn)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>] = heap[n--];</span><br><span class="line">    downAdjust(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="增添元素"><a href="#增添元素" class="headerlink" title="增添元素"></a>增添元素</h3><p>思路：把要添加的元素放在数组最后，然后向上调整</p>
<p><strong>向上调整</strong>：与父结点比较，如果比父节点大就交换，直到到达堆顶或父节点权值大为止</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(logn)</span></span><br><span class="line"><span class="comment">// low一般为1，high为欲调整结点的下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = high, j = i / <span class="number">2</span>;	<span class="comment">// j为父节点下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (j &gt;= low)	<span class="comment">//父节点在数组范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap[j] &lt; heap[i])	<span class="comment">// 父节点小</span></span><br><span class="line">        &#123;</span><br><span class="line">            swap(heap[j], heap[i]);		<span class="comment">// 与父节点交换交换</span></span><br><span class="line">            i = j;		<span class="comment">// 继续向上调整</span></span><br><span class="line">            j = i / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(logn)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heap[++n] = x;</span><br><span class="line">    upAdjust(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>思路：取出堆顶元素，然后将堆的最后一个元素替换至堆顶，然后对堆顶向下调整</p>
<p>实际上为了节省空间，用原来存储heap的数组来存排序后的序列，所以用倒着遍历heap数组实现堆排序</p>
<ol>
<li>i从n开始遍历，直到堆只1个元素</li>
<li>访问到i，将i与堆顶交换</li>
<li>在[1, i-1]范围对堆顶进行向下调整</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(nlogn)</span></span><br><span class="line"><span class="comment">// 堆排序与快排有相同的时间复杂度，且不会退化</span></span><br><span class="line"><span class="comment">// 但堆排较快排的劣势是常数较大</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    createHeap();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--)	<span class="comment">// 遍历直到堆只剩1个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        swap(heap[<span class="number">1</span>], heap[i]);	<span class="comment">// 与堆顶交换</span></span><br><span class="line">        downAdjust(<span class="number">1</span>, i - <span class="number">1</span>);	<span class="comment">// 调整堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下</p>
<ul>
<li>倒着遍历：<ul>
<li>建堆：数组中已有数据，从$\lceil \frac{n}{2} \rceil$开始倒着遍历，对每个结点向下调整，建立起堆结构</li>
<li>堆排序：从结点n开始倒着遍历，和堆顶交换，对堆顶向下遍历，已访问的结点固定不再动</li>
</ul>
</li>
<li>调整<ul>
<li>向下调整：用于建堆、删除堆顶、堆排序。后二者是对堆顶向下调整，调整后，子树根结点就存放着最大元素</li>
<li>向上调整：用于插入时，将尾巴插入的结点调整到它的位置</li>
</ul>
</li>
</ul>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>定义：</p>
<ul>
<li><p>图由顶点和边组成：G(V, E)</p>
</li>
<li><p>有向图与无向图 </p>
</li>
<li><p>度：和顶点相连的边的条数；<br>入度：入边条数；出度：出边条数</p>
</li>
<li>权值：点权、边权</li>
</ul>
<h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><p>邻接矩阵：</p>
<ul>
<li><p>G[i][j]=1代表结点i和j之间有边，G[i][j]=0或-1表示无边</p>
</li>
<li><p>G[i][j]存放边权，对于不存在的边可设为0、-1或一个很大的数</p>
</li>
</ul>
<p>一般适用于顶点数目不大（不超过1000）的题目</p>
<hr>
<p>邻接表</p>
<p><code>Adj\[i\]</code>存放顶点<code>i</code>的所有<strong>出边</strong>组成的列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w;	<span class="comment">// 编号、边权</span></span><br><span class="line">    Node(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w) : v(_v), w(_w) &#123;&#125;	<span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[N];</span><br></pre></td></tr></table></figure>
<p>使用构造函数实现加边</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Adj[i].push_back(Node(<span class="number">3</span>, <span class="number">4</span>));	<span class="comment">// i和3之间的边，结点3的权值为4</span></span><br></pre></td></tr></table></figure>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>对无向图：</p>
<ul>
<li><strong>连通</strong>：两个顶点之间相互<strong>可达</strong></li>
<li><strong>连通图</strong>：图G(V, E)中任意两个顶点<strong>连通</strong></li>
<li><strong>连通分量</strong>：非连通图中的<strong>极大连通子图</strong></li>
</ul>
<p>对有向图：</p>
<ul>
<li><strong>强连通</strong>：两个顶点各有一条有向路径通向另一个顶点（即可达）</li>
<li><strong>强连通图</strong>：图G(V, E)中任意两个顶点<strong>强连通</strong></li>
<li><strong>强连通分量</strong>：非强连通图中的<strong>极大强连通子图</strong></li>
</ul>
<hr>
<h4 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h4><p>邻接表版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（ps：其本质还是递归边界和递归式，不过递归边界隐藏在邻接点访问和vis[]数组中，</span></span><br><span class="line"><span class="comment">// 没有点可访问了就到了递归边界）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 访问结点u</span></span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	...访问细节</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问u的邻接点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = adj[u][i];</span><br><span class="line">        <span class="keyword">if</span> (!vis[v])</span><br><span class="line">            DFS(v, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTravel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历所有连通块</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[u])</span><br><span class="line">            DFS(u, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无向图、邻接矩阵存储，涉及边权的累计：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span>&amp; totalW)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[u] = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	访问...</span></span><br><span class="line"><span class="comment">   	*/</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;nump; v++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (G[u][v] &gt; <span class="number">0</span>)	<span class="comment">// 如果有边</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 累计边权 </span></span><br><span class="line">			totalW += G[u][v];</span><br><span class="line">			G[u][v] = G[v][u] = <span class="number">0</span>;	<span class="comment">// ***/删除边，防止回头，因为此处不考虑是否访问过</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// dfs访问 </span></span><br><span class="line">			<span class="keyword">if</span> (!vis[v])</span><br><span class="line">				DFS(v, totalW);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h4><p>之前介绍过了，这里只放图的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵版</span></span><br><span class="line"><span class="keyword">int</span> n, G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">bool</span> inq[MAXV] = &#123;<span class="literal">false</span>&#125;;	<span class="comment">// 是否入过队</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 有边且未入过队</span></span><br><span class="line">            <span class="keyword">if</span> (!inq[v] &amp;&amp; G[u][v] != INT_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                inq[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表版 参考搜索专题</span></span><br></pre></td></tr></table></figure>
<p>注意：清空<code>inq</code>数组时，要对整个MAXV长度清空，否则后面来的如果访问顶点数大于前者</p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><p>算法流程：</p>
<ol>
<li>从未访问过的点集（V-S）中找到一个与起点距离最小的点u</li>
<li>u作为中介点，对起点s 与 所有从u能到达的未访问顶点 进行relaxing（松弛）操作</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">int</span> d[MAXV];</span><br><span class="line"><span class="keyword">int</span> pre[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d, d+MAXV, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取与顶点距离最小的点</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minD = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; d[j] &lt; MIN)</span><br><span class="line">            &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minD = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>)	<span class="comment">// 找不到点，说明剩下的点不连通</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 松弛操作</span></span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF &amp;&amp; d[u] + G[u][v] &lt; d[v])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + G[u][v];</span><br><span class="line">                pre[v] = u;		<span class="comment">// 记录前驱结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归输出最短路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s, pre[v]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三种可能的第二标尺（多条最短路径时的其他衡量标准）：</p>
<p>只需在relaxing操作中进行修改</p>
<ul>
<li><p>新增边权（如花费）<br>初始化合数组d相同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[v] = d[u] + G[u][v];</span><br><span class="line">            c[v] = c[u] + cost[u][v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + G[u][v] == d[v] &amp;&amp; c[u] + cost[u][v] &lt; c[v])	<span class="comment">// 多条</span></span><br><span class="line">            c[v] = c[u] + cost[u][v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增点权（如每个点的资源）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// w[u]记录从起点s到点u收集的最大资源数（前提为路径最短）</span></span><br><span class="line"><span class="comment">// 初始化w[s]=weight[s]，其余w[u]=0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[v] = d[u] + G[u][v];</span><br><span class="line">            w[v] = w[u] + weight[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + G[u][v] == d[v] &amp;&amp; w[u] + weight[v] &gt; w[v])	<span class="comment">// 多条</span></span><br><span class="line">            w[v] = w[u] + weight[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求最短路径条数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[v] = d[u] + G[u][v];</span><br><span class="line">            num[v] = num[u];	<span class="comment">// 仅一条时，遵循上个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + G[u][v] == d[v])</span><br><span class="line">            num[v] += num[u];	<span class="comment">// 有多条不同的最短路通往v</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用Dij+dfs简化逻辑：</p>
<ol>
<li><p>使用dij记录下所有最短路径</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在relaxing操作中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[v] = d[u] + G[u][v];</span><br><span class="line">            pre[v].<span class="built_in">clear</span>();		<span class="comment">// 因为最短路已换，前驱需清空</span></span><br><span class="line">            pre[v].push_back(u);	<span class="comment">// 添加新的前驱</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + G[u][v] == d[v])</span><br><span class="line">            pre[v].push_back(u);	<span class="comment">// 记录多个前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历所有最短路径，找出第二标尺最优的路径<br>遍历过程相当于对终点为根结点，起点为叶子结点（可重复）的递归树的搜索</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[MAXV];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path, tempPath;</span><br><span class="line"><span class="keyword">int</span> optValue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> curValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == st)	<span class="comment">// 到达起点，形成一条倒着的完整最短路</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (curValue 优于 optValue)	<span class="comment">// 更新</span></span><br><span class="line">		&#123;</span><br><span class="line">			optValue = curValue;</span><br><span class="line">			path = tempPath;</span><br><span class="line">			path.push_back(v);		<span class="comment">// 别忘了添加起点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tempPath.push_back(v);	<span class="comment">// 加入临时的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre[v].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = pre[v][i];</span><br><span class="line">        dfs(u, curValue + value[u][v]);		<span class="comment">// 递归访问前驱结点，累计第二标尺的权值</span></span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.pop_back();	<span class="comment">// 删除结点v，因为要记录其他最短路</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：</p>
<ul>
<li>INF要用<code>const int INF = 1e9</code>定义，不要用<code>#define</code>，后者值为0，原因不明</li>
<li>所有的min都要记得初始化</li>
</ul>
<h4 id="Bellman-Ford与SPFA"><a href="#Bellman-Ford与SPFA" class="headerlink" title="Bellman-Ford与SPFA"></a>Bellman-Ford与SPFA</h4><p><strong>Bellman-Ford：</strong></p>
<p>邻接表实现为$O(VE)$，思路如下：</p>
<p>进行V-1轮操作，每轮对所有边松弛</p>
<p>最后一轮再对所有边松弛，如果仍能松弛，说明有原点可达的负环，返回false；否则返回true；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">d[s] = <span class="number">0</span>;	<span class="comment">// 起点为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (each edge e[u][v])</span><br><span class="line">        <span class="keyword">if</span> (d[u] + e[u][v] &lt; d[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[v] = d[u] + e[u][v];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (each edge e[u][v])</span><br><span class="line">    <span class="keyword">if</span> (d[u] + e[u][v] &lt; d[v])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>SPFA：</strong></p>
<p>邻接表实现为$O(kE)$，从B-F算法优化而来，思路如下：</p>
<p>只有当某个顶点d[u]的值改变时，从它出发的邻接点v的d[v]才有可能改变</p>
<p>因此建立一个队列，每次松弛后，如果顶点不在队中，将其入队。若入队次数超过V-1次，则存在负环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Node&gt; adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> d[MAXV], num[MAXV];</span><br><span class="line"><span class="keyword">bool</span> inq[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d, d + MAXV, INF);</span><br><span class="line">    <span class="comment">// 原点入队</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    inq[s] = <span class="literal">true</span>; num[s]++; d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 主体</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取队首</span></span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[u].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// relaxing</span></span><br><span class="line">            <span class="keyword">int</span> v = adj[u][v].v, dis = adj[u][v].dis;</span><br><span class="line">            <span class="keyword">if</span> (d[u] + dis &lt; d[v])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + dis;</span><br><span class="line">                <span class="keyword">if</span> (!inq[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    inq[v] = <span class="literal">true</span>; num[v]++;</span><br><span class="line">                    <span class="keyword">if</span> (num[v] &gt;= n)	<span class="comment">// 有可达负环</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用优先队列<code>priority_queue</code>进行优化</p>
<h4 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h4><p>全源最短路径算法，$O(n^3)$，n应限制在200以内</p>
<p>基本思想：枚举中介点k，使用k任意两个顶点进行松弛操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[MAXV][MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dis[<span class="number">0</span>], dis[<span class="number">0</span>] + MAXV * MAXV, INF);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 松弛</span></span><br><span class="line">                <span class="keyword">if</span> (dis[i][k] != INF &amp;&amp; dis[k][j] != INF</span><br><span class="line">                   &amp;&amp; dis[i][k] + dis[k][j] &lt; dis[i][j])</span><br><span class="line">                    dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小生成树MST"><a href="#最小生成树MST" class="headerlink" title="最小生成树MST"></a>最小生成树MST</h3><p>MST（Minimum Spanning Tree）</p>
<p>在给定无向图G中求一棵树T，T包含G中所有顶点，且边都来自G，满足整棵树边权之和最小</p>
<ul>
<li>作为树，MST有：边数=顶点数-1</li>
<li>MST不唯一，但边权之和一定为1</li>
<li>一般给定一个根结点求最小生成树</li>
</ul>
<h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><p>复杂度$O(V^2)$，优先队列优化能达到$O(VlogV)$</p>
<p>基本思想：</p>
<ol>
<li><p>集合S存放已访问结点，每次从V-S中选择与S距离最小的点u，将该距离最小的边加入MST，并将u加入S</p>
</li>
<li><p>令顶点u为中介，优化 所有u的邻接点 与 集合S 之间的最短距离</p>
</li>
<li><p>循环n次后，即得到MST</p>
</li>
</ol>
<p>（Prim与Dij的思想几乎相同，区别只有：Prim松弛的是邻接点到集合S的距离，Dij松弛的是邻接点到起点之间的距离；在代码中体现为数组d[i]的意义）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">int</span> d[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fill</span>(d, d + MAXV, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minD = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; d[j] &lt; minD)</span><br><span class="line">            &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minD = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        ans += d[u];		<span class="comment">// 累计MST的边权</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF)	<span class="comment">// 未访问过的邻接点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (G[u][v] &lt; d[v])		<span class="comment">// 如果能松弛到S的距离</span></span><br><span class="line">                &#123;</span><br><span class="line">                    d[v] = G[u][v];		</span><br><span class="line">                    <span class="comment">// 如果需要记录边，在这里记录，将d[v]和边u-&gt;v放入一个结构体中存储</span></span><br><span class="line">                &#125;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><p>复杂度$O(ElogE)$，开销来自于边排序</p>
<p>基本思想：边贪心策略</p>
<p>​    每次选择图中最小边权的边，如果加入不成环（边两端顶点在不同连通块中），就把边加入MST中</p>
<p>实现：使用并查集判断是否成环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 边结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">&#125; E[MAXE];</span><br><span class="line"><span class="comment">// 边排序使用的比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost &lt; b.cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="keyword">int</span> fa[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span>	<span class="comment">// n顶点数，m边数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, nEdges = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 并查集初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    <span class="comment">// 边排序</span></span><br><span class="line">    sort(E, E + m, cmp);</span><br><span class="line">    <span class="comment">// 遍历所有边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> faU = findFather(E[i].u);</span><br><span class="line">        <span class="keyword">int</span> faV = findFather(E[i].v);</span><br><span class="line">        <span class="keyword">if</span> (faU != faV)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[faU] = faV;		<span class="comment">// 集合合并</span></span><br><span class="line">            ans += E[i].cost;	<span class="comment">// MST边权累加</span></span><br><span class="line">            nEdges++;		<span class="comment">// MST的边数累加</span></span><br><span class="line">            <span class="keyword">if</span> (nEdges == n - <span class="number">1</span>)	<span class="comment">// 边数等于顶点数-1时，完成MST构建</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nEdges != n - <span class="number">1</span>)	<span class="comment">// 无法连通</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结</p>
<ul>
<li>prim和dij思想相近，都是不断优化<code>d[]</code>，复杂度与顶点数有关，适用于稠密图（边多点少）</li>
<li>kruskal使用边贪心策略，并查集判断是否成环，复杂度与边数有关，适用于稀疏图（边少点多）</li>
</ul>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>有向无环图（Directed Acyclic Graph， <strong>DAG</strong>）：有向、无环（任意点都无法通过边回到自身）</p>
<p>拓扑排序：将DAG图的所有顶点排成一个序列，如果存在边u-&gt;v，则序列中u一定在v之前</p>
<p>算法步骤：</p>
<ol>
<li>定义队列Q，将所有入度为0的结点入队</li>
<li>取队首结点输出，删去所有从它出发的边，并令边到达的结点入度-1</li>
<li>重复直到队空。如果入过队的结点数目为N，则排序成功；否则图中有环</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表实现</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXV];</span><br><span class="line"><span class="keyword">int</span> inDegree[MAXV];	<span class="comment">// 入度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toplogicalSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;	<span class="comment">// 记录加入拓扑序列的结点数</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)</span><br><span class="line">            q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取队首</span></span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 访问：输出结点，或加入数组</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, u);</span><br><span class="line">        num++;		<span class="comment">// 累计加入拓扑序列的结点个数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新邻接点的入度、入度为0的结点入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>)</span><br><span class="line">                q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">        G[u].<span class="built_in">clear</span>();	<span class="comment">// 清空出边，如无必要可不写</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (num == n);	<span class="comment">// 加入拓扑序列的点数为n，说明无环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>AOV（Activity On Vertex）网：顶点活动网，用顶点表示活动，边集表示活动间优先关系的有向图</p>
<p>AOE（Activity On Edge）网：边活动网，带权边集表示活动，顶点表示事件的有向图。边权表示活动所需时间</p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210313210932268.png" alt="image-20210313210932268" style="zoom:67%;" /></p>
<p>源点：入度为0的点，表示起始事件；</p>
<p>汇点：出度为0的点，表示终止事件</p>
<p><strong>关键路径</strong>：AOE网中的<strong>最长路径</strong>，关键路径上的活动称为关键活动，关键路径的长度等于工程<strong>最短完成时间</strong></p>
<ul>
<li>最长？从路径长度上看，选择不能拖延的活动，组成的就是最长的路径，比较对象是选择其他路径的方案</li>
<li>最短？从时间角度看，不能拖延的活动按照时间完成就是最短的时间，比较对象是活动中有拖延的方案</li>
</ul>
<hr>
<p>AOE网实际是DAG图</p>
<p>求解关键路径的问题即 求解DAG图中最长路径</p>
<p>四个关键的数组：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据</th>
<th>定义</th>
<th>计算</th>
<th>图示</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>e[r]</code></td>
<td>活动$a_r$的最早开始时间</td>
<td><strong>e[r] = ve[i]</strong></td>
<td><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210313212311647.png" alt="image-20210313212311647" style="zoom:67%;" /></td>
</tr>
<tr>
<td><code>l[r]</code></td>
<td>活动$a_r$的最迟开始时间</td>
<td><strong>l[r] = vl[j] - length[r]</strong></td>
<td><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210313212311647.png" alt="image-20210313212311647" style="zoom:67%;" /><br />（活动r最迟开始时间+活动时间=事件j最迟发生时间）</td>
</tr>
<tr>
<td><code>ve[i]</code></td>
<td>事件$i$的最早发生时间</td>
<td><strong>ve[j] = max{ve[ip] + length[rp]}</strong></td>
<td><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210313212537246.png" alt="image-20210313212537246" style="zoom:67%;" /><br />（所有前驱事件发生、活动完成之后，Vj才能被激活，最后完成的是max）</td>
</tr>
<tr>
<td><code>vl[i]</code></td>
<td>事件$i$的最迟发生时间</td>
<td><strong>vl[i] = min{vl[jk] - length[rk]}</strong></td>
<td>（图中用了逆拓扑展示）<br /><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210313213046547.png" alt="image-20210313213046547" style="zoom:67%;" /><br />（事件i的最迟发生，加上活动时间，不能影响到任何后继事件，最先影响到的是min）</td>
</tr>
</tbody>
</table>
</div>
<p>编码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序，并计算ve</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; topOrder;	<span class="comment">// 使用栈是为了获取逆拓扑序列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toplogicalSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)</span><br><span class="line">            q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        topOrder.push(u);	<span class="comment">// 拓扑序列入栈</span></span><br><span class="line">        <span class="comment">// 遍历邻接点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].v;</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>)</span><br><span class="line">                q.push(v);</span><br><span class="line">            <span class="comment">// 使用ve[u]更新所有后继结点v的最早开始时间ve[v]</span></span><br><span class="line">			<span class="comment">// 本质是松弛操作（反向）</span></span><br><span class="line">            <span class="keyword">if</span> (ve[u] + G[u][i].w &gt; ve[v])</span><br><span class="line">                ve[v] = ve[u] + G[u][i].w;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> (topOrder.<span class="built_in">size</span>() == n);	<span class="comment">// n个结点进入序列才为成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">criticalPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ve, <span class="number">0</span>, <span class="keyword">sizeof</span>(ve));</span><br><span class="line">    <span class="comment">// 拓扑排序的过程中计算ve</span></span><br><span class="line">    <span class="comment">// 如果不是DAG图，返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (!toplogicalSort())	</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取汇点的最早发生时间</span></span><br><span class="line">    <span class="comment">// 汇点i顶是最后发生的事件，所以一定ve最大</span></span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ve[i] &gt; maxLength)</span><br><span class="line">            maxLength = ve[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill</span>(vl, vl + n, maxLength);	<span class="comment">// 初始化事件最晚发生时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用逆拓扑序列，更新事件的vl数组</span></span><br><span class="line">    <span class="keyword">while</span> (!topOrder.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = topOrder.top();</span><br><span class="line">        topOrder.pop();</span><br><span class="line">        <span class="comment">// 使用u的后继结点的来更新u的最迟发生时间vl[u]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].v;</span><br><span class="line">            <span class="keyword">if</span> (vl[v] - G[u][v].w &lt; vl[u])</span><br><span class="line">                vl[u] = vl[v] - G[u][v].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算关键路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].v, w = G[u][i].w;</span><br><span class="line">            <span class="comment">// 计算活动最早开始时间e和最迟开始时间l</span></span><br><span class="line">            <span class="keyword">int</span> e = ve[u], l = vl[v] - w;</span><br><span class="line">            <span class="keyword">if</span> (e == l)		<span class="comment">// 如果e==l，说明活动u-&gt;v（即这条边）是关键活动</span></span><br><span class="line">                nextPath[u] = v; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找出源点</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(ve[i] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">            s = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出路径</span></span><br><span class="line">    <span class="keyword">while</span> (nextPath[s] != s)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"(%c,%c) "</span>, vertices[s], vertices[nextPath[s]]);</span><br><span class="line">    	s = nextPath[s];</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxLength;	<span class="comment">// 关键路径长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划-DP"><a href="#动态规划-DP" class="headerlink" title="动态规划 DP"></a>动态规划 DP</h2><ul>
<li>状态：记录当前信息；状态转移方程：根据之前的状态计算当前状态值<br>如何设计二者是DP的核心</li>
<li>最优子结构：问题最优解可以由子问题的最优解构造出来</li>
<li>状态的无后效性：当前状态一旦确定，不再改变。只有当前状态能影响下一状态，历史信息只能通过已有状态影响决策，而不直接参与决策</li>
</ul>
<p>分治与DP</p>
<ul>
<li>同：都分解为子问题</li>
<li>异：分治的子问题不重叠，DP的重叠</li>
</ul>
<p>贪心与DP</p>
<ul>
<li>同：都要求最优子结构</li>
<li>异：贪心壮士断腕，直接选择一个子问题往下求解；DP总会考虑所有子问题，选择继承能得到最优解的一个</li>
</ul>
<h3 id="最大连续子序列"><a href="#最大连续子序列" class="headerlink" title="最大连续子序列"></a>最大连续子序列</h3><p>给定数字序列$A_1, …, A_n$，求$i, j$使$A_1 + … + A_j$最大，输出这个和</p>
<p>暴力：$O(n^2)$，DP：$O(n)$</p>
<p>状态：<code>dp[i]</code>表示以A[i]为结尾的连续序列最大和</p>
<p>状态转移方程：<code>dp[i] = max(A[i], dp[i-1] + A[i])</code></p>
<ul>
<li>一个元素：A[i]</li>
<li>多个元素：前面最大和dp[i-1]加上当前A[i]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    dp[i] = <span class="built_in">max</span>(A[i], dp[i<span class="number">-1</span>] + A[i]);</span><br><span class="line"><span class="comment">// max(dp[1], ..., dp[n-1])即为结果</span></span><br></pre></td></tr></table></figure>
<h3 id="最长不下降子序列-LIS"><a href="#最长不下降子序列-LIS" class="headerlink" title="最长不下降子序列 LIS"></a>最长不下降子序列 LIS</h3><p>LIS（Longest Increasing Sequence）</p>
<p>给定一个数字序列，子u最长的非下降子序列长度（可以不连续）</p>
<p>暴力：$O(2^n)$， DP：$O(n^2)$</p>
<p>状态：<code>dp[i]</code> 表示以A[i]结尾的LIS长度</p>
<p>状态转移方程：<code>dp[i] = max{1, dp[j] + 1}</code>（j=1, 2,…, i-1 &amp;&amp; A[j] &lt;= A[i]）</p>
<ul>
<li>A[i]跟在A[j]后面，LIS长度+1</li>
<li>A[i]自己成为一条新的LIS，长度为1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[j] &lt;= A[i] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i])</span><br><span class="line">            dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// asn = max(dp[0],...dp[n-1])</span></span><br></pre></td></tr></table></figure>
<h3 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列 LCS"></a>最长公共子序列 LCS</h3><p>给定两个字符串A和B，求字符串s，使s使A和B的最长公共部分（可以不连续）</p>
<p>复杂度：$O(nm)$</p>
<p>状态：<code>dp[i][j]</code> 表示A的<code>i</code>号位和B的<code>j</code>号位之前的LCS长度</p>
<p>状态转移方程：<br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210315144750560.png" alt="image-20210315144750560" style="zoom:80%;" /></p>
<ul>
<li>如果A[i]==B[i]，LCS长度为增加1位</li>
<li>否则，继承<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>中较大的一个</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> A[MAXN], B[MAXN];</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN], p[MAXN][MAXN];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LU = <span class="number">0</span>, U = <span class="number">1</span>, L = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gets(A + <span class="number">1</span>);	<span class="comment">// 从下标1开始读入</span></span><br><span class="line">    gets(B + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> lenA = <span class="built_in">strlen</span>(A + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> lenB = <span class="built_in">strlen</span>(B + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lenA; i++)</span><br><span class="line">    	dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= lenB; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenA; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lenB; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == B[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">             	p[i][j] = LU;		<span class="comment">// 左上</span></span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &gt; dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                p[i][j] = U;		<span class="comment">// 上</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                p[i][j] = L;	<span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[lenA][lenB];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印最长公共子序列，printLCS(lenA, lenB)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLCS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[i][j] == LU)</span><br><span class="line">    &#123;</span><br><span class="line">        printLCS(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p[i][j] == U)</span><br><span class="line">        printLCS(i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printLCS(i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h3><p>复杂度：$O(n^2)$</p>
<p>状态：<code>dp[i][j]</code>表示S[i]到S[j]是否是回文串，是为1，不是为2</p>
<p>状态转移方程：<br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210315152211196.png" alt="image-20210315152211196" style="zoom:80%;" /></p>
<ul>
<li>若<code>S[i]==S[j]</code>，则只要<code>S[i+1]</code>至<code>S[j-1]</code>是回文串，<code>S[i]</code>至<code>S[j]</code>就是，因此继承<code>dp[i+1][j-1]</code></li>
<li>若<code>S[i]!=S[j]</code>，肯定不是回文串，<code>dp[i][j]=0</code></li>
</ul>
<p>采用<strong>区间dp</strong>实现，即两层循环，外层枚举子串长度L，内层枚举初始位置（左端点）i，右端点=i+L-1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;	<span class="comment">// 最大长度</span></span><br><span class="line"><span class="comment">// 边界</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">    dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; len - <span class="number">1</span> &amp;&amp; S[i] == S[i+<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        ans = <span class="number">2</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">3</span>; L &lt;= len; L++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + L - <span class="number">1</span> &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + L - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == S[j] &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            ans = L;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>
<h3 id="DAG最长路"><a href="#DAG最长路" class="headerlink" title="DAG最长路"></a>DAG最长路</h3><p>也即求关键路径，两个问题：</p>
<ol>
<li>整个DAG中的最长路径</li>
<li>固定终点，求DAG的最长路径</li>
</ol>
<h4 id="整个DAG中的最长路径"><a href="#整个DAG中的最长路径" class="headerlink" title="整个DAG中的最长路径"></a>整个DAG中的最长路径</h4><p>状态：<code>dp[i]</code>表示从i号结点出发能获得的最长路径长度</p>
<p>状态转换方程：<code>dp[i] = max{dp[j] + length[i-&gt;j]} (i,j)∈E</code></p>
<ul>
<li>因为是用后继结点<code>j</code>更新结点<code>i</code>，使用递归，代替逆拓扑序列求解</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i] &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[i][j] != INF)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = DP(j) + G[i][j];</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; dp[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = temp;</span><br><span class="line">                pathNext[i] = j;	<span class="comment">// 记录后继结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">criticalPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化dp[i]=0, 结点后继为本身</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">        pathNext[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp计算最长路径</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (DP(i) &gt; ans)</span><br><span class="line">        &#123;</span><br><span class="line">           ans = dp[i]; 	<span class="comment">// 更新最长路径</span></span><br><span class="line">            s = i;		<span class="comment">// 起始点</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印路径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, s);</span><br><span class="line">    <span class="keyword">while</span> (pathNext[s] != s)</span><br><span class="line">    &#123;</span><br><span class="line">        s = pathNext[s];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-&gt;%d"</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码还自动实现了取字典序最小的路径（因为是按结点从小到大遍历）</p>
<h4 id="固定终点的DAG最长路径"><a href="#固定终点的DAG最长路径" class="headerlink" title="固定终点的DAG最长路径"></a>固定终点的DAG最长路径</h4><p>状态：<code>dp[i]</code>表示从<code>i</code>出发到终点T的最长路径长度</p>
<p>状态转移方程：<code>dp[i] = max{dp[j] + length[i-&gt;j]} (i,j)∈E</code></p>
<ul>
<li>与前一个问题的方程相同，区别在对边界的定义：初始化所有dp[i]=-INF来表达不可达，dp[T]=0</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i])	<span class="comment">// 已访问过才能取值</span></span><br><span class="line">        <span class="keyword">return</span> dp[i];</span><br><span class="line">    </span><br><span class="line">    vis[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[i][j] != INF)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = DP(j) + G[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">criticalPath</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化dp[i]=-INF, dp[T]=0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = -INF;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[T] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DP(S);		<span class="comment">// 返回从起点S到终点T的关键路径长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>path选择以及最小字典序方案和上一个问题相同</p>
<p>总结：</p>
<ul>
<li><strong>不规定终点的DAG关键路径</strong>，dp[i]=0有两层意思：<br>1）如果是出度为0的点，从它出发的关键路径长度为0<br>2）出度不为0的点，表示未更新dp[i]，因此进入邻接点的遍历</li>
<li><strong>规定终点的关键路径问题</strong>，不能初始化所有dp[i]=0，因为并非所有点都可达T，所以初始化未-INF，并利用vis数组记录dp[i]是否更新</li>
<li><p><strong>不关心起点</strong>，因为dp[i]已经具有这层意思。<br>对于规定起点S的问题，返回DP(S)即可，<br>对于未规定起点的问题，取dp[i]最大的结果返回</p>
</li>
<li><p>用DAG的思路解决矩形嵌套问题：每个矩形看成一个顶点，嵌套关系视为有向边，边权为1，于是就能转换为DAG最长路问题</p>
</li>
</ul>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>多阶段动态规划问题：:arrow_right:问题可以描述成若干有序阶段，每个阶段（多个状态）只与上个阶段的状态有关</p>
<p>01背包就是多阶段DP问题</p>
<h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>DP：$O(nV)$</p>
<p>n件物品，容量V的背包，每件物品重w[i]，价值c[i]，问如何选取物品使背包内物品总价值最大（每个物品1件）</p>
<ol>
<li><strong>状态与最优子结构</strong><br><code>dp[i][v]</code>表示选择前i项物品装入容量v的背包的最大价值<ul>
<li>不放第i件物品：<code>dp[i][v]=dp[i-1][v]</code></li>
<li>放第i件物品：<code>dp[i][v] = dp[i-1][v-w[i]]+c[i]</code></li>
</ul>
</li>
<li><p><strong>状态转移方程</strong><br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316082007789.png" alt="image-20210316082007789" style="zoom: 80%;" /></p>
</li>
<li><p><strong>自底向上</strong><br>边界<code>dp[0][v]=0</code>（0件物品放入任何背包容量的价值都为0）<br>枚举<code>i&lt;-1 to n</code>，<code>v&lt;-w[i] to V</code></p>
</li>
</ol>
<p>编码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = w[i]; v &lt;= V; v++)</span><br><span class="line">        dp[i][v] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][v], dp[i - <span class="number">1</span>][v - w[i]] + c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化空间复杂度：</p>
<p>上一阶段的状态，用于计算当前阶段的状态后，就不再使用，因此可以用滚动数组，化为一阶数组表示当前状态</p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316084246846.png" alt="image-20210316084246846"></p>
<p>注意，自底向上的遍历必须<strong>逆序</strong>，因为如果正序遍历，<code>dp[v]</code>使用的<code>dp[v-w[i]]</code>是<code>i-1</code>阶段的状态，会造成错误。逆序保证了计算第<code>i</code>阶段的状态时使用的都是<code>i-1</code>阶段的状态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = V; v &gt;=w[i]; v--)</span><br><span class="line">        dp[v] = <span class="built_in">max</span>(dp[v], dp[v-w[i]] + c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>如果能划分阶段，可以尝试将阶段作为状态，将数组<strong>降一维</strong></li>
<li>如果设计的状态不满足无后效性，可以尝试将状态<strong>升维</strong>（多个阶段，每个阶段多个状态）来表达相应信息</li>
</ul>
<h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><p>与01背包的区别在于，每个物品有无穷件（可选择多次）</p>
<ol>
<li><p><strong>状态与最优子结构</strong><br><code>dp[i][v]</code>表示选择前i项物品装入容量v的背包的最大价值</p>
<ul>
<li>不放第i件物品：<code>dp[i][v]=dp[i-1][v]</code></li>
<li>放第i件物品：<code>dp[i][v] = dp[i][v-w[i]]+c[i]</code><br>注意此处转移到了第<code>i</code>阶段而非<code>i-1</code>阶段，因为放了第i件物品后还可以继续放</li>
</ul>
</li>
<li><p><strong>状态转移方程</strong><br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316091304532.png" alt="image-20210316091304532" style="zoom:80%;" />|<br>优化版：<br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316091330893.png" alt="image-20210316091330893" style="zoom:80%;" /></p>
</li>
<li>自底向上<br>对于优化版：边界：初始化所有dp[v]为0（即表示<code>dp[0][v]=0</code>）<br><strong>正向</strong>枚举<code>v&lt;-w[i] to V</code>，因为求解<code>dp[i][v]</code>总是需要它左边的<code>dp[i][v-w[i]]</code>，而上方的<code>dp[i-1][v]</code>在计算完后才会覆盖<br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316091619664.png" alt="image-20210316091619664" style="zoom:80%;" /></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = w[i]; v &lt;= V; v++)</span><br><span class="line">        dp[v] = <span class="built_in">max</span>(dp[v], dp[v - w[i]] + c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>当题目与序列或字符串<code>A</code>有关时，可以考虑状态设计：<ol>
<li>令<code>dp[i]</code>表示以<code>A[i]</code>结尾（或开头）的xxx</li>
<li>令<code>dp[i]</code>表示以<code>A[i]</code>至<code>A[j]</code>区间的xxx</li>
</ol>
</li>
</ul>
<ul>
<li><p>当题目包含某种”方向“的意思时，状态需要几个维度来表示，对每一维用以下描述</p>
<ol>
<li>恰好为<code>i</code></li>
<li>前<code>i</code></li>
</ol>
<p>令<code>dp</code>数组表示恰好为<code>i</code>（或前<code>i</code>）的xxx</p>
</li>
</ul>
<p>大多数情况都可以把DP问题看作一个有向无环图（DAG），结点是状态，边是状态转移方向，辅助理解</p>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>给出两个字符串<code>text</code>和<code>pattern</code>，判断<code>pattern</code>是否是<code>text</code>的子串</p>
<p>暴力法枚举起始点$O(nm)$，使用KMP能达到$O(n+m)$</p>
<p>求解next数组</p>
<ul>
<li><p><code>next[i]</code>定义：<br>使子串<code>s[0...i]</code>的前缀<code>s[0...k]</code>和后缀<code>s[i-k...i]</code>相等的<strong>最大的k</strong>（前后缀长度为k+1），也即最长相等前后缀的<strong>前缀最后一位的下标</strong></p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316125810982.png" alt="image-20210316125810982" style="zoom: 80%;" /><br>上框下划线画出匹配的前后缀，下框的第一行为前缀，第二行为后缀</p>
</li>
<li><p><strong>递推求解next[i]</strong>：<br>令<code>j=next[i-1]</code></p>
<ul>
<li><p>若<code>s[i] == s[j+1]</code>，最长相等前后缀可以扩展，长度+1，即<code>next[i]=j+1</code></p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316125722792.png" alt="image-20210316125722792"></p>
</li>
<li><p>若<code>s[i] != s[j+1]</code>，前后缀匹配失败，相等前后缀无法达到那么长，因此需要缩短一点。需要找出一个<code>j&#39;</code>，使得</p>
<ul>
<li>1） <code>s[i] == s[j&#39;+1]</code>成立</li>
<li>2） <code>s[0...j&#39;]</code>（下图3的~）是<code>s[i-j-1...i-1]</code>（下图3和~在一个框的上方的子串）的<strong>后缀</strong><br>因为<code>s[i-j-1..i-1] == s[0..j]</code>（由<code>j=next[i-1]</code>的意义决定，<code>j</code>是<code>s[0..i-1]</code>的最长前后缀匹配的前缀最后一位下标），所以只需满足<strong><code>s[0..j&#39;]</code>是<code>s[0..j]</code>的后缀</strong><br>从下面图片来理解就是：j=next[4]=2，需要找一个串<code>s[0..j&#39;]</code>，使得它是<code>s[2..4]=&quot;aba&quot;</code>的后缀（这样才能匹配成功），因为<code>s[2..4] == s[0..2]</code>（因为<code>next[4]=2</code>），所以也即<code>s[0..j&#39;]</code>需满足是<code>s[0..2]</code>后缀</li>
<li>3） <strong><code>s[0...j&#39;]</code>是<code>s[0...j]</code>的前缀</strong>（自动满足，因为是在<code>0..j</code>里找<code>j&#39;</code>）</li>
<li>4）<code>j&#39;</code>尽可能大</li>
</ul>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316131651669.png" alt="image-20210316131651669" style="zoom: 67%;" /></p>
<p>上面的要求2）3）4），正好就是<code>next[j]</code>的定义：<code>s[0..j]</code>最长相等前后缀的前缀下标<code>j&#39;</code>，因此只需让<strong><code>j&#39;=next[j]</code></strong>，判断<code>s[i]==s[j&#39;+1]</code>是否成立，不成立继续回退，直到<code>j&#39;=-1</code><br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316133601904.png" alt="image-20210316133601904" style="zoom: 67%;" /></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求解长度为len的字符串s的next数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 1. 让i在1~len-1范围内遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2.不断令j=next[j]，直到j回退到-1，或满足s[i]==s[i+1]</span></span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>])</span><br><span class="line">            j = next[j];</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 3. 若s[i]==s[j+1]，则next[i]=j+1，否则next[i]=j</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j+<span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>KMP算法</p>
<p>令i指向text的欲比较位，j指向pattern已被比较的最后一位</p>
<ul>
<li><p>若<code>text[i] == pattern[j+1]</code>，说明匹配成功，i、j自增，继续比较</p>
</li>
<li><p>若<code>text[i] != pattern[j+1]</code>，匹配失败，需要考虑<code>j</code>回退到哪，位置要满足以下条件：</p>
<ul>
<li>1）<code>text[i] == pattern[j&#39; + 1]</code>成立</li>
<li>2）<code>pattern[0..j&#39;]</code>仍然与<code>text</code>相应位置处于匹配状态，即<code>pattern[0..j&#39;]</code>是<code>text[i-1-j..i-1]</code>的后缀，由于之前匹配的结果有<code>text[i-1-j..i-1] == pattern[0..j]</code>，因此只需满足<strong><code>pattern[0..j&#39;]</code>是<code>pattern[0..j]</code>的后缀</strong></li>
<li>3）<code>pattern[0..j&#39;]</code>是<code>pattern[0..j]</code>的前缀（自动满足，因为是回退）</li>
<li>4）<code>j&#39;</code>尽可能大</li>
</ul>
<p>条件2）3）4）正是数组<code>next[j]</code>的定义，因此只需不断令<code>j&#39;=next[j]</code>，直到满足条件1）或<code>j&#39;=-1</code>为止。（逻辑与<code>next</code>数组的求解几乎一致）</p>
<p>从这个角度来看，<code>next</code>数组的含义就是当<code>j+1</code>位失配时，<code>j</code>应该回到的位置</p>
</li>
</ul>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316141313149.png" alt="image-20210316141313149" style="zoom:80%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> <span class="built_in">text</span>[], <span class="keyword">char</span> pattern[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(<span class="built_in">text</span>), m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    getNext(pattern, m);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 1. 遍历文本串text</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2. 不断令j=next[j]，直到j回退到-1，或text[i]==pattern[j+1]为止</span></span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; <span class="built_in">text</span>[i] != pattern[j+<span class="number">1</span>])</span><br><span class="line">            j = next[j];</span><br><span class="line">        <span class="comment">// 3. 若匹配，往前一位</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">text</span>[i] == pattern[j+<span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="comment">// 4. 若j达到pattern尾，说明是子串</span></span><br><span class="line">        <span class="keyword">if</span> (j == m - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>统计文本串<code>text</code>中<code>pattern</code>的出现次数（不是子串个数，如text=”ababab”中，pattern=”abab”出现了2次）</p>
<p>思路：</p>
<p>完全匹配一次pattern后，<code>j</code>需回退一定距离，使得不漏解且效率最高。由于<code>next[j]</code>的定义是最长前后缀匹配的前缀最后一位，完全匹配时<code>text[i-j..i] == pattern[0..j], j=m-1</code>，所以<strong>令<code>j=next[j]</code></strong>，在<code>next[j]</code>之前的位置都已完成匹配，省去了许多无意义的比较</p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316141352442.png" alt="image-20210316141352442" style="zoom:80%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> <span class="built_in">text</span>[], <span class="keyword">char</span> pattern[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(<span class="built_in">text</span>), m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    getNext(pattern, m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>; ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; <span class="built_in">text</span>[i] != pattern[j+<span class="number">1</span>])</span><br><span class="line">            j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">text</span>[i] == pattern[j+<span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (j == m - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            j = next[j];	<span class="comment">// 关键一步</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结</p>
<ul>
<li>计算<code>next</code>数组实际上是<code>pattern</code>自我匹配的过程</li>
<li>KMP的关键是<code>j</code>回退的位置<code>j=next[j]</code>，实质就是回到一个已知匹配的长度，从而省去从头开始比较的开销。容易模糊的地方是如何证明这个回去的位置是有效而且最优的，可以多看看上面的解释，思路就是递推求解代替逐项匹配</li>
<li>$O(n+m)$的开销：i和j的变化是$O(n)$的，计算next数组的开销是$O(m)$</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="中缀表达式计算"><a href="#中缀表达式计算" class="headerlink" title="中缀表达式计算"></a>中缀表达式计算</h3><p>1）中缀转换为逆波兰（后缀表达式）：</p>
<p>（使用队列存储）</p>
<ol>
<li><p>如果是数字，直接入队</p>
</li>
<li><p>如果是运算符op：如果运算符栈空，压入运算符栈，否则与栈顶比较优先级（用<code>map</code>记录优先级）：<br><strong>只有在遇到” ) “的情况下我们才弹出” ( “，其他情况我们都不会弹出” ( “</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(栈非空 &amp;&amp; 栈顶 != <span class="string">'('</span> &amp;&amp; op小于或等于栈顶)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 栈顶入队</span></span><br><span class="line">    <span class="comment">// 弹栈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 表达式中的op压栈</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果遇到一个右括号，则将栈元素弹出（入队），将弹出的操作符输出直到遇到左括号为止。<strong>注意，左括号只弹出并不输出。</strong></p>
</li>
<li><p>表达式扫描结束后，若运算符栈非空，从栈顶依次入队</p>
</li>
</ol>
<hr>
<p>2）逆波兰表达式运算：</p>
<p>（由队首依次出队）</p>
<ol>
<li>如果是数字，压栈</li>
<li>如果是运算符，取栈顶两个数字，运算，将结果压栈</li>
<li>队列扫描结束后，栈顶数字即最终结果</li>
</ol>
<hr>
<p>3）中缀表达式直接计算：<br>（使用数字栈和运算符栈）</p>
<ol>
<li>如果是数字，压栈</li>
<li>如果是运算符，同1），不过弹栈时，取数字栈顶两个元素运算后压栈，而非入队</li>
<li>同1），弹栈时运算而非入队</li>
</ol>
<h3 id="C语言变长参数函数写法"><a href="#C语言变长参数函数写法" class="headerlink" title="C语言变长参数函数写法"></a>C语言变长参数函数写法</h3><p>使用头文件<strong><code>&lt;stdarg.h&gt;</code></strong>实现，下面为用到的四个宏：</p>
<ul>
<li><code>va_list</code>：声明指向变长参数的指针ap</li>
<li><code>va_start(ap, arg)</code>：用于初始化变长参数指针ap的位置，arg为最后一个固定参数</li>
<li><code>va_arg(ap, type)</code>：ap传入变长参数指针，type为参数类型。函数返回ap当前指向的类型为type的参数，并将ap指向参数列表的下一个参数</li>
<li><code>va_end(ap)</code>：置ap为空指针</li>
</ul>
<p>变长参数函数的参数中，先填写若干个固定参数，然后在最后一个固定参数的逗号后方添加3个点，表示变长参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	va_list ap;</span><br><span class="line">	va_start(ap, num);</span><br><span class="line">	<span class="keyword">char</span>* str;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		str = va_arg(ap, <span class="keyword">char</span>*);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">	&#125;</span><br><span class="line">	va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	test(<span class="number">3</span>, <span class="string">"hello"</span>, <span class="string">"fxxking"</span>, <span class="string">"world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Debug思路"><a href="#Debug思路" class="headerlink" title="Debug思路"></a>Debug思路</h2><ul>
<li>注意考虑<strong>边界情况</strong>，如0、有质数的题考虑1</li>
<li>没有编码错误的情况下，找<strong>逻辑错误</strong>（代码是否和题目逻辑一致），着重检查循环里的数组下标<code>i,j,k</code></li>
<li>注意浮点数精度：<code>float</code>能保证6位，<code>double</code>能保证到15位。有时float错了可能double能过</li>
<li>可能没有考虑多组输入</li>
<li>格式问题，有些题目可能输出点个数为0时需<strong>输出空行</strong></li>
<li>无法调试可能的原因：<ul>
<li>内存爆了，减小<strong>MAXN</strong></li>
<li>添加查看了<strong>STL容器</strong></li>
</ul>
</li>
<li>声明<code>const char []</code>型数据时，一定要检查后面<strong>有没有添加<code>&#39;\0&#39;</code></strong>，否则可能会出现本地没问题但交上去WA的情况。比如：<code>const char ONE[2] = {&#39;1&#39;, &#39;\0&#39;};</code>能过，但<code>const char ONE[1] = {&#39;1&#39;};</code>在Linux环境下会出现怪数，但windows下结果正常</li>
<li>同阶<strong>时间复杂度</strong>的算法，实际表现可能有很大差异。比如<code>O(nlogn)</code>和<code>O(2nlog(2n))</code>。当RE时，可能其他同阶算法能过</li>
<li>sort的<strong>cmp函数</strong>中如果使用<code>return a &gt;= b</code>可能会有段错误（原因不明），改用<code>return a &gt; b</code>，不影响语义</li>
<li>多组输入，记得对每个用到的数据结构进行<strong>初始化</strong></li>
</ul>
<h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><ul>
<li><p>字符转数字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	num = num * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意先找规律，n很大的不要一上来就递归DP，很容易超时。有时可能往简单想能做出来</p>
</li>
<li><p>int的范围[-2147483648, 2147483647]，10个0就无法支持了，一般取INF=1e9</p>
</li>
<li><p><code>ceil()</code>：向上取整；<code>floor()</code>：向下取整；<code>round()</code>：四舍五入；三者都返回<code>double</code>值</p>
</li>
<li><p>万能库：<code>include &lt;bits/stdc++.h&gt;</code></p>
</li>
<li><p><code>long</code>和<code>int</code>都是4字节，<code>long long</code>才是8字节</p>
</li>
<li><p>21！就超过了<code>long long</code>的范围</p>
</li>
<li><p><code>cin</code>和<code>cout</code><strong>远比</strong><code>scanf</code>和<code>printf</code>花费时间多，能不用尽量不用</p>
</li>
<li><p>运行时限为1s，算法复杂度不能超过百万级，也即不能超过一千万<br>比如$O(n^2)$，n应&lt;=3000</p>
</li>
<li><p><code>cin</code>的多组输入：<code>while(cin &gt;&gt; x)</code>，<code>cin</code>在读入EOF时返回0</p>
</li>
<li><p>浮点数比较，在经过大量计算后应考虑误差</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span></span><br><span class="line">#define Equ(a, b) (<span class="built_in">fabs</span>((a)-(b))&lt;(eps))</span><br></pre></td></tr></table></figure>
<p>大于、小于、大于等于，以及sqrt、asin、cos等也需要考虑</p>
</li>
<li><p>C的空指针为<code>NULL</code>，c++11引入<code>nullptr</code></p>
</li>
<li><p><code>scanf(&quot;%c&quot;)</code>会可以读入空格，需要考虑</p>
</li>
<li><p>下标的计算（i、j的加加减减之类的）从实体加减考虑，不要考虑加减位置</p>
</li>
<li><p>C语言中整型最大值和最小值的宏</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, INT_MAX);	<span class="comment">//2147483647</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, INT_MIN);	<span class="comment">//-2147483648</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>命令行输入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[ ])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;argc; i++)</span><br><span class="line">    	<span class="built_in">printf</span>(“%s%c”, argv[i], (i&lt; argc<span class="number">-1</span>)? <span class="string">' '</span>: <span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Minghao Feng 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Minghao Feng 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/13/arp%E6%B8%97%E9%80%8F/" rel="prev" title="ettercap+driftnet抓取同一无线网段中设备阅览的图片">
      <i class="fa fa-chevron-left"></i> ettercap+driftnet抓取同一无线网段中设备阅览的图片
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-起步"><span class="nav-number">1.</span> <span class="nav-text">0 起步</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#include"><span class="nav-number"></span> <span class="nav-text">include </span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-算法初步"><span class="nav-number">1.</span> <span class="nav-text">1 算法初步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-排序"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-递归"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-贪心"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4二分"><span class="nav-number">1.4.</span> <span class="nav-text">1.4二分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-Two-Pointer"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 Two Pointer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-归并排序"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.5.1 归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2快排"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.5.2快排</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-其他高效技巧"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 其他高效技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-数学问题"><span class="nav-number">2.</span> <span class="nav-text">2 数学问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单数学"><span class="nav-number">2.1.</span> <span class="nav-text">简单数学</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最大公约数和最小公倍数"><span class="nav-number">2.2.</span> <span class="nav-text">最大公约数和最小公倍数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分数四则运算"><span class="nav-number">2.3.</span> <span class="nav-text">分数四则运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#素数"><span class="nav-number">2.4.</span> <span class="nav-text">素数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大整数运算"><span class="nav-number">2.5.</span> <span class="nav-text">大整数运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合数"><span class="nav-number">2.6.</span> <span class="nav-text">组合数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-标准模板库STL"><span class="nav-number">3.</span> <span class="nav-text">C++标准模板库STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">3.1.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string"><span class="nav-number">3.2.</span> <span class="nav-text">string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">3.3.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queue"><span class="nav-number">3.4.</span> <span class="nav-text">queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#priority-queue"><span class="nav-number">3.5.</span> <span class="nav-text">priority_queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stack"><span class="nav-number">3.6.</span> <span class="nav-text">stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pair"><span class="nav-number">3.7.</span> <span class="nav-text">pair</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#algorithm头文件下的常用函数"><span class="nav-number">4.</span> <span class="nav-text">algorithm头文件下的常用函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构专题"><span class="nav-number">5.</span> <span class="nav-text">数据结构专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#链表"><span class="nav-number">5.1.</span> <span class="nav-text">链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搜索专题"><span class="nav-number">6.</span> <span class="nav-text">搜索专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DFS"><span class="nav-number">6.1.</span> <span class="nav-text">DFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BFS"><span class="nav-number">6.2.</span> <span class="nav-text">BFS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-number">7.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树"><span class="nav-number">7.1.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一般的树"><span class="nav-number">7.2.</span> <span class="nav-text">一般的树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉查找树-BST"><span class="nav-number">7.3.</span> <span class="nav-text">二叉查找树 BST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#平衡二叉树-AVL树"><span class="nav-number">7.4.</span> <span class="nav-text">平衡二叉树 AVL树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#平衡因子"><span class="nav-number">7.4.1.</span> <span class="nav-text">平衡因子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#旋转"><span class="nav-number">7.4.2.</span> <span class="nav-text">旋转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入"><span class="nav-number">7.4.3.</span> <span class="nav-text">插入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈夫曼树"><span class="nav-number">8.</span> <span class="nav-text">哈夫曼树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并查集"><span class="nav-number">9.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆"><span class="nav-number">10.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#向下调整"><span class="nav-number">10.1.</span> <span class="nav-text">向下调整</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建堆"><span class="nav-number">10.2.</span> <span class="nav-text">建堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除堆顶"><span class="nav-number">10.3.</span> <span class="nav-text">删除堆顶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增添元素"><span class="nav-number">10.4.</span> <span class="nav-text">增添元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆排序"><span class="nav-number">10.5.</span> <span class="nav-text">堆排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图"><span class="nav-number">11.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图的存储"><span class="nav-number">11.1.</span> <span class="nav-text">图的存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的遍历"><span class="nav-number">11.2.</span> <span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DFS-1"><span class="nav-number">11.2.1.</span> <span class="nav-text">DFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BFS-1"><span class="nav-number">11.2.2.</span> <span class="nav-text">BFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最短路径"><span class="nav-number">11.3.</span> <span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dijkstra"><span class="nav-number">11.3.1.</span> <span class="nav-text">Dijkstra</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bellman-Ford与SPFA"><span class="nav-number">11.3.2.</span> <span class="nav-text">Bellman-Ford与SPFA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Floyd"><span class="nav-number">11.3.3.</span> <span class="nav-text">Floyd</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小生成树MST"><span class="nav-number">11.4.</span> <span class="nav-text">最小生成树MST</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Prim"><span class="nav-number">11.4.1.</span> <span class="nav-text">Prim</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruskal"><span class="nav-number">11.4.2.</span> <span class="nav-text">Kruskal</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拓扑排序"><span class="nav-number">11.5.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键路径"><span class="nav-number">11.6.</span> <span class="nav-text">关键路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划-DP"><span class="nav-number">12.</span> <span class="nav-text">动态规划 DP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最大连续子序列"><span class="nav-number">12.1.</span> <span class="nav-text">最大连续子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长不下降子序列-LIS"><span class="nav-number">12.2.</span> <span class="nav-text">最长不下降子序列 LIS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长公共子序列-LCS"><span class="nav-number">12.3.</span> <span class="nav-text">最长公共子序列 LCS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长回文串"><span class="nav-number">12.4.</span> <span class="nav-text">最长回文串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DAG最长路"><span class="nav-number">12.5.</span> <span class="nav-text">DAG最长路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#整个DAG中的最长路径"><span class="nav-number">12.5.1.</span> <span class="nav-text">整个DAG中的最长路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#固定终点的DAG最长路径"><span class="nav-number">12.5.2.</span> <span class="nav-text">固定终点的DAG最长路径</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#背包问题"><span class="nav-number">12.6.</span> <span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#01背包"><span class="nav-number">12.6.1.</span> <span class="nav-text">01背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#完全背包问题"><span class="nav-number">12.6.2.</span> <span class="nav-text">完全背包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">12.6.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP算法"><span class="nav-number">12.7.</span> <span class="nav-text">KMP算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">13.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中缀表达式计算"><span class="nav-number">13.1.</span> <span class="nav-text">中缀表达式计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C语言变长参数函数写法"><span class="nav-number">13.2.</span> <span class="nav-text">C语言变长参数函数写法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Debug思路"><span class="nav-number">14.</span> <span class="nav-text">Debug思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#杂"><span class="nav-number">15.</span> <span class="nav-text">杂</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Minghao Feng"
      src="/images/morty.png">
  <p class="site-author-name" itemprop="name">Minghao Feng</p>
  <div class="site-description" itemprop="description">Stay hungry, stay foolish.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kongkongNG" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kongkongNG" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1298974109@qq.com" title="E-Mail → 1298974109@qq.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;" rel="noopener" target="_blank">CNBlog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Minghao Feng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      script.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'QMXGn5ttLIUf6TGnmWMCm1cO-gzGzoHsz',
      appKey     : 'MeOG4BU6iYnp6YQ9YYMel2mi',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>

  
    <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  

</body>
</html>
