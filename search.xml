<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++trick_methods</title>
    <url>/2021/04/21/C++trick_methods/</url>
    <content><![CDATA[<p>title: C++ Trick Methods</p>
<p>tags: C++</p>
<p>categories: C++</p>
<h1 id="C-Trick-Methods"><a href="#C-Trick-Methods" class="headerlink" title="C++ Trick Methods"></a>C++ Trick Methods</h1><p>介绍c++中一些简化编码/提高效率/单纯有趣的函数</p>
<a id="more"></a>
<h2 id="iota"><a href="#iota" class="headerlink" title="iota()"></a>iota()</h2><p><a href="http://c.biancheng.net/view/681.html" target="_blank" rel="noopener">http://c.biancheng.net/view/681.html</a></p>
<p>定义在 <code>numeric</code> 头文件中的 <code>iota()</code> 函数模板会用连续的 T 类型值填充序列。前两个参数是定义序列的正向迭代器，第三个参数是初始的 T 值。 T 类型必须支持 operator++()</p>
<blockquote>
<p>相当于使用enum为容器进行初始化</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">data</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> initial &#123;<span class="number">-4</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::iota (<span class="built_in">std</span>::<span class="built_in">begin</span> (data) , <span class="built_in">std</span>::<span class="built_in">end</span> (data) , initial);</span><br><span class="line"><span class="comment">// -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0</span></span><br></pre></td></tr></table></figure>
<h2 id="使用ostream-iterator输出容器"><a href="#使用ostream-iterator输出容器" class="headerlink" title="使用ostream_iterator输出容器"></a>使用ostream_iterator输出容器</h2><p><a href="https://www.jianshu.com/p/c14f60ee3527" target="_blank" rel="noopener">https://www.jianshu.com/p/c14f60ee3527</a></p>
<p>头文件<code>#include &lt;iterator&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data = &#123; <span class="number">1</span>, <span class="number">21</span>, <span class="number">31</span>, <span class="number">41</span>, <span class="number">51</span>, <span class="number">61</span>, <span class="number">71</span>, <span class="number">81</span> &#125;;</span><br><span class="line">	<span class="comment">// 定义ostream_iterator，第一个参数是流文件，第二个是分隔符</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">dataIter</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">", "</span>)</span></span>;</span><br><span class="line">	<span class="comment">// 使用copy将迭代器复制到ostream</span></span><br><span class="line">    <span class="built_in">std</span>::copy(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), dataIter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>lambda表达式</title>
    <url>/2021/04/21/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>参考：<a href="http://c.biancheng.net/view/3741.html" target="_blank" rel="noopener">http://c.biancheng.net/view/3741.html</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>lambda 表达式是 <a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a>11 最重要也最常用的一个特性之一，<a href="http://c.biancheng.net/csharp/" target="_blank" rel="noopener">C#</a> 3.5 和 <a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">Java</a> 8 中就引入了 lambda 表达式。</p>
<p>lambda表达式有如下优点：</p>
<ul>
<li>声明式编程风格：就地<strong>匿名定义目标函数或函数对象</strong>，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，好的可读性和可维护性。</li>
<li>简洁：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也获取了更高的生产率。</li>
<li>在需要的时间和地点实现功能闭包，使程序更灵活。</li>
</ul>
<a id="more"></a>
<h2 id="lambda-表达式的概念和基本用法"><a href="#lambda-表达式的概念和基本用法" class="headerlink" title="lambda 表达式的概念和基本用法"></a>lambda 表达式的概念和基本用法</h2><p>lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。</p>
<ol>
<li><p>lambda表达式完全体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[ capture ] ( params ) opt -&gt; ret &#123; body; &#125;;	<span class="comment">// 注意外部有';'</span></span><br></pre></td></tr></table></figure>
<p>其中 <strong>capture</strong> 是捕获列表，<strong>params</strong> 是参数表，<strong>opt</strong> 是函数选项，<strong>ret</strong> 是返回值类型，<strong>body</strong>是函数体。</p>
</li>
<li><p>省略返回值或参数表的lambda表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a)&#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>在 C++11 中，lambda 表达式的返回值是通过前面介绍的《<a href="http://c.biancheng.net/view/3727.html" target="_blank" rel="noopener">C++返回值类型后置</a>》语法来定义的。其实很多时候，lambda 表达式的返回值是非常明显的，比如这个例子。因此，C++11 中允许省略 lambda 表达式的返回值定义：</p>
<p>这样编译器就会根据 return 语句自动推导出返回值类型。但是注意，定义二中，<strong>初始化列表不能用于返回值的自动推导</strong>。</p>
<p>lambda 表达式在没有参数列表时，参数列表是可以省略的。因此像下面的写法都是正确的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f1 = []()&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="comment">// 省略空参数表</span></span><br><span class="line"><span class="keyword">auto</span> f2 = []&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义了一个功能f，实现输入+1并返回</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出: 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x1 = [](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> i; &#125;;  <span class="comment">// OK: return type is int</span></span><br><span class="line"><span class="keyword">auto</span> x2 = []()&#123; <span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">2</span> &#125;; &#125;;  <span class="comment">// error: 无法推导出返回值类型</span></span><br></pre></td></tr></table></figure>
<h2 id="lambda-表达式捕获列表"><a href="#lambda-表达式捕获列表" class="headerlink" title="lambda 表达式捕获列表"></a>lambda 表达式捕获列表</h2><p>lambda 表达式还可以通过捕获列表捕获一定范围内的变量：</p>
<ul>
<li><code>[]</code> 不捕获任何变量。</li>
<li><code>[&amp;]</code>捕获<strong>外部作用域中所有变量</strong>，并作为<strong>引用</strong>在函数体中使用（按引用捕获）。</li>
<li><code>[=]</code> 捕获<strong>外部作用域中所有变量</strong>，并作为<strong>副本</strong>在函数体中使用（按值捕获）。</li>
<li><code>[=，&amp;foo]</code> 按值捕获外部作用域中所有变量，并按引用捕获 foo <strong>变量</strong>。</li>
<li><code>[bar]</code> <strong>按值捕获 bar 变量</strong>，同时不捕获其他变量。</li>
<li><code>[this]</code> 捕获<strong>当前类中的 this <a href="http://c.biancheng.net/c/80/" target="_blank" rel="noopener">指针</a></strong>，让 lambda 表达式<strong>拥有和当前类成员函数同样的访问权限</strong>。如果已经使用了 <strong>&amp; 或者 =，就默认添加此选项</strong>。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</li>
</ul>
<p>例1：类中捕获变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i_ = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = []&#123; <span class="keyword">return</span> i_; &#125;;                    <span class="comment">// error，没有捕获外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x2 = [=]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;           <span class="comment">// OK，捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x3 = [&amp;]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;           <span class="comment">// OK，捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_; &#125;;                <span class="comment">// OK，捕获this指针</span></span><br><span class="line">        <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;        <span class="comment">// error，没有捕获x、y</span></span><br><span class="line">        <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;  <span class="comment">// OK，捕获this指针、x、y</span></span><br><span class="line">        <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_++; &#125;;              <span class="comment">// OK，捕获this指针，并修改成员的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例2：引用捕获与按值捕获</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = []&#123; <span class="keyword">return</span> a; &#125;;               <span class="comment">// error，没有捕获外部变量</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;]&#123; <span class="keyword">return</span> a++; &#125;;            <span class="comment">// OK，捕获所有外部变量，并对a执行自加运算</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [=]&#123; <span class="keyword">return</span> a; &#125;;              <span class="comment">// OK，捕获所有外部变量，并返回a</span></span><br><span class="line"><span class="keyword">auto</span> f4 = [=]&#123; <span class="keyword">return</span> a++; &#125;;            <span class="comment">// error，a是以复制方式捕获的，无法修改</span></span><br><span class="line"><span class="keyword">auto</span> f5 = [a]&#123; <span class="keyword">return</span> a + b; &#125;;          <span class="comment">// error，没有捕获变量b</span></span><br><span class="line"><span class="keyword">auto</span> f6 = [a, &amp;b]&#123; <span class="keyword">return</span> a + (b++); &#125;;  <span class="comment">// OK，捕获a和b的引用，并对b做自加运算</span></span><br><span class="line"><span class="keyword">auto</span> f7 = [=, &amp;b]&#123; <span class="keyword">return</span> a + (b++); &#125;;  <span class="comment">// OK，捕获所有外部变量和b的引用，并对b做自加运算</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，默认状态下 lambda 表达式无法修改通过复制方式捕获的外部变量。如果希望修改这些变量的话，我们需要使用<strong>引用方式</strong>进行捕获。</p>
<p>例3：lambda表达式简化代码的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用for_each累计偶数个数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> even_count = <span class="number">0</span>;</span><br><span class="line">for_each( v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [&amp;even_count](<span class="keyword">int</span> val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(val &amp; <span class="number">1</span>))  <span class="comment">// val % 2 == 0</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++ even_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The number of even is "</span> &lt;&lt; even_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="lambda-表达式的延迟调用"><a href="#lambda-表达式的延迟调用" class="headerlink" title="lambda 表达式的延迟调用"></a>lambda 表达式的延迟调用</h2><p>如果希望 lambda 表达式在调用时能够即时访问外部变量，我们应当使用<strong>引用方式</strong>捕获。<strong>按值捕获得到的外部变量值是在 lambda 表达式定义时的值</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=]&#123; <span class="keyword">return</span> a; &#125;;      <span class="comment">// 按值捕获外部变量</span></span><br><span class="line">a += <span class="number">1</span>;                         <span class="comment">// a被修改了</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出？</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，lambda 表达式按值捕获了所有外部变量。<strong>在捕获的一瞬间，a 的值就已经被复制到f中了</strong>。之后 a 被修改，但此时 f 中存储的 a 仍然还是捕获时的值，因此，最终输出结果是 0。</p>
<p>那么如果希望去修改按值捕获的外部变量应当怎么办呢？这时，需要显式指明 lambda 表达式为 <strong>mutable</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=]&#123; <span class="keyword">return</span> a++; &#125;;             <span class="comment">// error，修改按值捕获的外部变量</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [=]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> a++; &#125;;  <span class="comment">// OK，mutable</span></span><br></pre></td></tr></table></figure>
<p>需要注意的一点是，被 mutable 修饰的 lambda 表达式就算没有参数也要写明参数列表。</p>
<h2 id="lambda-表达式的类型"><a href="#lambda-表达式的类型" class="headerlink" title="lambda 表达式的类型"></a>lambda 表达式的类型</h2><p>lambda 表达式的类型在 C++11 中被称为“闭包类型（Closure Type）”。它是一个特殊的，匿名的非 nunion 的类类型。</p>
<p>因此，我们可以认为它是一个<strong>带有 operator() 的类</strong>，即仿函数</p>
<blockquote>
<p>operator()：重载的函数操作符。类重载这一操作符后，可以将对象当作函数使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test t;</span><br><span class="line">    t(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>lambda 表达式可以说是就地定义仿函数闭包的“语法糖”。它的<strong>捕获列表捕获住的任何外部变量，最终均会变为闭包类型的成员变量</strong>。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《算法笔记》总结</title>
    <url>/2021/04/21/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<a id="more"></a>
<p>[TOC]</p>
<h2 id="0-起步"><a href="#0-起步" class="headerlink" title="0 起步"></a>0 起步</h2><p>基本数据类型：变量，强制转换，符号常量（define），const</p>
<p>顺序结构：赋值，scanf/printf，getchar/putchar，typedef，<strong>math</strong>函数</p>
<ul>
<li><p>区分double型的scanf和printf<br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309090058765.png" alt="image-20210309090058765"></p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309090139568.png" alt="image-20210309090139568"></p>
</li>
<li><p>常用math函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 规范</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fabs</span><span class="params">(<span class="keyword">double</span> x)</span></span>;	<span class="comment">// 取绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> x)</span></span>;	<span class="comment">// 四舍五入，返回的double需用(int)取整</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> x)</span></span>;	<span class="comment">// 向下取整</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>;	<span class="comment">// 向上取整</span></span><br><span class="line"><span class="comment">// 以上两个函数对负数也有效，如floor(-5.2) = -6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> r, <span class="keyword">double</span> p)</span></span>;	<span class="comment">// 返回r^p</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;	<span class="comment">// 返回x的算术平方根</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> x)</span></span>;	<span class="comment">// 返回以e为底的对数</span></span><br><span class="line"><span class="comment">// 换底公式处理任何底的对数: log_a(b) = log(b) / log(a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三角函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sin</span><span class="params">(<span class="keyword">double</span> x)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> x)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">tan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;	</span><br><span class="line"><span class="comment">// 参数要求弧度制 如1/3 * pi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反三角函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">asin</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">acos</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>选择结构：if，switch</p>
<p>循环结构：while，do while，for，break/continue</p>
<p>数组：memset，字符数组，string.h头文件，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="built_in">memset</span>(数组名, 值, <span class="keyword">sizeof</span>(数组名));	<span class="comment">// 值只能0或-1，因为是按字节赋值</span></span><br></pre></td></tr></table></figure>
<p><strong>sscanf/sprintf</strong>（字符串格式转换）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将数据输入到字符串</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">6</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%d"</span>, n);</span><br><span class="line"><span class="comment">// 执行后str为"12345"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串中提取输入</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">6</span>] = <span class="string">"12345"</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="comment">// 执行后n = 12345</span></span><br></pre></td></tr></table></figure>
<p>函数：嵌套、递归</p>
<p>指针：指针与数组、<strong>引用<code>&amp;</code></strong></p>
<ul>
<li>引用不产生副本，而是给原变量起别名</li>
<li>指针引用（如<code>int* &amp;r</code>），在需要改指针存储的<code>unsigned int</code>型地址本身时使用</li>
</ul>
<p>结构体：访问元素<code>.</code>/<code>-&gt;</code>，构造函数</p>
<p>输入字符串汇总：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);		<span class="comment">// scanf读入一个char[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((str[i]=getchar())!=<span class="string">'\n'</span>)		<span class="comment">// getchar读入一行char[]</span></span><br><span class="line">    i++;</span><br><span class="line"></span><br><span class="line">gets(str);	<span class="comment">// gets读入一行char[]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.getline(str, MAXN);	<span class="comment">// cin读入一行char[], 读取直到遇到\n为止</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2;</span><br><span class="line">getline(<span class="built_in">cin</span>, str2);	<span class="comment">// cin读入一行string</span></span><br></pre></td></tr></table></figure>
<p>文件输入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 打开文件，如果没有则新建</span></span><br><span class="line"><span class="keyword">char</span> fileName[<span class="number">10</span>] = <span class="string">"tmp.txt"</span>;</span><br><span class="line"><span class="keyword">char</span> mode[<span class="number">3</span>] = <span class="string">"r+"</span>;	<span class="comment">// r只读，w只写，r+可读可写</span></span><br><span class="line">FILE *fp = fopen(filename, mode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件关闭</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">( FILE *fp )</span></span>;	<span class="comment">// 错误返回EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件读</span></span><br><span class="line"><span class="comment">// fgetc</span></span><br><span class="line"><span class="keyword">while</span> ((c = fgetc(fp)) != EOF)		<span class="comment">// 返回读取的字符</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//fgets</span></span><br><span class="line"><span class="keyword">char</span> buff[maxn];</span><br><span class="line"><span class="keyword">while</span> (fgets(buf, maxn, fp))	 <span class="comment">// 读一行存进buf，也可以用char*接收返回值</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// fscanf</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;n) != EOF)	<span class="comment">// 注意结合sscanf理解“流”</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件写</span></span><br><span class="line">fputc( <span class="keyword">int</span> c, fp);</span><br><span class="line"><span class="built_in">fputs</span>(str, fp);		<span class="comment">// 末尾无\n，puts有</span></span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">"%s"</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他</span></span><br><span class="line">rewind(fp);		<span class="comment">// 文件指向开头</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> <span class="keyword">int</span> offset, <span class="keyword">int</span> whence)</span></span>;	<span class="comment">// 文件指针移动</span></span><br><span class="line"><span class="comment">// whence可以是：SEEK_SET开头，SEEK_CUR当前，SEEK_END末尾</span></span><br></pre></td></tr></table></figure>
<p>C语言字符判断函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isalpha</span>(c);	<span class="comment">// 是否为字母</span></span><br><span class="line"><span class="built_in">isdigit</span>(c);	<span class="comment">// 是否为数字</span></span><br><span class="line"><span class="built_in">isalnum</span>(c);	<span class="comment">// 是否为英文或数字</span></span><br><span class="line"><span class="built_in">isupper</span>(c);	<span class="comment">// 是否为大写</span></span><br><span class="line"><span class="built_in">islower</span>(c);	<span class="comment">// 是否为小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否为分割文本的空白符（空格' '和水平制表符'\t'）</span></span><br><span class="line">isblank(c);	</span><br><span class="line"><span class="comment">// 是否为空白符（' '、水平制表符'\t'、换行符'\n'、垂直制表符'\v'、换页'\f'以及回车'\r'。）</span></span><br><span class="line"><span class="built_in">isspace</span>(c);</span><br></pre></td></tr></table></figure>
<h2 id="1-算法初步"><a href="#1-算法初步" class="headerlink" title="1 算法初步"></a>1 算法初步</h2><h3 id="1-1-排序"><a href="#1-1-排序" class="headerlink" title="1.1 排序"></a>1.1 排序</h3><p>c++ <code>sort</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">sort([首元素地址], [尾元素的下一个地址], [比较函数cmp(非必填)]);	<span class="comment">// 默认升序</span></span><br><span class="line"><span class="comment">// 简单cmp函数</span></span><br><span class="line"><span class="comment">// bool cmp(e1, e2)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 		return e1 &lt; e2; // 小元素在前、升序</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用lambda表达式写cmp</span></span><br><span class="line"><span class="comment">// 对索引数组indices排序</span></span><br><span class="line">sort(indices.<span class="built_in">begin</span>(), indices.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;</span><br><span class="line">    <span class="keyword">return</span> tasks[i][<span class="number">0</span>] &lt; tasks[j][<span class="number">0</span>];   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>c <code>qsort</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmpfunc</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * a, <span class="keyword">const</span> <span class="keyword">void</span> * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> ( *([类型]*)a - *([类型]*)b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">qsort([数组], n, <span class="keyword">sizeof</span>([类型]), cmp);</span><br></pre></td></tr></table></figure>
<p>写cmp函数的原则：</p>
<ul>
<li><strong>希望元素按什么顺序排列，就直接按照大小次序返回即可；</strong></li>
</ul>
<h3 id="1-2-递归"><a href="#1-2-递归" class="headerlink" title="1.2 递归"></a>1.2 递归</h3><p>典例：全排列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dfs(0)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 递归边界</span></span><br><span class="line">    <span class="keyword">if</span> (index == n - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>, a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 递归式</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!flag[i])</span><br><span class="line">		&#123;</span><br><span class="line">			a[index] = i;	<span class="comment">// 常用技巧: 用层数做数组下标记录结果</span></span><br><span class="line">			vis[i] = <span class="literal">true</span>;</span><br><span class="line">			dfs(index + <span class="number">1</span>);</span><br><span class="line">			vis[i] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>n皇后问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心思想：排列 + 判断方案是否合法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (index == n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 方案数</span></span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="comment">// 打印方案</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">			(i == n - <span class="number">1</span>)? <span class="built_in">putchar</span>(<span class="string">'\n'</span>) : <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="comment">// 枚举待选择的位置：index下标放入i </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> pre = <span class="number">0</span>; pre &lt; index; pre++)	<span class="comment">// 枚举已有的位置 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 如果在对角线上</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(index - pre) == <span class="built_in">abs</span>(i - ans[pre]))</span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 若这种方案目前合法 </span></span><br><span class="line">			<span class="keyword">if</span> (flag)	</span><br><span class="line">			&#123;</span><br><span class="line">				vis[i] = <span class="literal">true</span>;</span><br><span class="line">				ans[index] = i;</span><br><span class="line">				dfs(index + <span class="number">1</span>);</span><br><span class="line">				vis[i] = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-贪心"><a href="#1-3-贪心" class="headerlink" title="1.3 贪心"></a>1.3 贪心</h3><p>局部最优推得全局最优</p>
<ul>
<li>简单贪心：分布背包</li>
<li>区间贪心<ul>
<li>活动选择、区间选点问题</li>
</ul>
</li>
</ul>
<h3 id="1-4二分"><a href="#1-4二分" class="headerlink" title="1.4二分"></a>1.4二分</h3><ul>
<li><p>查找序列<strong>是否存在</strong>满足条件的元素（常规二分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 严格递增序列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == x)	<span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &gt; x) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>	left = mid + <span class="number">1</span>;		<span class="comment">// A[mid] &lt; x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">// 查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>查找序列<strong>第一个满足</strong>条件的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列从左到右先不满足，后满足</span></span><br><span class="line"><span class="comment">// 若存在，返回的是元素的位置</span></span><br><span class="line"><span class="comment">// 若不存在，返回的是“假设存在，它应在的位置”</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)	<span class="comment">// 此时才有区间</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (条件成立)	<span class="comment">// 满足条件，则第一个满足的在[left, mid]之间</span></span><br><span class="line">            right = mid		<span class="comment">// 因为mid也满足，所以不是mid-1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;	<span class="comment">// left==right时退出循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于左开右闭的区间<code>(left, right]</code>，二分条件就是<code>while ((left + 1 &lt; right)</code></p>
<p>对于左闭右开<code>[left, right)</code>，二分条件是<code>while (left &lt; right - 1)</code></p>
</li>
<li><p>二分拓展</p>
<ul>
<li><p>计算单调函数<code>f(x)=0</code>的根（近似）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// f(x)递增</span></span><br><span class="line"><span class="keyword">double</span> f(<span class="keyword">double</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ...; <span class="comment">// 函数值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> left, <span class="keyword">double</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (right - left &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(mid) &gt; <span class="number">0</span>) 	<span class="comment">// 若递减，把&gt;改为&lt;</span></span><br><span class="line">            right = mid;	<span class="comment">// 往[left, mid]逼近</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            left = mid;		<span class="comment">// 往[mid, right]逼近</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>快速幂（求$a^b\%m$，O(logb)）</p>
<p>递归写法</p>
<ol>
<li>如果b是奇数（$b \&amp; 1$），$a^b = a * a^{b - 1}$</li>
<li>如果b是偶数，$a^b = a^{b/2} * a^{b / 2}$</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(logb)</span></span><br><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a, LL b, LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)	<span class="comment">// 奇数</span></span><br><span class="line">        <span class="keyword">return</span> a * binaryPow(a, b - <span class="number">1</span>, m) % m;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LL mul = binaryPow(a, b / <span class="number">2</span>, m);</span><br><span class="line">        <span class="keyword">return</span> mul * mul % m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代写法：</p>
<p>b可以写成若干二次幂的和，如$2^{13} = 2^{(1101)_2} = 2^8 <em> 2^4 </em> 2^1$</p>
<p>当二次幂$i$号位被选中（中间的式子），那么$a^{2i}$就被选中（右边的式子）</p>
<ol>
<li>判断b的二进制末尾是否为1，是则令ans*a</li>
<li>a自乘，相当于进入下一位的判断和计算</li>
<li>b右移一位，和2的作用类似</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a, LL b, LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)	<span class="comment">// b的二进制末尾为1</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans * a % m;	<span class="comment">// 用b的二进制计算幂</span></span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % m;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;		<span class="comment">// b右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>​                注：任何正整数对1取模一定为0</p>
<h3 id="1-5-Two-Pointer"><a href="#1-5-Two-Pointer" class="headerlink" title="1.5 Two Pointer"></a>1.5 Two Pointer</h3><p>Two Pointer即双指针，用两个指针（或下标）一同访问一个序列，加快速度</p>
<h4 id="1-5-1-归并排序"><a href="#1-5-1-归并排序" class="headerlink" title="1.5.1 归并排序"></a>1.5.1 归并排序</h4><p>two pointer思想：merge中，两个数组两个指针</p>
<p>2-路归并排序的核心是将两个有序的数组合并为一个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span> L2, <span class="keyword">int</span> R2)</span>		<span class="comment">// [L1,R1]是左半边，L2=R1+1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = L1, j = L2;</span><br><span class="line">    <span class="keyword">int</span> temp[MAXN], index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= R1 &amp;&amp; j &lt;= R2)		<span class="comment">// 合并</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt;= A[j])</span><br><span class="line">            temp[index++] = A[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[index++] = A[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= R1)</span><br><span class="line">        temp[index++] = A[i++];		<span class="comment">// 加入剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= R2)</span><br><span class="line">        temp[index++] = A[j++];		<span class="comment">// 加入剩余元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        A[L1 + i] = temp[i];		<span class="comment">// 合并后的序列赋值回A</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序O(nlogn)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(A, left, mid);		<span class="comment">// 排左子区间</span></span><br><span class="line">        mergeSort(A, mid + <span class="number">1</span>, right);	<span class="comment">// 排右子区间</span></span><br><span class="line">        merge(A, left, mid, mid + <span class="number">1</span>, right);	<span class="comment">// 合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-2快排"><a href="#1-5-2快排" class="headerlink" title="1.5.2快排"></a>1.5.2快排</h4><p>two pointer思想：partition中，一个数组、首尾双指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randPartition</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 随机轴 </span></span><br><span class="line">    <span class="comment">// rand()生成一个[0, RAND_MAX]的数</span></span><br><span class="line">    <span class="comment">// [0, RAND_MAX]-&gt;[0, 1]-&gt;[0, right-left]-&gt;[left, right]</span></span><br><span class="line">	<span class="keyword">int</span> p = (<span class="keyword">int</span>)round(<span class="number">1.0</span> * rand() / RAND_MAX * (right - left) + left);</span><br><span class="line">	swap(A[left], A[p]);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 切分，左边比轴小，右边比轴大</span></span><br><span class="line">	<span class="keyword">int</span> temp = A[left];</span><br><span class="line">	<span class="keyword">while</span>(left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; A[right] &gt; temp) right--;	<span class="comment">// 右往左找比轴小的</span></span><br><span class="line">		A[left] = A[right];	</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; A[left] &lt;= temp) left++;		<span class="comment">// 左往右找比轴大的</span></span><br><span class="line">		A[right] = A[left];	</span><br><span class="line">	&#125;</span><br><span class="line">	A[left] = temp;		<span class="comment">// left = right</span></span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line">	<span class="keyword">if</span> (L &lt; R)</span><br><span class="line">	&#123;</span><br><span class="line">		pivot = randPartition(L, R);	<span class="comment">// 切分</span></span><br><span class="line">		quickSort(L, pivot - <span class="number">1</span>);	<span class="comment">// 排左区间</span></span><br><span class="line">		quickSort(pivot + <span class="number">1</span>, R);	<span class="comment">// 排右区间</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));	<span class="comment">// 随机种子 </span></span><br><span class="line">    <span class="comment">// time返回自1970-01-01来经过的秒数，参数为接受该值的指针（和返回值一致）</span></span><br><span class="line">    <span class="comment">// 不需要存下该值，所以为NULL</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-其他高效技巧"><a href="#1-6-其他高效技巧" class="headerlink" title="1.6 其他高效技巧"></a>1.6 其他高效技巧</h3><ul>
<li><p>打表</p>
</li>
<li><p>递推（有时思考一下递推式比简单暴力高效很多）<br>“有几个PAT”：计算一个给定字符串包含多少个PAT</p>
<p>暴力计算会超时，但利用组合的思想，计算A左边的P数，乘以A右边的T数，就能得到一个A形成的PAT个数</p>
<p>例如 APPAPT，中间的A左边2个P，右边1个T，总共能形成2*1=2个PAT，将所有A的结果相加得到最终结果</p>
</li>
<li><p><strong>随机选择算法</strong>（求第K大的数）<br>此处有文字游戏：如1 2 3 4 5 6，有两种理解：1）第一大 1，第二大 2；2）第一大 6，第二大 5</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 期望时间O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">randSelect</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = randPartition(left, right);	<span class="comment">// 使用快排的randPartition</span></span><br><span class="line">	<span class="keyword">int</span> M = p - left + <span class="number">1</span>;	<span class="comment">// 位置p在[left,right]中排在第M位</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (K == M) </span><br><span class="line">        <span class="keyword">return</span> A[p];	<span class="comment">// 找到第K大元素</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (K &lt; M) </span><br><span class="line">        <span class="keyword">return</span> randSelect(A, left, p - <span class="number">1</span>, K);	<span class="comment">// 在左子区间</span></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> randSelect(A, p + <span class="number">1</span>, right, K - M);	<span class="comment">// 在右子区间的第K-M位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-数学问题"><a href="#2-数学问题" class="headerlink" title="2 数学问题"></a>2 数学问题</h2><h3 id="简单数学"><a href="#简单数学" class="headerlink" title="简单数学"></a>简单数学</h3><ul>
<li>数字黑洞</li>
</ul>
<h3 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最小公倍数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">    <span class="comment">// 可能溢出，也可写为 return a / gcd(a, b) * b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分数四则运算"><a href="#分数四则运算" class="headerlink" title="分数四则运算"></a>分数四则运算</h3><h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><p>素数：不能被其他数整除的数（<code>n%i!=0</code>）</p>
<p>求素数表</p>
<ul>
<li><p>遍历1-sqrt(n)，复杂度为O(n * sqrt(n))</p>
</li>
<li><p>质数筛</p>
<ul>
<li><p>埃氏(O(nloglogn))：对每个质数，筛去其倍数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">// i既可能是待存质数，同时也作为筛 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) </span><br><span class="line">		&#123;</span><br><span class="line">			p[++p[<span class="number">0</span>]] = i;	<span class="comment">// p[0]为cnt</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= MAXN; j += i)</span><br><span class="line">				vis[j] = <span class="literal">true</span>;</span><br><span class="line">		&#125;	 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>欧拉筛(O(n))：在埃氏筛的基础上，每个合数只被其最小质因子筛去，避免重复</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 存质数 </span></span><br><span class="line">		<span class="keyword">if</span> (!vis[i])</span><br><span class="line">			p[++p[<span class="number">0</span>]] = i;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 筛：筛去i * p[j]</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p[<span class="number">0</span>] &amp;&amp; i * p[j] &lt;= MAXN; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i * p[j]] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>)	<span class="comment">// 以后会由质因子筛到，避免重复 </span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键语句<code>if ((i % p[j]) == 0) break;</code>的理解：</p>
<ol>
<li>当$i \% p[j]$时，令$i = k <em> p[j]$，继续往下执行，即筛$i </em> p[j+1]$，而此时有$i <em> p[j+1] = p[j] </em> k <em> p[j+1]$，即$i </em> p[j+1]$会在$i’=k <em> p[j+1]$时由$p[j]$筛掉，此时属于重复操作，违背由<em>*最小质因子</em></em>筛去的法则。对于$p[j+2], … p[j+m]$类同，因而中断循环</li>
</ol>
<p>注意！！！<code>i % p[j]</code><strong><code>== 0</code></strong>才表示<code>p[j]</code>整除<code>i</code>！！！</p>
</li>
</ul>
</li>
</ul>
<h3 id="大整数运算"><a href="#大整数运算" class="headerlink" title="大整数运算"></a>大整数运算</h3><p>由于大整数运算从低位开始，而字符串读入从高位，因此在转换时要记得<strong>反置</strong></p>
<ul>
<li><p>大整数结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigN</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num[MAXN];</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 初始化函数</span></span><br><span class="line">	BigN()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">		len = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BigN <span class="title">add</span><span class="params">(BigN a, BigN b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BigN c;</span><br><span class="line">	<span class="keyword">int</span> carry = <span class="number">0</span>;	<span class="comment">// 进位</span></span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len || i &lt; b.len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		res = a.num[i] + b.num[i] + carry;</span><br><span class="line">		c.num[c.len++] = res % <span class="number">10</span>;</span><br><span class="line">		carry = res / <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 末尾进位</span></span><br><span class="line">	<span class="keyword">if</span> (carry != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		c.num[c.len++] = carry;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>减法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设a &gt; b，如果a &lt; b需交换a、b并在前面加-号</span></span><br><span class="line"><span class="function">BigN <span class="title">sub</span><span class="params">(BigN a, BigN b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BigN c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len || i &lt; b.len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a.num[i] &lt; b.num[i])</span><br><span class="line">		&#123;</span><br><span class="line">			a.num[i] += <span class="number">10</span>;</span><br><span class="line">			a.num[i+<span class="number">1</span>] -= <span class="number">1</span>;	<span class="comment">// 由于a &gt; b，if不会在i=len时成立，所以不会越界 </span></span><br><span class="line">		&#125;</span><br><span class="line">		c.num[c.len++] = a.num[i] - b.num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (c.len &gt; <span class="number">1</span> &amp;&amp; c.num[c.len<span class="number">-1</span>] == <span class="number">0</span>) 	<span class="comment">// 去除高位0但保留至少1位数</span></span><br><span class="line">        c.len--;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>高精度与低精度的乘法</p>
<ol>
<li>从低位遍历大整数，每位与低精度相乘，并加上已有进位</li>
<li>取个位数为结果，多位</li>
<li>循环直至遍历所有位，记得考虑最后的进位</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BigN <span class="title">mult</span><span class="params">(BigN a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BigN c;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a.num[i] * b + carry; <span class="comment">// 每位与低精度相乘，并加上已有进位</span></span><br><span class="line">        c.num[c.len++] = temp % <span class="number">10</span>;	<span class="comment">// 取个位数为结果</span></span><br><span class="line">        carry = temp / <span class="number">10</span>;	<span class="comment">// 高位为进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (carry != <span class="number">0</span>)	<span class="comment">// 最后的多位进位</span></span><br><span class="line">    &#123;</span><br><span class="line">        c.num[c.len++] = carry % <span class="number">10</span>;</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>高精度与低精度除法<br>注意：唯一从字符串反置后的高位开始遍历的计算（加减乘都是从低位），实际就是直接按输入的序</p>
<ol>
<li>商的位数和被除数（左边）的位数一一对应</li>
<li>遍历被除数的每一位，余数（初始化为0）和每次选取的位组成新的临时被除数</li>
<li>若除不了（小于除数），结果为0，进入下一位；若能除，记录商，更新余数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BigN <span class="title">divide</span><span class="params">(BigN a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BigN c;</span><br><span class="line">    c.len = a.len;	<span class="comment">// 商和被除数每一位一一对应</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)	<span class="comment">// 从高位开始遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp * <span class="number">10</span> + a.num[i];	<span class="comment">// 本次选择的位与上一位遗留的余数组合</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; b)	c.num[i] = <span class="number">0</span>;	<span class="comment">// 不够除，该位为0</span></span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">// 够除</span></span><br><span class="line">        &#123;</span><br><span class="line">            c.num[i] = temp / b;	<span class="comment">// 商</span></span><br><span class="line">            temp = temp % b;	<span class="comment">// 该位遗留的余数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r = temp;	<span class="comment">// 最终余数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (c.len &gt; <span class="number">1</span> &amp;&amp; c.num[c.len - <span class="number">1</span>] == <span class="number">0</span>) c.len--;	<span class="comment">// 去除高位0但至少保留1位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h3><ul>
<li><p>求<code>n!</code>中有多少个质因子<code>p</code>O(logn)<br>结论：<code>n!</code>中有$\frac{n}{p}+\frac{n}{p^2}+\frac{n}{p^3}+…$个质因子<code>p</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可用于计算<code>n!</code>末尾有多少个0：计算质因子5的个数</p>
</li>
<li><p>求组合数$C_{n}^{m}$</p>
<ol>
<li><p><del>定义计算（阶乘）</del>（long long也只能承受n&lt;20的数据）</p>
</li>
<li><p>递推公式：$C_n^m = C_{n-1}^m + C_{n-1}^{m-1}$，$C_n^0 = C_n^n = 1$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || n == m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> C(n<span class="number">-1</span>, m) + C(n<span class="number">-1</span>, m<span class="number">-1</span>);	<span class="comment">// 可以储存计算结果防止重复计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用定义，边除边乘，$C_{n+m-i}^{i}=\frac{(n-m+1)<em>(n-m+2)</em>…<em>(n-m+i)}{1</em>2<em>…</em>i}$一定是整数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans * (n - m + i) / i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="C-标准模板库STL"><a href="#C-标准模板库STL" class="headerlink" title="C++标准模板库STL"></a>C++标准模板库STL</h2><ul>
<li><p>注1：<br>无特殊说明，一般</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;[STL名字]&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<p>即可使用</p>
</li>
<li><p>注2：<br>STL嵌套，如果出现<code>&gt;&gt;</code>，记得在中间加空格：<code>&gt; &gt;</code>，否则c++11会将其识别为移位</p>
</li>
<li><p>注3：<br>STL的<code>find()</code>一般用<code>if (stl.find(x) != stl.end())</code>进行判断，<code>string</code>特殊，可以用<code>string::npos</code></p>
</li>
<li><p>```c++<br>count(stl.begin(), stl.end(), value);    // 计算value在stl中的个数</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 注<span class="number">4</span>：C++<span class="number">11</span>新特性！</span><br><span class="line"></span><br><span class="line">  - 引入**emlace_front、empace 和 emplace_back**进行构造插入</span><br><span class="line"></span><br><span class="line">    ```c++</span><br><span class="line">    <span class="comment">//push_back()创建一个临时对象，然后将临时对象拷贝到容器中</span></span><br><span class="line">    d.push_back(Date(“<span class="number">2016</span>”,”<span class="number">05</span>”,”<span class="number">26</span>”));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接进行构造插入，省去构造临时对象的开销</span></span><br><span class="line">    <span class="comment">// 前提是元素需要有相应的构造函数</span></span><br><span class="line">    d.emplace_back(“<span class="number">2016</span>”,”<span class="number">05</span>”,”<span class="number">26</span>”);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; name;	<span class="comment">// 一维变长</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt;&gt; name;	<span class="comment">// 二维变长</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; arrName[arrSize];	<span class="comment">// 第一维定长，第二维变长</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>元素访问</p>
<ul>
<li>使用下标：<code>v[i]</code></li>
<li>迭代器：<ul>
<li><code>vector&lt;typename&gt;::iterator it</code>：类似指针，用<code>*it</code>访问元素</li>
<li><code>vi.begin()</code>, <code>vi.end()</code>：左闭右开。（只有vector和string可以使用<code>vi.begin()+i</code>的写法</li>
</ul>
</li>
</ul>
</li>
<li><p>常用函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vi.push_back(x);	<span class="comment">// O(1)</span></span><br><span class="line">vi.pop_back();	<span class="comment">// O(1), 删除尾元素</span></span><br><span class="line">vi.<span class="built_in">size</span>();	<span class="comment">// O(1), 返回unsigned类型</span></span><br><span class="line">vi.<span class="built_in">clear</span>(); <span class="comment">// O(n), 清除vector中所有元素</span></span><br><span class="line">vi.insert(it, x);	<span class="comment">// O(n), 向it处插入一个元素</span></span><br><span class="line">vi.erase(it);	<span class="comment">// O(n), 删除it处的元素</span></span><br><span class="line">vi.erase(first, last)	<span class="comment">// O(n), 删除[first, last)内的所有元素, first, last为迭代器</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>内部自动有序且不含重复元素的<strong>集合</strong></p>
<ul>
<li><p>定义：和vector类似</p>
</li>
<li><p>元素访问<br>只能通过迭代器：<code>set&lt;typename&gt;::iterator it</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只能按以下方式枚举，不支持*(it+i)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st.insert(x);	<span class="comment">// O(logn), 自动递增排序和去重</span></span><br><span class="line">st.<span class="built_in">find</span>(value);	<span class="comment">// O(logn), 返回值为value的迭代器it</span></span><br><span class="line">st.count(value);	<span class="comment">// 如果value在集合中，返回1，否则返回0</span></span><br><span class="line">st.erase(it);	<span class="comment">// O(1), 删除元素</span></span><br><span class="line">st.erase(value);	<span class="comment">// O(logn), 删除元素</span></span><br><span class="line">st.erase(first, last);	<span class="comment">/// O(n)</span></span><br><span class="line">st.<span class="built_in">size</span>();	<span class="comment">// O(1)</span></span><br><span class="line">st.<span class="built_in">clear</span>();	<span class="comment">// O(n)</span></span><br></pre></td></tr></table></figure></li>
<li>拓展：<code>multiset</code>, <code>unordered_set</code></li>
</ul>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用字符串常量初始化</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"abcd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字符数组初始化</span></span><br><span class="line"><span class="keyword">char</span> c[MAXN];</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(c)</span></span>;</span><br><span class="line"><span class="built_in">string</span> str1 = c;</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素访问</p>
<ul>
<li><p>直接像字符数组一样访问</p>
</li>
<li><p>直接输入输出，只能用<code>cin</code>和<code>cout</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用printf输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str.c_str());</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span>::iterator it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>常用函数</p>
<ul>
<li><p>operator+=（字符串拼接）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str3 = str1 + str2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>compare operator，按字典序比较</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str1 &gt;= str2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">str.length(); str.<span class="built_in">size</span>();	<span class="comment">// O(1), 二者基本相同</span></span><br><span class="line">str.insert(pos, str2);	<span class="comment">// O(N), 在pos下标处插入str2</span></span><br><span class="line">str.insert(it, first, last);	<span class="comment">//	O(N), 在原字符串it处插入串[first, last)</span></span><br><span class="line">str.erase(it);	<span class="comment">// O(N), 删除it指向的元素</span></span><br><span class="line">str.erase(first, last);</span><br><span class="line">str.erase(pos, length);	<span class="comment">// 从pos处删除length个字符(含本身)</span></span><br><span class="line">str.<span class="built_in">clear</span>();	<span class="comment">// O(1), 清空</span></span><br><span class="line">str.substr(pos, len);	<span class="comment">// O(len), 返回从pos开始、长度为len的子串</span></span><br><span class="line">str.<span class="built_in">find</span>(str2); <span class="comment">// O(nm), 如果str2是字串, 返回其在str第一次出现的位置, 否则返回string::npos(unsigned_int型, 值为-1)</span></span><br><span class="line">str.<span class="built_in">find</span>(str2, pos);	<span class="comment">// 从pos处开始匹配str2</span></span><br><span class="line"><span class="comment">// 常用写法：if (str.find(str2) != string::npos) 如果能找到, 则...</span></span><br><span class="line">str.replace(pos, len, str2); <span class="comment">// O(n), 把str从pos处开始、长度为len的子串替换为str2</span></span><br><span class="line">str.replace(first, last, str2);	<span class="comment">// 把str的[first, last)子串替换为str2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map内的键会按从小到大顺序自动排序（因为是基于红黑树实现），键唯一</p>
<p>注：</p>
<p>​    map无法按value排序，只能将<code>pair</code>放进<code>vector</code>里，对<code>vector</code>排序</p>
<ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;type1, type2&gt; mp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问</p>
<ul>
<li><p>直接使用下标（新值会覆盖旧值）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mp[<span class="string">'c'</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过迭代器访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;type1, type2&gt;::iterator it;</span><br><span class="line">it-&gt;first;	<span class="comment">// 访问键</span></span><br><span class="line">it-&gt;second;	<span class="comment">// 访问值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>常用函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">it = mp.<span class="built_in">find</span>(key);	<span class="comment">// O(logN), 返回键为key的迭代器it</span></span><br><span class="line">mp.insert(make_pair(value1, value2));</span><br><span class="line">mp.erase(it);	<span class="comment">// O(1), 删除元素</span></span><br><span class="line">mp.erase(key);	<span class="comment">// O(logN), 根据键删除</span></span><br><span class="line">mp.erase(first, last);	<span class="comment">// 删除一个区间的元素</span></span><br><span class="line">mp.<span class="built_in">size</span>();	<span class="comment">// O(1)</span></span><br><span class="line">mp.<span class="built_in">clear</span>(); <span class="comment">// O(N)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>拓展</p>
<ul>
<li><code>multimap</code>：一个键对多个值</li>
<li><code>unordered_map</code>：只映射不排序，比纯<code>map</code>快很多</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>hashmap可当作bool数组使用</li>
<li>map会自动初始化</li>
</ul>
</li>
</ul>
<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>先进先出</p>
<ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;type&gt; q;</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素访问<br>只能用<code>q.front()</code>或<code>q.back()</code>访问队首或队尾元素<br>（ps：访问前先使用<code>empty()</code>判断队是否空）</p>
</li>
<li><p>常用函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">q.push();	<span class="comment">// O(1)</span></span><br><span class="line">q.front(); q.back();	<span class="comment">// O(1)</span></span><br><span class="line">q.pop();	<span class="comment">// O(1) 队首出队</span></span><br><span class="line">q.empty();	<span class="comment">// O(1) 队列是否空</span></span><br><span class="line">q.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>拓展</p>
<ul>
<li>双端队列<code>deque</code>：首尾皆可插入和删除</li>
<li>优先队列<code>priority_queue</code>：堆实现，最大元素置于队首</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>通常通过重新定义一个队列来完成清空<code>O(1)</code></li>
</ul>
</li>
</ul>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>用堆实现，队首元素是当前队列中优先级最高的一个</p>
<ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">priority_queue&lt;type&gt; name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素访问<br>只能通过<code>top()</code>来访问队首元素（优先级最高）<br>（ps：使用<code>top()</code>前要用<code>empty()</code>判断队是否空）</p>
</li>
<li><p>常用函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pq.push(x);	<span class="comment">// O(logN), 入队</span></span><br><span class="line">pq.top();	<span class="comment">// O(1)</span></span><br><span class="line">pq.pop();	<span class="comment">// O(logN), 令队首元素出队</span></span><br><span class="line">pq.empty();	<span class="comment">// O(1), 队是否空</span></span><br><span class="line">pq.<span class="built_in">size</span>();	<span class="comment">// O(1)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优先级设置</strong></p>
<ul>
<li><p>基本数据类型<br>默认为大顶堆。小顶堆写法为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt; [type], <span class="built_in">vector</span>&lt;[type]&gt;, greater&lt;[type]&gt; &gt; pq;</span><br></pre></td></tr></table></figure>
<p><code>vector&lt;[type]</code>：承载堆的容器；<code>greater&lt;[type]&gt;</code>：小于对应大优先级</p>
</li>
<li><p>结构体优先级</p>
<p>写在结构体内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="comment">// 重载小于号</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> fruit&amp; f1, <span class="keyword">const</span> fruit&amp; f2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &lt; f2.price;	<span class="comment">// 价格大的优先级大, 相当大顶堆</span></span><br><span class="line">        <span class="comment">// return f1.price &gt; f2.price // 价格小的优先级大，即小顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;fruit&gt; pq;</span><br></pre></td></tr></table></figure>
<p>（<code>friend</code>友元允许非成员函数访问类/结构体的所有成员）</p>
<p>写在结构体外：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> fruit&amp; f1, <span class="keyword">const</span> fruit&amp; f2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price &gt; f2.price;	<span class="comment">// 小顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;fruit, <span class="built_in">vector</span>&lt;fruit&gt;, cmp&gt; pq;</span><br></pre></td></tr></table></figure>
<p>注意：结构体指针的比较需另写struct cmp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Node* n1, <span class="keyword">const</span> Node* n2)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n1-&gt;v &gt; n2-&gt;v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Node*, <span class="built_in">vector</span>&lt;Node*&gt;, cmp&gt; pq;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>后进先出</p>
<ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;type&gt; name</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素访问<br><code>st.top()</code></p>
</li>
<li><p>常用函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">st.push(x);		<span class="comment">// O(1)</span></span><br><span class="line">st.top();		<span class="comment">// O(1)</span></span><br><span class="line">st.pop();		<span class="comment">// O(1)</span></span><br><span class="line">st.empty();		<span class="comment">// O(1)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他</p>
<ul>
<li>通常通过重新定义一个栈来完成栈的清空<code>O(1)</code></li>
</ul>
</li>
</ul>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>将两个元素合成为一个</p>
<ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line">pair&lt;type1, type2&gt; name;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">pair&lt;type1, type2&gt; p(value1, value2);</span><br><span class="line"><span class="comment">//临时构建</span></span><br><span class="line">pair&lt;type1, type2&gt;(value1, value2);	<span class="comment">// 方法一</span></span><br><span class="line">make_pair(value1, value2);		<span class="comment">// 方法二</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>元素访问</p>
<p>只有两个元素：<code>p.first</code>，<code>p.second</code></p>
</li>
<li><p>常用函数</p>
<ul>
<li>比较操作<br>直接使用比较符号如<code>&gt;=, !=</code>。首先比较<code>first</code>，只有当<code>first</code>相等时才去比较<code>second</code><br>（可类似<code>priority_queue</code>重写<code>&lt;</code>号）</li>
</ul>
</li>
<li><p>常见用途<br>作为map的键值对插入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mp.insert(make_pair(value1, value2));s</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="algorithm头文件下的常用函数"><a href="#algorithm头文件下的常用函数" class="headerlink" title="algorithm头文件下的常用函数"></a>algorithm头文件下的常用函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x, y为整数</span></span><br><span class="line"><span class="built_in">max</span>(x, y);</span><br><span class="line"><span class="built_in">min</span>(x, y);</span><br><span class="line"><span class="built_in">abs</span>(x);		<span class="comment">// 若想获取浮点数的绝对值，使用math头文件下的fabs</span></span><br><span class="line"></span><br><span class="line">swap(x, y);	<span class="comment">// 交换x和y的值</span></span><br><span class="line"></span><br><span class="line">reverse(it1, it2);	<span class="comment">// 使数组或STL的[it1, it2)之间的元素反转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span> a[N];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d%d%d..."</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]...);   </span><br><span class="line">&#125; <span class="keyword">while</span> (next_permutation(it1, it2));	<span class="comment">// 给出序列[it1, it2)在全排列中的下一个序列</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fill</span>(it1, it2, value);	<span class="comment">// 给数组或容器的某一段区间赋值value, 区别memset</span></span><br><span class="line"></span><br><span class="line">sort(it1, it2, cmp);	<span class="comment">// 默认升序</span></span><br><span class="line"></span><br><span class="line">lower_bound(it1, it2, val);	<span class="comment">// 寻找[it1, it2)内第一个值大于等于val的元素位置，返回指针/迭代器</span></span><br><span class="line">upper_bound(it1, it2, val);	<span class="comment">// 返回第一个大于val的元素位置</span></span><br><span class="line"><span class="comment">// ps: 如果没有该元素，返回的是可供插入的位置，即假设元素存在时其所在的位置</span></span><br><span class="line"><span class="comment">// 		若只想获得下标，令返回值减去数组首地址即可</span></span><br></pre></td></tr></table></figure>
<h2 id="数据结构专题"><a href="#数据结构专题" class="headerlink" title="数据结构专题"></a>数据结构专题</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;	<span class="comment">// 数据域</span></span><br><span class="line">    node* next;	<span class="comment">// 指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;	<span class="comment">// 用数组下标表示指针域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>空间分配</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C malloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">node* p = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line"></span><br><span class="line"><span class="comment">// c++ new</span></span><br><span class="line">node* p = <span class="keyword">new</span> node;</span><br></pre></td></tr></table></figure>
<p>(申请较大动态数组时可能会失败)</p>
<p><strong>内存泄漏</strong>：使用<code>malloc</code>或<code>new</code>分配的空间，使用后没有释放，直到程序结束前一直占据。</p>
<p>内存泄漏会导致内存消耗过快而最终五内存可使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C free</span></span><br><span class="line"><span class="built_in">free</span>(p);	<span class="comment">// p为指针变量，free释放p指向的空间，并将p指向NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="keyword">delete</span>(p);</span><br></pre></td></tr></table></figure>
<p><code>malloc</code>与<code>free</code>成对出现；<code>new</code>与<code>delete</code>成对出现</p>
</li>
<li><p>创建与增删</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node *p, *head;</span><br><span class="line">	</span><br><span class="line">	head = <span class="keyword">new</span> node;	<span class="comment">// 使用头节点，相当于数组的下标0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = <span class="keyword">new</span> node;</span><br><span class="line">		p-&gt;val = arr[i];</span><br><span class="line">		p-&gt;next = head-&gt;next;</span><br><span class="line">		head-&gt;next = p;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* head, <span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node* p = head;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// p移动到pos的前一个元素位置 </span></span><br><span class="line">	<span class="comment">// (p从head开始，i从0开始，i到达pos-1时，p也到达第pos-1个元素) </span></span><br><span class="line">    <span class="comment">// 使用头节点即可不用讨论在链表头插入的情况</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pos - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>; i++, p = p-&gt;next);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span> || i &gt; pos - <span class="number">1</span>)	<span class="comment">// i小于1或大于表长</span></span><br><span class="line">		<span class="keyword">return</span>;	</span><br><span class="line">    </span><br><span class="line">	node* q = <span class="keyword">new</span> node;</span><br><span class="line">	q-&gt;val = val;</span><br><span class="line">	q-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = q;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删(删除某一位置上的元素)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(node* head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node* p = head;</span><br><span class="line">	node* q = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 同insert寻找前元</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos - <span class="number">1</span>; i++, p = p-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	q = p-&gt;next;	<span class="comment">// 要删除q</span></span><br><span class="line">	p-&gt;next = q-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span>(q);	<span class="comment">// 与new成对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态链表排序<br>将有效结点前置，按升序排序。之后即可用数组下标访问链表，数组序即为排序后的链表序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义有效位</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, addr;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> valid;	<span class="comment">// 为true表示在链表上</span></span><br><span class="line">&#125;ls[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node&amp; n1, <span class="keyword">const</span> node&amp; n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n1.valid &amp;&amp; n2.valid)	<span class="comment">// 都是有效结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> n1.data &lt; n2.data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> n1.valid &gt; n2.valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort需要排所有元素（包括无效的）</span></span><br><span class="line">sort(ls, ls+maxn, cmp);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="搜索专题"><a href="#搜索专题" class="headerlink" title="搜索专题"></a>搜索专题</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>找“岔路口”与“死胡同”</p>
<p>比如背包问题，对每个物品，有选或不选两种选择即“岔路口”；物品重量总和超过V或已完成n个物品选择，就到达“死胡同”</p>
<p>用递归即可写出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> sumW, <span class="keyword">int</span> sumC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == n)	<span class="comment">// 完成选择 </span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    dfs(index + <span class="number">1</span>, sumW, sumC);	<span class="comment">// 岔路1：选</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sumW + w[index] &lt;= V)	<span class="comment">// 如果重量超过，到达死胡同</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sumC + c[index] &gt; <span class="built_in">max</span>) </span><br><span class="line">            <span class="built_in">max</span> = sumC + c[index];</span><br><span class="line">        </span><br><span class="line">        dfs(index + <span class="number">1</span>, sumW + w[index], sumC + c[index]);	<span class="comment">// 岔路2：不选</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>访问完所有邻接点，再往下层</p>
<p>一般用队列实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);	<span class="comment">// 起点入队</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取队首元素q.front();</span></span><br><span class="line">        <span class="comment">// *****访问*****</span></span><br><span class="line">        q.pop();	<span class="comment">// 队首出队</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (当前元素的邻接点x)</span><br><span class="line">            q.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迷宫问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增量数组</span></span><br><span class="line"><span class="keyword">int</span> X[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Y[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.push(S);</span><br><span class="line">    inq[S.x][S.y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取队首</span></span><br><span class="line">        node top = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (top.x == T.x &amp;&amp; top.y == T.y) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> top.<span class="built_in">step</span>;	<span class="comment">// 遇到终点返回, 此时就是最小步数</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 利用增量数组访问四个方向上的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> newX = top.x + X[i];</span><br><span class="line">            <span class="keyword">int</span> newY = top.y + Y[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(newX, newY) &amp;&amp; !inq[newX][newY])	<span class="comment">// 点合法且没入过队</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">Node <span class="title">node</span><span class="params">(newX, newY)</span></span>;</span><br><span class="line">                node.<span class="built_in">step</span> = top.<span class="built_in">step</span> + <span class="number">1</span>;	<span class="comment">// 步数增加</span></span><br><span class="line">                q.push(node);	<span class="comment">// 结点入队</span></span><br><span class="line">                inq[newX][newY] = <span class="literal">true</span>;	<span class="comment">// 标记结点已入过队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注<code>inq[x][y]</code>的含义是判断结点是否入过队，而非结点是否已被访问。如果使用后者定义会导致重复入队，进而造成重复访问</li>
<li><p>迷宫问题考虑的重点是：检查下一次可以走到的位置以及它们是否合法</p>
</li>
<li><p><a href="http://codeup.cn/problem.php?cid=100000609&amp;pid=2" target="_blank" rel="noopener">8数码难题</a>的启发</p>
<ul>
<li>将数字排列的矩阵，转换为一串整型数字，当作状态，用于剪枝。已到过该状态就无需再入队</li>
<li><code>sprintf</code>和<code>sscanf</code>处理字符串和数字间的转换</li>
</ul>
</li>
</ul>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>一些定义与概念</p>
<ul>
<li>结点、根结点、叶子结点、子树、边</li>
<li>层次：根节点为第1层，往下增；<ul>
<li>深度：即层数</li>
<li>高度：从最底层叶子结点（高度为1）向上逐层累加至该结点</li>
</ul>
</li>
<li>度<ul>
<li>结点的度：该结点子树的棵数，叶子结点的度为0</li>
<li>树的度：树中结点的最大的度</li>
</ul>
</li>
<li>祖先、子孙：自己既是自己的祖先结点，也是自己的子孙结点</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>概念</p>
<ul>
<li>递归定义：要么没有根节点，是一棵空树；要么由根节点、左子树、右子树组成，子树都是二叉树<br>（与度为2的树的区别：不能随意交换左右子树的位置）</li>
<li>满二叉树：每层结点个数都达到最大</li>
<li>完全二叉树：除最后一层，其余层节点数都达到最大</li>
</ul>
<p>定义与增删改查</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;</span><br><span class="line">    node* lch;</span><br><span class="line">    node* rch;</span><br><span class="line">&#125;;</span><br><span class="line">node* root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建节点</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">typename</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* p = <span class="keyword">new</span> node;</span><br><span class="line">    p-&gt;data = x;</span><br><span class="line">    p-&gt;lch = <span class="literal">NULL</span>; p-&gt;rch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改查</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* p, <span class="keyword">typename</span> x, <span class="keyword">typename</span> newData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == x)</span><br><span class="line">        root-&gt;data = newData;</span><br><span class="line">    </span><br><span class="line">    search(root-&gt;lch, x, newData);</span><br><span class="line">    search(root-&gt;rch, x, newData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（注意*root带引用）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">typename</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = newNode(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (xxx)	<span class="comment">// 根据性质</span></span><br><span class="line">        insert(root-&gt;lch, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        insert(root-&gt;rch, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">typename</span> data[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完全二叉树的递归创建</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* root = newNode(x);</span><br><span class="line">    root-&gt;lch = create(<span class="number">2</span> * x);		<span class="comment">// 递归创建左子树</span></span><br><span class="line">    root-&gt;rch = create(<span class="number">2</span> * x + <span class="number">1</span>);	<span class="comment">// 递归创建右子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先序 中-左-右</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;x);</span><br><span class="line">    </span><br><span class="line">    preOrder(root-&gt;lch);</span><br><span class="line">    preOrder(root-&gt;rch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序 左中右</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    inOrder(root-&gt;lch);</span><br><span class="line">     <span class="comment">// 访问</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;x);</span><br><span class="line">    </span><br><span class="line">    inOrder(root-&gt;rch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序 左右中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    postOrder(root-&gt;lch);</span><br><span class="line">    postOrder(root-&gt;rch);</span><br><span class="line">    <span class="comment">// 访问</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">layerOrder</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">    </span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node* now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 访问</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (now-&gt;lch != <span class="literal">NULL</span>) q.push(now-&gt;lch);</span><br><span class="line">        <span class="keyword">if</span> (now-&gt;rch != <span class="literal">NULL</span>) q.push(now-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二叉树静态实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用数组下标代表指针，-1表示NULL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;</span><br><span class="line">    <span class="keyword">int</span> lch;</span><br><span class="line">    <span class="keyword">int</span> rch;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建结点</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node[index].data = v;</span><br><span class="line">    Node[index].lch = Node[index].rch = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其余的与指针表示一致</span></span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>有些题按层序标了号，要求计算一些特性，此时可能无需建树（只需假想一棵树），利用下标计算：<br>当前结点: x，<strong>左子: 2x</strong>，<strong>右子: 2x+1</strong>，<br>判断超出范围：2x &gt; n</li>
</ul>
<h3 id="一般的树"><a href="#一般的树" class="headerlink" title="一般的树"></a>一般的树</h3><p>尽量考虑静态写法，maxn为结点数上限</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sreuct node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typename</span> data;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;	<span class="comment">// 子结点下标</span></span><br><span class="line">&#125; Node[maxn];</span><br></pre></td></tr></table></figure>
<p>从树的遍历看DFS与BFS</p>
<ul>
<li>DFS：合法的DFS都能画出树的形式，“死胡同”等价于叶子结点；“岔路口”等价于非叶子结点，DFS遍历过程即树的<strong>先序遍历</strong>过程<br>从树的角度引入对状态的剪枝</li>
<li>BFS：即对树的层序遍历</li>
</ul>
<p>需要再看看的题目</p>
<ul>
<li>codeup_611_b 子结点计算</li>
<li>codeup_611_d 树重建（主要看指针方式存储树的创建）</li>
</ul>
<h3 id="二叉查找树-BST"><a href="#二叉查找树-BST" class="headerlink" title="二叉查找树 BST"></a>二叉查找树 BST</h3><p>也叫<strong>二叉排序树</strong></p>
<p>递归定义：</p>
<ul>
<li>要么是一棵空树</li>
<li>要么由根节点、左右子树构成，左子树上的结点小于根结点，右子树上的结点大于根节点</li>
</ul>
<p>性质：</p>
<ul>
<li>对二叉查找树进行<strong>中序遍历</strong>，遍历结果是<strong>有序</strong>的</li>
</ul>
<p>编码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找 O(h)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(node* root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)	<span class="comment">// 查找失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x == root-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> search(root-&gt;lch, x);	<span class="comment">// 小于则往左找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> search(root-&gt;rch, x);	<span class="comment">// 大于则往右找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入 O(h)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span>	<span class="comment">// 没有修改根节点的值, 而是为对应层的root赋予新的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)	<span class="comment">// 查找失败，即插入的位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = newNode(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x == root-&gt;data)	<span class="comment">// 查找成功，已存在该点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root-&gt;data)</span><br><span class="line">        insert(root-&gt;lch, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        insert(root-rch, x);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立</span></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        insert(root, data[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除比较难，单独记录一下：</p>
<p>删除结点v的基本思路是：使v的<strong>前驱</strong>（左子树的最大结点，即左子树最右结点）或<strong>后继</strong>（右子树的最小结点，即右子树的最左结点）覆盖v，然后递归删除前驱或后继</p>
<p>编码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">node* <span class="title">findMax</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Q: 为什么这里传指针，还能修改呢？</span></span><br><span class="line">	<span class="comment">// A: 因为没有改指针里的内容，将node*看成unsigned int，实际上传进来的是拷贝</span></span><br><span class="line">	<span class="keyword">while</span> (root-&gt;rch != <span class="literal">NULL</span>)</span><br><span class="line">		root = root-&gt;rch;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node* <span class="title">findMin</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (root-&gt;lch != <span class="literal">NULL</span>)</span><br><span class="line">		root = root-&gt;lch;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(node* root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)	<span class="comment">// 找不到，删除失败</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x == root-&gt;data)	<span class="comment">// 找到结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lch == <span class="literal">NULL</span> &amp;&amp; root-&gt;rch == <span class="literal">NULL</span>)	<span class="comment">// 叶子结点直接删除</span></span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;lch != <span class="literal">NULL</span>)	<span class="comment">// 左子树非空</span></span><br><span class="line">        &#123;</span><br><span class="line">			node* pre = findMax(root-&gt;lch);	<span class="comment">// 找到前驱	</span></span><br><span class="line">            root-&gt;data = pre-&gt;data;	<span class="comment">// 覆盖待删除结点</span></span><br><span class="line">            deleteNode(root-&gt;lch, pre-&gt;data);	<span class="comment">// 在左子树继续删除pre</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">// 右子树非空</span></span><br><span class="line">        &#123;</span><br><span class="line">            node* next = findMin(root-&gt;rch);</span><br><span class="line">            root-&gt;data = next-&gt;data;</span><br><span class="line">            deleteNode(root-&gt;rch, next-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root-&gt;data)	<span class="comment">// 小，往左找</span></span><br><span class="line">        deleteNode(root-&gt;lch, x);</span><br><span class="line">    <span class="keyword">else</span>						<span class="comment">// 大，往右找</span></span><br><span class="line">        deleteNode(root-&gt;rch, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：一直删除前驱或后继会导致树退化成一条链，解决办法有：</p>
<ol>
<li>交替删除前驱或后继</li>
<li>记录高度，总是优先在高度较高的一棵子树里删除结点</li>
</ol>
<h3 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树 AVL树"></a>平衡二叉树 AVL树</h3><p>使树高在每次插入后保持O(logn)级别</p>
<h4 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h4><p><strong>平衡因子</strong>：左子树与右子树的高度差（ps：高度从叶子开始计算，叶子为1）</p>
<p>为记录平衡因子，需要在树的结构中增加变量height：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    Node* lch, rch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* node = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="number">1</span>;	<span class="comment">// 初始树高为1</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取树高</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)	<span class="comment">// 空结点的高度为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算平衡因子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getHeight(root-&gt;lch) - getHeight(root-&gt;rch));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新树高</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 需要#include &lt;algorithm&gt;</span></span><br><span class="line">    root-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(getHeight(root-&gt;lch), getHeight(root-&gt;rch)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AVL树的重点是插入，需要考虑平衡的调整：</p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><ul>
<li><p>左旋：</p>
<ol>
<li>使B的左子树♦成为A的右子树</li>
<li>使A成为B的左子树、更新高度</li>
<li>根节点设置为B</li>
</ol>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309131148866.png" alt="image-20210309131148866"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftRotation</span><span class="params">(Node* &amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* temp = root-&gt;rch;</span><br><span class="line">    </span><br><span class="line">    root-&gt;rch = temp-&gt;lch;	<span class="comment">// 步骤1</span></span><br><span class="line">    temp-&gt;lch = root;		<span class="comment">// 步骤2</span></span><br><span class="line">    updateHeight(root);		<span class="comment">// 顺序别反，root此时是temp的子树</span></span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;			<span class="comment">// 步骤3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右旋</p>
<ol>
<li>使A的右子树成为B的左子树</li>
<li>使B成为A的右子树、更新高度</li>
<li>根节点设置为A</li>
</ol>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309132227795.png" alt="image-20210309132227795" style="zoom:80%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际上就是把左旋的lch和rch颠倒</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rightRotation</span><span class="params">(Node* &amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* temp = root-&gt;lch;</span><br><span class="line">    </span><br><span class="line">    root-&gt;lch = temp-&gt;rch;		<span class="comment">// 步骤1</span></span><br><span class="line">    temp-&gt;rch = root;			<span class="comment">// 步骤2</span></span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;				<span class="comment">// 步骤3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>AVL插入即BST插入+平衡调整</p>
<p>平衡调整：将最靠近插入结点的失衡结点调整到正常</p>
<p>四种情况（左插LL、LR，右插RR、RL）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>树形</th>
<th>判定条件</th>
<th>调整方法</th>
<th>示图</th>
</tr>
</thead>
<tbody>
<tr>
<td>LL</td>
<td>BF(root) = 2, <br />BF(root-&gt;lch)  = 1</td>
<td>对root右旋</td>
<td><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309133417940.png" alt="image-20210309133417940" style="zoom:50%;" /></td>
</tr>
<tr>
<td>LR</td>
<td>BF(root) = 2, <br />BF(root-&gt;lch) = -1</td>
<td>对root-&gt;lch左旋，再对root右旋</td>
<td><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309133715663.png" alt="image-20210309133715663" style="zoom:50%;" /></td>
</tr>
<tr>
<td>RR</td>
<td>BF(root) = -2, <br />BF(root-&gt;rch) = -1</td>
<td>对root左旋</td>
<td><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309134048706.png" alt="image-20210309134048706" style="zoom:50%;" /></td>
</tr>
<tr>
<td>RL</td>
<td>BF(root) = -2,<br />BF(root-&gt;rch) = 1</td>
<td>对root-&gt;rch右旋，再对root左旋</td>
<td><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309134154099.png" alt="image-20210309134154099" style="zoom:50%;" /></td>
</tr>
</tbody>
</table>
</div>
<p>编码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = newNode(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x &lt; root-&gt;data)	<span class="comment">// 左插</span></span><br><span class="line">    &#123;</span><br><span class="line">        insert(root-&gt;lch, x);</span><br><span class="line">        updateHeight(root);		<span class="comment">// 插入后别忘了更新树高</span></span><br><span class="line">        <span class="keyword">if</span> (getBalanceFactor(root) == <span class="number">2</span>)	<span class="comment">// 失衡：左高于右</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (getBalanceFactor(root-&gt;lch) == <span class="number">1</span>)	<span class="comment">// LL</span></span><br><span class="line">            &#123;</span><br><span class="line">                rightRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (getBalanceFactor(root-&gt;lch) == <span class="number">-1</span>)	<span class="comment">// LR</span></span><br><span class="line">            &#123;</span><br><span class="line">                leftRotation(root-&gt;lch);</span><br><span class="line">                rightRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">// 大于或等于root，右插</span></span><br><span class="line">    &#123;</span><br><span class="line">        insert(root-&gt;rch, x);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        <span class="keyword">if</span> (getBalanceFactor(root) == <span class="number">-2</span>)	<span class="comment">// 失衡：右高于左</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (getBalanceFactor(root-&gt;rch) == <span class="number">-1</span>)	<span class="comment">// RR</span></span><br><span class="line">            &#123;</span><br><span class="line">                leftRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (getBalanceFactor(root-&gt;rch) == <span class="number">1</span>)	<span class="comment">// RL</span></span><br><span class="line">            &#123;</span><br><span class="line">                rightRotation(root-&gt;rch);</span><br><span class="line">                leftRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>知道如何插入后，AVL树的建立与查找就和BST无异了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意易错点：</p>
<ul>
<li><code>search</code>不要想复杂了，查找树按照大小选择子树查找，如果找不到，就是查找失败，无需考虑其他树上有没有该结点</li>
<li>涉及对root本身的修改要记得用指针引用<code>Node* &amp;root</code>，这里有<code>leftRotation</code>, <code>rightRotation</code>和<code>insert</code></li>
<li><code>insert</code>之后要记得<code>updateHeight</code></li>
</ul>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>结点的路径长度：从根结点到该结点所经过的边数</p>
<p>叶子的<strong>带权路径长度</strong>：叶子的权值乘以路径长度</p>
<p>树的带权路径长度：所有叶子结点的带权路径长度之和</p>
<p><strong>哈夫曼树</strong>：树的带权路径最小的二叉树（最优二叉树）</p>
<p>构建过程：</p>
<ol>
<li>初始n个结点，视为n棵只有1个结点的树</li>
<li>合并其中<strong>权值最小</strong>的两棵树，生成两棵子树的父结点，权值为两个根结点之和</li>
<li>重复步骤2，直到只剩下一棵树为止，这棵树即哈夫曼树，根结点的权值为最小带权路径长度</li>
</ol>
<p>哈夫曼树的构建思想核心为：反复选择两个<strong>最小的元素</strong>，合并，直到剩下一个元素。有时无需构建树，只需通过合并，得到最终带权路径长度即可。</p>
<p>哈夫曼编码：</p>
<ul>
<li>对任何一个叶子结点，其编号一定不会成为其他任何结点编号的前缀</li>
<li>左0右1</li>
<li>按频次作为权值，字符串编码为01串的长度即树的带权路径长度</li>
</ul>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210311163608746.png" alt="image-20210311163608746"></p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>定义</p>
<ul>
<li><p>并（Union）：合并两个集合；</p>
</li>
<li><p>查（Find）：查找，判断两个元素是否在同一集合；</p>
</li>
<li><p>集（Set）：集合</p>
</li>
</ul>
<p>性质：</p>
<ul>
<li>并查集产生的每个集合都是一棵树（因为只对不同集合进行合并，集合内不会有环）</li>
</ul>
<p>实现：</p>
<ul>
<li>用数组<code>father[i]</code>记录结点i的父节点；若<code>i=father[i]</code>，说明i是根节点。一个集合只有一个根结点，其是集合的标志</li>
</ul>
<p>编码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line">    fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="comment">//int findFather(int x)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    while (x != fa[x])</span></span><br><span class="line"><span class="comment">//        x = fa[x];</span></span><br><span class="line"><span class="comment">//    return x;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">// 使用路径压缩的查找根节点方法 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = x;</span><br><span class="line">    <span class="keyword">while</span> (root != fa[root])	<span class="comment">// 找到根结点</span></span><br><span class="line">        root = fa[root];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])		<span class="comment">// 回溯x走过的结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = x;</span><br><span class="line">        fa[tmp] = root;		<span class="comment">// 将它们的父节点都标记为根结点</span></span><br><span class="line">        x = fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span> (faA != faB)			<span class="comment">// 若根节点不同</span></span><br><span class="line">        fa[faA] = faB;		<span class="comment">// 将一方的根结点指向另一方的根结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合个数 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">   	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[i] == i)		<span class="comment">// 集合的标志是根结点，只需数根结点的个数</span></span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充路径压缩的示意图：</p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210309224829582.png" alt="image-20210309224829582" style="zoom: 80%;" /></p>
<p>并查集模型的应用：</p>
<ul>
<li>输入一条边的两个点（双向边），使用<code>union</code>就能将两个点并在一个集合下，进而计数集合的个数或集合内元素个数</li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>定义</p>
<ul>
<li><p>堆是一棵<strong>完全二叉树</strong></p>
</li>
<li><p>大顶堆：树中每个结点的值都不小于孩子</p>
</li>
<li><p>小顶堆：不大于</p>
</li>
</ul>
<p>实现方式：用数组来存储完全二叉树，这样结点就按<strong>层序</strong>存储在数组中。第一个结点存于下标1，第i号的左孩子是<strong>2i</strong>，右孩子是<strong>2i+1</strong>，父亲是<strong>i/2</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> heap[MAXN];</span><br></pre></td></tr></table></figure>
<p>ps：如果不是强调自己实现堆，在可用STL的情况下，尽量用优先队列，不要造轮子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq;		<span class="comment">// 大顶堆</span></span><br><span class="line">priority_queue&lt; <span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; pq_s;	<span class="comment">// 小顶堆</span></span><br></pre></td></tr></table></figure>
<h3 id="向下调整"><a href="#向下调整" class="headerlink" title="向下调整"></a>向下调整</h3><ol>
<li>当前结点与其孩子比较，将其中权值大的孩子与V交换</li>
<li>继续让V与孩子比较，直到孩子的权值都比V小或没有孩子结点</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// O(logn)</span></span><br><span class="line"><span class="comment">// 对heap数组[low, high]范围进行调整</span></span><br><span class="line"><span class="comment">// low为预调整的结点下标，high为堆最后一个元素的下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = <span class="number">2</span> * i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high)	<span class="comment">// 存在孩子（左子不在右子肯定不在）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= hight &amp;&amp; heap[j+<span class="number">1</span>] &gt; heap[j])	<span class="comment">// 若存在右子，且右子大于左子</span></span><br><span class="line">            j = j + <span class="number">1</span>;		<span class="comment">// 令j为右子下标, j相当于max(左子, 右子)的下标</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (heap[j] &gt; heap[i])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(heap[j], heap[i]);	<span class="comment">// 交换</span></span><br><span class="line">            i = j;		<span class="comment">//	继续向下比较</span></span><br><span class="line">            j = <span class="number">2</span> * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;	<span class="comment">// 没有比结点i小的子结点，结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>完全二叉树的叶子结点个数为$\lceil \frac{n}{2} \rceil$,因此在$[1, \lfloor \frac{n}{2} \rfloor]$范围内的都是非叶子结点，</p>
<blockquote>
<p>n个结点的完全二叉树有性质 </p>
<p>1）n0+n1+n2=n（其中n0表示度为0的结点）<br>2）n0=n2+1</p>
<p>3）n1 = 0 或 1</p>
<p>综上可得n0 = $\lceil \frac{n}{2} \rceil$</p>
</blockquote>
<p>从$\lfloor \frac{n}{2} \rfloor$倒着枚举，对遍历到的结点$i$进行$[i, n]$范围的调整。</p>
<p>倒着调整是因为，每次调整一个结点后，当前子树中权值最大的结点就会处于子树的根结点位置（这正是向下调整的逻辑），轮到父节点调整时，又可以直接使用这一结果，保证了<strong>每个结点都是以其为根结点的子树的权值最大点</strong></p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210310212428242.png" alt="image-20210310212428242" style="zoom:67%;" /></p>
<p>记住结论即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        downAdjust(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除堆顶"><a href="#删除堆顶" class="headerlink" title="删除堆顶"></a>删除堆顶</h3><p>思路：用最后一个结点覆盖堆顶结点（根结点），然后对根结点向下调整</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// O(logn)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>] = heap[n--];</span><br><span class="line">    downAdjust(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="增添元素"><a href="#增添元素" class="headerlink" title="增添元素"></a>增添元素</h3><p>思路：把要添加的元素放在数组最后，然后向上调整</p>
<p><strong>向上调整</strong>：与父结点比较，如果比父节点大就交换，直到到达堆顶或父节点权值大为止</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// O(logn)</span></span><br><span class="line"><span class="comment">// low一般为1，high为欲调整结点的下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = high, j = i / <span class="number">2</span>;	<span class="comment">// j为父节点下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (j &gt;= low)	<span class="comment">//父节点在数组范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap[j] &lt; heap[i])	<span class="comment">// 父节点小</span></span><br><span class="line">        &#123;</span><br><span class="line">            swap(heap[j], heap[i]);		<span class="comment">// 与父节点交换交换</span></span><br><span class="line">            i = j;		<span class="comment">// 继续向上调整</span></span><br><span class="line">            j = i / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(logn)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heap[++n] = x;</span><br><span class="line">    upAdjust(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>思路：取出堆顶元素，然后将堆的最后一个元素替换至堆顶，然后对堆顶向下调整</p>
<p>实际上为了节省空间，用原来存储heap的数组来存排序后的序列，所以用倒着遍历heap数组实现堆排序</p>
<ol>
<li>i从n开始遍历，直到堆只1个元素</li>
<li>访问到i，将i与堆顶交换</li>
<li>在[1, i-1]范围对堆顶进行向下调整</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// O(nlogn)</span></span><br><span class="line"><span class="comment">// 堆排序与快排有相同的时间复杂度，且不会退化</span></span><br><span class="line"><span class="comment">// 但堆排较快排的劣势是常数较大</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    createHeap();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--)	<span class="comment">// 遍历直到堆只剩1个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        swap(heap[<span class="number">1</span>], heap[i]);	<span class="comment">// 与堆顶交换</span></span><br><span class="line">        downAdjust(<span class="number">1</span>, i - <span class="number">1</span>);	<span class="comment">// 调整堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下</p>
<ul>
<li>倒着遍历：<ul>
<li>建堆：数组中已有数据，从$\lceil \frac{n}{2} \rceil$开始倒着遍历，对每个结点向下调整，建立起堆结构</li>
<li>堆排序：从结点n开始倒着遍历，和堆顶交换，对堆顶向下遍历，已访问的结点固定不再动</li>
</ul>
</li>
<li>调整<ul>
<li>向下调整：用于建堆、删除堆顶、堆排序。后二者是对堆顶向下调整，调整后，子树根结点就存放着最大元素</li>
<li>向上调整：用于插入时，将尾巴插入的结点调整到它的位置</li>
</ul>
</li>
</ul>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>定义：</p>
<ul>
<li><p>图由顶点和边组成：G(V, E)</p>
</li>
<li><p>有向图与无向图 </p>
</li>
<li><p>度：和顶点相连的边的条数；<br>入度：入边条数；出度：出边条数</p>
</li>
<li>权值：点权、边权</li>
</ul>
<h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><p>邻接矩阵：</p>
<ul>
<li><p>G[i][j]=1代表结点i和j之间有边，G[i][j]=0或-1表示无边</p>
</li>
<li><p>G[i][j]存放边权，对于不存在的边可设为0、-1或一个很大的数</p>
</li>
</ul>
<p>一般适用于顶点数目不大（不超过1000）的题目</p>
<hr>
<p>邻接表</p>
<p><code>Adj\[i\]</code>存放顶点<code>i</code>的所有<strong>出边</strong>组成的列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w;	<span class="comment">// 编号、边权</span></span><br><span class="line">    Node(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w) : v(_v), w(_w) &#123;&#125;	<span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[N];</span><br></pre></td></tr></table></figure>
<p>使用构造函数实现加边</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Adj[i].push_back(Node(<span class="number">3</span>, <span class="number">4</span>));	<span class="comment">// i和3之间的边，结点3的权值为4</span></span><br></pre></td></tr></table></figure>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>对无向图：</p>
<ul>
<li><strong>连通</strong>：两个顶点之间相互<strong>可达</strong></li>
<li><strong>连通图</strong>：图G(V, E)中任意两个顶点<strong>连通</strong></li>
<li><strong>连通分量</strong>：非连通图中的<strong>极大连通子图</strong></li>
</ul>
<p>对有向图：</p>
<ul>
<li><strong>强连通</strong>：两个顶点各有一条有向路径通向另一个顶点（即可达）</li>
<li><strong>强连通图</strong>：图G(V, E)中任意两个顶点<strong>强连通</strong></li>
<li><strong>强连通分量</strong>：非强连通图中的<strong>极大强连通子图</strong></li>
</ul>
<hr>
<h4 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h4><p>邻接表版：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（ps：其本质还是递归边界和递归式，不过递归边界隐藏在邻接点访问和vis[]数组中，</span></span><br><span class="line"><span class="comment">// 没有点可访问了就到了递归边界）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 访问结点u</span></span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	...访问细节</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问u的邻接点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = adj[u][i];</span><br><span class="line">        <span class="keyword">if</span> (!vis[v])</span><br><span class="line">            DFS(v, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTravel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历所有连通块</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[u])</span><br><span class="line">            DFS(u, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无向图、邻接矩阵存储，涉及边权的累计：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span>&amp; totalW)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[u] = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	访问...</span></span><br><span class="line"><span class="comment">   	*/</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;nump; v++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (G[u][v] &gt; <span class="number">0</span>)	<span class="comment">// 如果有边</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 累计边权 </span></span><br><span class="line">			totalW += G[u][v];</span><br><span class="line">			G[u][v] = G[v][u] = <span class="number">0</span>;	<span class="comment">// ***/删除边，防止回头，因为此处不考虑是否访问过</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// dfs访问 </span></span><br><span class="line">			<span class="keyword">if</span> (!vis[v])</span><br><span class="line">				DFS(v, totalW);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h4><p>之前介绍过了，这里只放图的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵版</span></span><br><span class="line"><span class="keyword">int</span> n, G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">bool</span> inq[MAXV] = &#123;<span class="literal">false</span>&#125;;	<span class="comment">// 是否入过队</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 有边且未入过队</span></span><br><span class="line">            <span class="keyword">if</span> (!inq[v] &amp;&amp; G[u][v] != INT_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                inq[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表版 参考搜索专题</span></span><br></pre></td></tr></table></figure>
<p>注意：清空<code>inq</code>数组时，要对整个MAXV长度清空，否则后面来的如果访问顶点数大于前者</p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><p>算法流程：</p>
<ol>
<li>从未访问过的点集（V-S）中找到一个与起点距离最小的点u</li>
<li>u作为中介点，对起点s 与 所有从u能到达的未访问顶点 进行relaxing（松弛）操作</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">int</span> d[MAXV];</span><br><span class="line"><span class="keyword">int</span> pre[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d, d+MAXV, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取与顶点距离最小的点</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minD = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; d[j] &lt; MIN)</span><br><span class="line">            &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minD = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>)	<span class="comment">// 找不到点，说明剩下的点不连通</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 松弛操作</span></span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF &amp;&amp; d[u] + G[u][v] &lt; d[v])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + G[u][v];</span><br><span class="line">                pre[v] = u;		<span class="comment">// 记录前驱结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归输出最短路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s, pre[v]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三种可能的第二标尺（多条最短路径时的其他衡量标准）：</p>
<p>只需在relaxing操作中进行修改</p>
<ul>
<li><p>新增边权（如花费）<br>初始化合数组d相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[v] = d[u] + G[u][v];</span><br><span class="line">            c[v] = c[u] + cost[u][v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + G[u][v] == d[v] &amp;&amp; c[u] + cost[u][v] &lt; c[v])	<span class="comment">// 多条</span></span><br><span class="line">            c[v] = c[u] + cost[u][v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增点权（如每个点的资源）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// w[u]记录从起点s到点u收集的最大资源数（前提为路径最短）</span></span><br><span class="line"><span class="comment">// 初始化w[s]=weight[s]，其余w[u]=0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[v] = d[u] + G[u][v];</span><br><span class="line">            w[v] = w[u] + weight[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + G[u][v] == d[v] &amp;&amp; w[u] + weight[v] &gt; w[v])	<span class="comment">// 多条</span></span><br><span class="line">            w[v] = w[u] + weight[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求最短路径条数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[v] = d[u] + G[u][v];</span><br><span class="line">            num[v] = num[u];	<span class="comment">// 仅一条时，遵循上个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + G[u][v] == d[v])</span><br><span class="line">            num[v] += num[u];	<span class="comment">// 有多条不同的最短路通往v</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用Dij+dfs简化逻辑：</p>
<ol>
<li><p>使用dij记录下所有最短路径</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在relaxing操作中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[u] + G[u][v] &lt; d[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[v] = d[u] + G[u][v];</span><br><span class="line">            pre[v].<span class="built_in">clear</span>();		<span class="comment">// 因为最短路已换，前驱需清空</span></span><br><span class="line">            pre[v].push_back(u);	<span class="comment">// 添加新的前驱</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d[u] + G[u][v] == d[v])</span><br><span class="line">            pre[v].push_back(u);	<span class="comment">// 记录多个前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历所有最短路径，找出第二标尺最优的路径<br>遍历过程相当于对终点为根结点，起点为叶子结点（可重复）的递归树的搜索</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[MAXV];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path, tempPath;</span><br><span class="line"><span class="keyword">int</span> optValue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> curValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == st)	<span class="comment">// 到达起点，形成一条倒着的完整最短路</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (curValue 优于 optValue)	<span class="comment">// 更新</span></span><br><span class="line">		&#123;</span><br><span class="line">			optValue = curValue;</span><br><span class="line">			path = tempPath;</span><br><span class="line">			path.push_back(v);		<span class="comment">// 别忘了添加起点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tempPath.push_back(v);	<span class="comment">// 加入临时的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre[v].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = pre[v][i];</span><br><span class="line">        dfs(u, curValue + value[u][v]);		<span class="comment">// 递归访问前驱结点，累计第二标尺的权值</span></span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.pop_back();	<span class="comment">// 删除结点v，因为要记录其他最短路</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：</p>
<ul>
<li>INF要用<code>const int INF = 1e9</code>定义，不要用<code>#define</code>，后者值为0，原因不明</li>
<li>所有的min都要记得初始化</li>
</ul>
<h4 id="Bellman-Ford与SPFA"><a href="#Bellman-Ford与SPFA" class="headerlink" title="Bellman-Ford与SPFA"></a>Bellman-Ford与SPFA</h4><p><strong>Bellman-Ford：</strong></p>
<p>邻接表实现为$O(VE)$，思路如下：</p>
<p>进行V-1轮操作，每轮对所有边松弛</p>
<p>最后一轮再对所有边松弛，如果仍能松弛，说明有原点可达的负环，返回false；否则返回true；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">d[s] = <span class="number">0</span>;	<span class="comment">// 起点为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (each edge e[u][v])</span><br><span class="line">        <span class="keyword">if</span> (d[u] + e[u][v] &lt; d[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[v] = d[u] + e[u][v];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (each edge e[u][v])</span><br><span class="line">    <span class="keyword">if</span> (d[u] + e[u][v] &lt; d[v])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>SPFA：</strong></p>
<p>邻接表实现为$O(kE)$，从B-F算法优化而来，思路如下：</p>
<p>只有当某个顶点d[u]的值改变时，从它出发的邻接点v的d[v]才有可能改变</p>
<p>因此建立一个队列，每次松弛后，如果顶点不在队中，将其入队。若入队次数超过V-1次，则存在负环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Node&gt; adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> d[MAXV], num[MAXV];</span><br><span class="line"><span class="keyword">bool</span> inq[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d, d + MAXV, INF);</span><br><span class="line">    <span class="comment">// 原点入队</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    inq[s] = <span class="literal">true</span>; num[s]++; d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 主体</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取队首</span></span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[u].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// relaxing</span></span><br><span class="line">            <span class="keyword">int</span> v = adj[u][v].v, dis = adj[u][v].dis;</span><br><span class="line">            <span class="keyword">if</span> (d[u] + dis &lt; d[v])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + dis;</span><br><span class="line">                <span class="keyword">if</span> (!inq[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    inq[v] = <span class="literal">true</span>; num[v]++;</span><br><span class="line">                    <span class="keyword">if</span> (num[v] &gt;= n)	<span class="comment">// 有可达负环</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用优先队列<code>priority_queue</code>进行优化</p>
<h4 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h4><p>全源最短路径算法，$O(n^3)$，n应限制在200以内</p>
<p>基本思想：枚举中介点k，使用k任意两个顶点进行松弛操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[MAXV][MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dis[<span class="number">0</span>], dis[<span class="number">0</span>] + MAXV * MAXV, INF);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 松弛</span></span><br><span class="line">                <span class="keyword">if</span> (dis[i][k] != INF &amp;&amp; dis[k][j] != INF</span><br><span class="line">                   &amp;&amp; dis[i][k] + dis[k][j] &lt; dis[i][j])</span><br><span class="line">                    dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小生成树MST"><a href="#最小生成树MST" class="headerlink" title="最小生成树MST"></a>最小生成树MST</h3><p>MST（Minimum Spanning Tree）</p>
<p>在给定无向图G中求一棵树T，T包含G中所有顶点，且边都来自G，满足整棵树边权之和最小</p>
<ul>
<li>作为树，MST有：边数=顶点数-1</li>
<li>MST不唯一，但边权之和一定为1</li>
<li>一般给定一个根结点求最小生成树</li>
</ul>
<h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><p>复杂度$O(V^2)$，优先队列优化能达到$O(VlogV)$</p>
<p>基本思想：</p>
<ol>
<li><p>集合S存放已访问结点，每次从V-S中选择与S距离最小的点u，将该距离最小的边加入MST，并将u加入S</p>
</li>
<li><p>令顶点u为中介，优化 所有u的邻接点 与 集合S 之间的最短距离</p>
</li>
<li><p>循环n次后，即得到MST</p>
</li>
</ol>
<p>（Prim与Dij的思想几乎相同，区别只有：Prim松弛的是邻接点到集合S的距离，Dij松弛的是邻接点到起点之间的距离；在代码中体现为数组d[i]的意义）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">int</span> d[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fill</span>(d, d + MAXV, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minD = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; d[j] &lt; minD)</span><br><span class="line">            &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minD = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        ans += d[u];		<span class="comment">// 累计MST的边权</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; G[u][v] != INF)	<span class="comment">// 未访问过的邻接点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (G[u][v] &lt; d[v])		<span class="comment">// 如果能松弛到S的距离</span></span><br><span class="line">                &#123;</span><br><span class="line">                    d[v] = G[u][v];		</span><br><span class="line">                    <span class="comment">// 如果需要记录边，在这里记录，将d[v]和边u-&gt;v放入一个结构体中存储</span></span><br><span class="line">                &#125;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><p>复杂度$O(ElogE)$，开销来自于边排序</p>
<p>基本思想：边贪心策略</p>
<p>​    每次选择图中最小边权的边，如果加入不成环（边两端顶点在不同连通块中），就把边加入MST中</p>
<p>实现：使用并查集判断是否成环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 边结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">&#125; E[MAXE];</span><br><span class="line"><span class="comment">// 边排序使用的比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost &lt; b.cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="keyword">int</span> fa[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span>	<span class="comment">// n顶点数，m边数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, nEdges = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 并查集初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    <span class="comment">// 边排序</span></span><br><span class="line">    sort(E, E + m, cmp);</span><br><span class="line">    <span class="comment">// 遍历所有边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> faU = findFather(E[i].u);</span><br><span class="line">        <span class="keyword">int</span> faV = findFather(E[i].v);</span><br><span class="line">        <span class="keyword">if</span> (faU != faV)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[faU] = faV;		<span class="comment">// 集合合并</span></span><br><span class="line">            ans += E[i].cost;	<span class="comment">// MST边权累加</span></span><br><span class="line">            nEdges++;		<span class="comment">// MST的边数累加</span></span><br><span class="line">            <span class="keyword">if</span> (nEdges == n - <span class="number">1</span>)	<span class="comment">// 边数等于顶点数-1时，完成MST构建</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nEdges != n - <span class="number">1</span>)	<span class="comment">// 无法连通</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结</p>
<ul>
<li>prim和dij思想相近，都是不断优化<code>d[]</code>，复杂度与顶点数有关，适用于稠密图（边多点少）</li>
<li>kruskal使用边贪心策略，并查集判断是否成环，复杂度与边数有关，适用于稀疏图（边少点多）</li>
</ul>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>有向无环图（Directed Acyclic Graph， <strong>DAG</strong>）：有向、无环（任意点都无法通过边回到自身）</p>
<p>拓扑排序：将DAG图的所有顶点排成一个序列，如果存在边u-&gt;v，则序列中u一定在v之前</p>
<p>算法步骤：</p>
<ol>
<li>定义队列Q，将所有入度为0的结点入队</li>
<li>取队首结点输出，删去所有从它出发的边，并令边到达的结点入度-1</li>
<li>重复直到队空。如果入过队的结点数目为N，则排序成功；否则图中有环</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接表实现</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXV];</span><br><span class="line"><span class="keyword">int</span> inDegree[MAXV];	<span class="comment">// 入度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toplogicalSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;	<span class="comment">// 记录加入拓扑序列的结点数</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)</span><br><span class="line">            q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取队首</span></span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 访问：输出结点，或加入数组</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, u);</span><br><span class="line">        num++;		<span class="comment">// 累计加入拓扑序列的结点个数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新邻接点的入度、入度为0的结点入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>)</span><br><span class="line">                q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">        G[u].<span class="built_in">clear</span>();	<span class="comment">// 清空出边，如无必要可不写</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (num == n);	<span class="comment">// 加入拓扑序列的点数为n，说明无环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>AOV（Activity On Vertex）网：顶点活动网，用顶点表示活动，边集表示活动间优先关系的有向图</p>
<p>AOE（Activity On Edge）网：边活动网，带权边集表示活动，顶点表示事件的有向图。边权表示活动所需时间</p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210313210932268.png" alt="image-20210313210932268" style="zoom:67%;" /></p>
<p>源点：入度为0的点，表示起始事件；</p>
<p>汇点：出度为0的点，表示终止事件</p>
<p><strong>关键路径</strong>：AOE网中的<strong>最长路径</strong>，关键路径上的活动称为关键活动，关键路径的长度等于工程<strong>最短完成时间</strong></p>
<ul>
<li>最长？从路径长度上看，选择不能拖延的活动，组成的就是最长的路径，比较对象是选择其他路径的方案</li>
<li>最短？从时间角度看，不能拖延的活动按照时间完成就是最短的时间，比较对象是活动中有拖延的方案</li>
</ul>
<hr>
<p>AOE网实际是DAG图</p>
<p>求解关键路径的问题即 求解DAG图中最长路径</p>
<p>四个关键的数组：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据</th>
<th>定义</th>
<th>计算</th>
<th>图示</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>e[r]</code></td>
<td>活动$a_r$的最早开始时间</td>
<td><strong>e[r] = ve[i]</strong></td>
<td><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210313212311647.png" alt="image-20210313212311647" style="zoom:67%;" /></td>
</tr>
<tr>
<td><code>l[r]</code></td>
<td>活动$a_r$的最迟开始时间</td>
<td><strong>l[r] = vl[j] - length[r]</strong></td>
<td><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210313212311647.png" alt="image-20210313212311647" style="zoom:67%;" /><br />（活动r最迟开始时间+活动时间=事件j最迟发生时间）</td>
</tr>
<tr>
<td><code>ve[i]</code></td>
<td>事件$i$的最早发生时间</td>
<td><strong>ve[j] = max{ve[ip] + length[rp]}</strong></td>
<td><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210313212537246.png" alt="image-20210313212537246" style="zoom:67%;" /><br />（所有前驱事件发生、活动完成之后，Vj才能被激活，最后完成的是max）</td>
</tr>
<tr>
<td><code>vl[i]</code></td>
<td>事件$i$的最迟发生时间</td>
<td><strong>vl[i] = min{vl[jk] - length[rk]}</strong></td>
<td>（图中用了逆拓扑展示）<br /><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210313213046547.png" alt="image-20210313213046547" style="zoom:67%;" /><br />（事件i的最迟发生，加上活动时间，不能影响到任何后继事件，最先影响到的是min）</td>
</tr>
</tbody>
</table>
</div>
<p>编码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序，并计算ve</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; topOrder;	<span class="comment">// 使用栈是为了获取逆拓扑序列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toplogicalSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)</span><br><span class="line">            q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        topOrder.push(u);	<span class="comment">// 拓扑序列入栈</span></span><br><span class="line">        <span class="comment">// 遍历邻接点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].v;</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>)</span><br><span class="line">                q.push(v);</span><br><span class="line">            <span class="comment">// 使用ve[u]更新所有后继结点v的最早开始时间ve[v]</span></span><br><span class="line">			<span class="comment">// 本质是松弛操作（反向）</span></span><br><span class="line">            <span class="keyword">if</span> (ve[u] + G[u][i].w &gt; ve[v])</span><br><span class="line">                ve[v] = ve[u] + G[u][i].w;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> (topOrder.<span class="built_in">size</span>() == n);	<span class="comment">// n个结点进入序列才为成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">criticalPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ve, <span class="number">0</span>, <span class="keyword">sizeof</span>(ve));</span><br><span class="line">    <span class="comment">// 拓扑排序的过程中计算ve</span></span><br><span class="line">    <span class="comment">// 如果不是DAG图，返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (!toplogicalSort())	</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取汇点的最早发生时间</span></span><br><span class="line">    <span class="comment">// 汇点i顶是最后发生的事件，所以一定ve最大</span></span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ve[i] &gt; maxLength)</span><br><span class="line">            maxLength = ve[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill</span>(vl, vl + n, maxLength);	<span class="comment">// 初始化事件最晚发生时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用逆拓扑序列，更新事件的vl数组</span></span><br><span class="line">    <span class="keyword">while</span> (!topOrder.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = topOrder.top();</span><br><span class="line">        topOrder.pop();</span><br><span class="line">        <span class="comment">// 使用u的后继结点的来更新u的最迟发生时间vl[u]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].v;</span><br><span class="line">            <span class="keyword">if</span> (vl[v] - G[u][v].w &lt; vl[u])</span><br><span class="line">                vl[u] = vl[v] - G[u][v].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算关键路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].v, w = G[u][i].w;</span><br><span class="line">            <span class="comment">// 计算活动最早开始时间e和最迟开始时间l</span></span><br><span class="line">            <span class="keyword">int</span> e = ve[u], l = vl[v] - w;</span><br><span class="line">            <span class="keyword">if</span> (e == l)		<span class="comment">// 如果e==l，说明活动u-&gt;v（即这条边）是关键活动</span></span><br><span class="line">                nextPath[u] = v; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找出源点</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(ve[i] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">            s = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出路径</span></span><br><span class="line">    <span class="keyword">while</span> (nextPath[s] != s)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"(%c,%c) "</span>, vertices[s], vertices[nextPath[s]]);</span><br><span class="line">    	s = nextPath[s];</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxLength;	<span class="comment">// 关键路径长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划-DP"><a href="#动态规划-DP" class="headerlink" title="动态规划 DP"></a>动态规划 DP</h2><ul>
<li>状态：记录当前信息；状态转移方程：根据之前的状态计算当前状态值<br>如何设计二者是DP的核心</li>
<li>最优子结构：问题最优解可以由子问题的最优解构造出来</li>
<li>状态的无后效性：当前状态一旦确定，不再改变。只有当前状态能影响下一状态，历史信息只能通过已有状态影响决策，而不直接参与决策</li>
</ul>
<p>分治与DP</p>
<ul>
<li>同：都分解为子问题</li>
<li>异：分治的子问题不重叠，DP的重叠</li>
</ul>
<p>贪心与DP</p>
<ul>
<li>同：都要求最优子结构</li>
<li>异：贪心壮士断腕，直接选择一个子问题往下求解；DP总会考虑所有子问题，选择继承能得到最优解的一个</li>
</ul>
<h3 id="最大连续子序列"><a href="#最大连续子序列" class="headerlink" title="最大连续子序列"></a>最大连续子序列</h3><p>给定数字序列$A_1, …, A_n$，求$i, j$使$A_1 + … + A_j$最大，输出这个和</p>
<p>暴力：$O(n^2)$，DP：$O(n)$</p>
<p>状态：<code>dp[i]</code>表示以A[i]为结尾的连续序列最大和</p>
<p>状态转移方程：<code>dp[i] = max(A[i], dp[i-1] + A[i])</code></p>
<ul>
<li>一个元素：A[i]</li>
<li>多个元素：前面最大和dp[i-1]加上当前A[i]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    dp[i] = <span class="built_in">max</span>(A[i], dp[i<span class="number">-1</span>] + A[i]);</span><br><span class="line"><span class="comment">// max(dp[1], ..., dp[n-1])即为结果</span></span><br></pre></td></tr></table></figure>
<h3 id="最长不下降子序列-LIS"><a href="#最长不下降子序列-LIS" class="headerlink" title="最长不下降子序列 LIS"></a>最长不下降子序列 LIS</h3><p>LIS（Longest Increasing Sequence）</p>
<p>给定一个数字序列，子u最长的非下降子序列长度（可以不连续）</p>
<p>暴力：$O(2^n)$， DP：$O(n^2)$</p>
<p>状态：<code>dp[i]</code> 表示以A[i]结尾的LIS长度</p>
<p>状态转移方程：<code>dp[i] = max{1, dp[j] + 1}</code>（j=1, 2,…, i-1 &amp;&amp; A[j] &lt;= A[i]）</p>
<ul>
<li>A[i]跟在A[j]后面，LIS长度+1</li>
<li>A[i]自己成为一条新的LIS，长度为1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[j] &lt;= A[i] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i])</span><br><span class="line">            dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// asn = max(dp[0],...dp[n-1])</span></span><br></pre></td></tr></table></figure>
<h3 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列 LCS"></a>最长公共子序列 LCS</h3><p>给定两个字符串A和B，求字符串s，使s使A和B的最长公共部分（可以不连续）</p>
<p>复杂度：$O(nm)$</p>
<p>状态：<code>dp[i][j]</code> 表示A的<code>i</code>号位和B的<code>j</code>号位之前的LCS长度</p>
<p>状态转移方程：<br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210315144750560.png" alt="image-20210315144750560" style="zoom:80%;" /></p>
<ul>
<li>如果A[i]==B[i]，LCS长度为增加1位</li>
<li>否则，继承<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>中较大的一个</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> A[MAXN], B[MAXN];</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN], p[MAXN][MAXN];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LU = <span class="number">0</span>, U = <span class="number">1</span>, L = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gets(A + <span class="number">1</span>);	<span class="comment">// 从下标1开始读入</span></span><br><span class="line">    gets(B + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> lenA = <span class="built_in">strlen</span>(A + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> lenB = <span class="built_in">strlen</span>(B + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lenA; i++)</span><br><span class="line">    	dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= lenB; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenA; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lenB; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == B[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">             	p[i][j] = LU;		<span class="comment">// 左上</span></span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &gt; dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                p[i][j] = U;		<span class="comment">// 上</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                p[i][j] = L;	<span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[lenA][lenB];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印最长公共子序列，printLCS(lenA, lenB)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLCS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[i][j] == LU)</span><br><span class="line">    &#123;</span><br><span class="line">        printLCS(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p[i][j] == U)</span><br><span class="line">        printLCS(i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printLCS(i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h3><p>复杂度：$O(n^2)$</p>
<p>状态：<code>dp[i][j]</code>表示S[i]到S[j]是否是回文串，是为1，不是为2</p>
<p>状态转移方程：<br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210315152211196.png" alt="image-20210315152211196" style="zoom:80%;" /></p>
<ul>
<li>若<code>S[i]==S[j]</code>，则只要<code>S[i+1]</code>至<code>S[j-1]</code>是回文串，<code>S[i]</code>至<code>S[j]</code>就是，因此继承<code>dp[i+1][j-1]</code></li>
<li>若<code>S[i]!=S[j]</code>，肯定不是回文串，<code>dp[i][j]=0</code></li>
</ul>
<p>采用<strong>区间dp</strong>实现，即两层循环，外层枚举子串长度L，内层枚举初始位置（左端点）i，右端点=i+L-1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;	<span class="comment">// 最大长度</span></span><br><span class="line"><span class="comment">// 边界</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">    dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; len - <span class="number">1</span> &amp;&amp; S[i] == S[i+<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        ans = <span class="number">2</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">3</span>; L &lt;= len; L++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + L - <span class="number">1</span> &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + L - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == S[j] &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            ans = L;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>
<h3 id="DAG最长路"><a href="#DAG最长路" class="headerlink" title="DAG最长路"></a>DAG最长路</h3><p>也即求关键路径，两个问题：</p>
<ol>
<li>整个DAG中的最长路径</li>
<li>固定终点，求DAG的最长路径</li>
</ol>
<h4 id="整个DAG中的最长路径"><a href="#整个DAG中的最长路径" class="headerlink" title="整个DAG中的最长路径"></a>整个DAG中的最长路径</h4><p>状态：<code>dp[i]</code>表示从i号结点出发能获得的最长路径长度</p>
<p>状态转换方程：<code>dp[i] = max{dp[j] + length[i-&gt;j]} (i,j)∈E</code></p>
<ul>
<li>因为是用后继结点<code>j</code>更新结点<code>i</code>，使用递归，代替逆拓扑序列求解</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i] &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[i][j] != INF)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = DP(j) + G[i][j];</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; dp[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = temp;</span><br><span class="line">                pathNext[i] = j;	<span class="comment">// 记录后继结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">criticalPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化dp[i]=0, 结点后继为本身</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">        pathNext[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp计算最长路径</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (DP(i) &gt; ans)</span><br><span class="line">        &#123;</span><br><span class="line">           ans = dp[i]; 	<span class="comment">// 更新最长路径</span></span><br><span class="line">            s = i;		<span class="comment">// 起始点</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印路径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, s);</span><br><span class="line">    <span class="keyword">while</span> (pathNext[s] != s)</span><br><span class="line">    &#123;</span><br><span class="line">        s = pathNext[s];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-&gt;%d"</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码还自动实现了取字典序最小的路径（因为是按结点从小到大遍历）</p>
<h4 id="固定终点的DAG最长路径"><a href="#固定终点的DAG最长路径" class="headerlink" title="固定终点的DAG最长路径"></a>固定终点的DAG最长路径</h4><p>状态：<code>dp[i]</code>表示从<code>i</code>出发到终点T的最长路径长度</p>
<p>状态转移方程：<code>dp[i] = max{dp[j] + length[i-&gt;j]} (i,j)∈E</code></p>
<ul>
<li>与前一个问题的方程相同，区别在对边界的定义：初始化所有dp[i]=-INF来表达不可达，dp[T]=0</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i])	<span class="comment">// 已访问过才能取值</span></span><br><span class="line">        <span class="keyword">return</span> dp[i];</span><br><span class="line">    </span><br><span class="line">    vis[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[i][j] != INF)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = DP(j) + G[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">criticalPath</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化dp[i]=-INF, dp[T]=0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = -INF;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[T] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DP(S);		<span class="comment">// 返回从起点S到终点T的关键路径长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>path选择以及最小字典序方案和上一个问题相同</p>
<p>总结：</p>
<ul>
<li><strong>不规定终点的DAG关键路径</strong>，dp[i]=0有两层意思：<br>1）如果是出度为0的点，从它出发的关键路径长度为0<br>2）出度不为0的点，表示未更新dp[i]，因此进入邻接点的遍历</li>
<li><strong>规定终点的关键路径问题</strong>，不能初始化所有dp[i]=0，因为并非所有点都可达T，所以初始化未-INF，并利用vis数组记录dp[i]是否更新</li>
<li><p><strong>不关心起点</strong>，因为dp[i]已经具有这层意思。<br>对于规定起点S的问题，返回DP(S)即可，<br>对于未规定起点的问题，取dp[i]最大的结果返回</p>
</li>
<li><p>用DAG的思路解决矩形嵌套问题：每个矩形看成一个顶点，嵌套关系视为有向边，边权为1，于是就能转换为DAG最长路问题</p>
</li>
</ul>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>多阶段动态规划问题：:arrow_right:问题可以描述成若干有序阶段，每个阶段（多个状态）只与上个阶段的状态有关</p>
<p>01背包就是多阶段DP问题</p>
<h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>DP：$O(nV)$</p>
<p>n件物品，容量V的背包，每件物品重w[i]，价值c[i]，问如何选取物品使背包内物品总价值最大（每个物品1件）</p>
<ol>
<li><strong>状态与最优子结构</strong><br><code>dp[i][v]</code>表示选择前i项物品装入容量v的背包的最大价值<ul>
<li>不放第i件物品：<code>dp[i][v]=dp[i-1][v]</code></li>
<li>放第i件物品：<code>dp[i][v] = dp[i-1][v-w[i]]+c[i]</code></li>
</ul>
</li>
<li><p><strong>状态转移方程</strong><br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316082007789.png" alt="image-20210316082007789" style="zoom: 80%;" /></p>
</li>
<li><p><strong>自底向上</strong><br>边界<code>dp[0][v]=0</code>（0件物品放入任何背包容量的价值都为0）<br>枚举<code>i&lt;-1 to n</code>，<code>v&lt;-w[i] to V</code></p>
</li>
</ol>
<p>编码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = w[i]; v &lt;= V; v++)</span><br><span class="line">        dp[i][v] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][v], dp[i - <span class="number">1</span>][v - w[i]] + c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化空间复杂度：</p>
<p>上一阶段的状态，用于计算当前阶段的状态后，就不再使用，因此可以用滚动数组，化为一阶数组表示当前状态</p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316084246846.png" alt="image-20210316084246846"></p>
<p>注意，自底向上的遍历必须<strong>逆序</strong>，因为如果正序遍历，<code>dp[v]</code>使用的<code>dp[v-w[i]]</code>是<code>i-1</code>阶段的状态，会造成错误。逆序保证了计算第<code>i</code>阶段的状态时使用的都是<code>i-1</code>阶段的状态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = V; v &gt;=w[i]; v--)</span><br><span class="line">        dp[v] = <span class="built_in">max</span>(dp[v], dp[v-w[i]] + c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>如果能划分阶段，可以尝试将阶段作为状态，将数组<strong>降一维</strong></li>
<li>如果设计的状态不满足无后效性，可以尝试将状态<strong>升维</strong>（多个阶段，每个阶段多个状态）来表达相应信息</li>
</ul>
<h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><p>与01背包的区别在于，每个物品有无穷件（可选择多次）</p>
<ol>
<li><p><strong>状态与最优子结构</strong><br><code>dp[i][v]</code>表示选择前i项物品装入容量v的背包的最大价值</p>
<ul>
<li>不放第i件物品：<code>dp[i][v]=dp[i-1][v]</code></li>
<li>放第i件物品：<code>dp[i][v] = dp[i][v-w[i]]+c[i]</code><br>注意此处转移到了第<code>i</code>阶段而非<code>i-1</code>阶段，因为放了第i件物品后还可以继续放</li>
</ul>
</li>
<li><p><strong>状态转移方程</strong><br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316091304532.png" alt="image-20210316091304532" style="zoom:80%;" />|<br>优化版：<br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316091330893.png" alt="image-20210316091330893" style="zoom:80%;" /></p>
</li>
<li>自底向上<br>对于优化版：边界：初始化所有dp[v]为0（即表示<code>dp[0][v]=0</code>）<br><strong>正向</strong>枚举<code>v&lt;-w[i] to V</code>，因为求解<code>dp[i][v]</code>总是需要它左边的<code>dp[i][v-w[i]]</code>，而上方的<code>dp[i-1][v]</code>在计算完后才会覆盖<br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316091619664.png" alt="image-20210316091619664" style="zoom:80%;" /></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = w[i]; v &lt;= V; v++)</span><br><span class="line">        dp[v] = <span class="built_in">max</span>(dp[v], dp[v - w[i]] + c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>当题目与序列或字符串<code>A</code>有关时，可以考虑状态设计：<ol>
<li>令<code>dp[i]</code>表示以<code>A[i]</code>结尾（或开头）的xxx</li>
<li>令<code>dp[i]</code>表示以<code>A[i]</code>至<code>A[j]</code>区间的xxx</li>
</ol>
</li>
</ul>
<ul>
<li><p>当题目包含某种”方向“的意思时，状态需要几个维度来表示，对每一维用以下描述</p>
<ol>
<li>恰好为<code>i</code></li>
<li>前<code>i</code></li>
</ol>
<p>令<code>dp</code>数组表示恰好为<code>i</code>（或前<code>i</code>）的xxx</p>
</li>
</ul>
<p>大多数情况都可以把DP问题看作一个有向无环图（DAG），结点是状态，边是状态转移方向，辅助理解</p>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>给出两个字符串<code>text</code>和<code>pattern</code>，判断<code>pattern</code>是否是<code>text</code>的子串</p>
<p>暴力法枚举起始点$O(nm)$，使用KMP能达到$O(n+m)$</p>
<p>求解next数组</p>
<ul>
<li><p><code>next[i]</code>定义：<br>使子串<code>s[0...i]</code>的前缀<code>s[0...k]</code>和后缀<code>s[i-k...i]</code>相等的<strong>最大的k</strong>（前后缀长度为k+1），也即最长相等前后缀的<strong>前缀最后一位的下标</strong></p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316125810982.png" alt="image-20210316125810982" style="zoom: 80%;" /><br>上框下划线画出匹配的前后缀，下框的第一行为前缀，第二行为后缀</p>
</li>
<li><p><strong>递推求解next[i]</strong>：<br>令<code>j=next[i-1]</code></p>
<ul>
<li><p>若<code>s[i] == s[j+1]</code>，最长相等前后缀可以扩展，长度+1，即<code>next[i]=j+1</code></p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316125722792.png" alt="image-20210316125722792"></p>
</li>
<li><p>若<code>s[i] != s[j+1]</code>，前后缀匹配失败，相等前后缀无法达到那么长，因此需要缩短一点。需要找出一个<code>j&#39;</code>，使得</p>
<ul>
<li>1） <code>s[i] == s[j&#39;+1]</code>成立</li>
<li>2） <code>s[0...j&#39;]</code>（下图3的~）是<code>s[i-j-1...i-1]</code>（下图3和~在一个框的上方的子串）的<strong>后缀</strong><br>因为<code>s[i-j-1..i-1] == s[0..j]</code>（由<code>j=next[i-1]</code>的意义决定，<code>j</code>是<code>s[0..i-1]</code>的最长前后缀匹配的前缀最后一位下标），所以只需满足<strong><code>s[0..j&#39;]</code>是<code>s[0..j]</code>的后缀</strong><br>从下面图片来理解就是：j=next[4]=2，需要找一个串<code>s[0..j&#39;]</code>，使得它是<code>s[2..4]=&quot;aba&quot;</code>的后缀（这样才能匹配成功），因为<code>s[2..4] == s[0..2]</code>（因为<code>next[4]=2</code>），所以也即<code>s[0..j&#39;]</code>需满足是<code>s[0..2]</code>后缀</li>
<li>3） <strong><code>s[0...j&#39;]</code>是<code>s[0...j]</code>的前缀</strong>（自动满足，因为是在<code>0..j</code>里找<code>j&#39;</code>）</li>
<li>4）<code>j&#39;</code>尽可能大</li>
</ul>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316131651669.png" alt="image-20210316131651669" style="zoom: 67%;" /></p>
<p>上面的要求2）3）4），正好就是<code>next[j]</code>的定义：<code>s[0..j]</code>最长相等前后缀的前缀下标<code>j&#39;</code>，因此只需让<strong><code>j&#39;=next[j]</code></strong>，判断<code>s[i]==s[j&#39;+1]</code>是否成立，不成立继续回退，直到<code>j&#39;=-1</code><br><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316133601904.png" alt="image-20210316133601904" style="zoom: 67%;" /></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求解长度为len的字符串s的next数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 1. 让i在1~len-1范围内遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2.不断令j=next[j]，直到j回退到-1，或满足s[i]==s[i+1]</span></span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; s[i] != s[j+<span class="number">1</span>])</span><br><span class="line">            j = next[j];</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 3. 若s[i]==s[j+1]，则next[i]=j+1，否则next[i]=j</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j+<span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>KMP算法</p>
<p>令i指向text的欲比较位，j指向pattern已被比较的最后一位</p>
<ul>
<li><p>若<code>text[i] == pattern[j+1]</code>，说明匹配成功，i、j自增，继续比较</p>
</li>
<li><p>若<code>text[i] != pattern[j+1]</code>，匹配失败，需要考虑<code>j</code>回退到哪，位置要满足以下条件：</p>
<ul>
<li>1）<code>text[i] == pattern[j&#39; + 1]</code>成立</li>
<li>2）<code>pattern[0..j&#39;]</code>仍然与<code>text</code>相应位置处于匹配状态，即<code>pattern[0..j&#39;]</code>是<code>text[i-1-j..i-1]</code>的后缀，由于之前匹配的结果有<code>text[i-1-j..i-1] == pattern[0..j]</code>，因此只需满足<strong><code>pattern[0..j&#39;]</code>是<code>pattern[0..j]</code>的后缀</strong></li>
<li>3）<code>pattern[0..j&#39;]</code>是<code>pattern[0..j]</code>的前缀（自动满足，因为是回退）</li>
<li>4）<code>j&#39;</code>尽可能大</li>
</ul>
<p>条件2）3）4）正是数组<code>next[j]</code>的定义，因此只需不断令<code>j&#39;=next[j]</code>，直到满足条件1）或<code>j&#39;=-1</code>为止。（逻辑与<code>next</code>数组的求解几乎一致）</p>
<p>从这个角度来看，<code>next</code>数组的含义就是当<code>j+1</code>位失配时，<code>j</code>应该回到的位置</p>
</li>
</ul>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316141313149.png" alt="image-20210316141313149" style="zoom:80%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> <span class="built_in">text</span>[], <span class="keyword">char</span> pattern[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(<span class="built_in">text</span>), m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    getNext(pattern, m);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 1. 遍历文本串text</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2. 不断令j=next[j]，直到j回退到-1，或text[i]==pattern[j+1]为止</span></span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; <span class="built_in">text</span>[i] != pattern[j+<span class="number">1</span>])</span><br><span class="line">            j = next[j];</span><br><span class="line">        <span class="comment">// 3. 若匹配，往前一位</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">text</span>[i] == pattern[j+<span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="comment">// 4. 若j达到pattern尾，说明是子串</span></span><br><span class="line">        <span class="keyword">if</span> (j == m - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>统计文本串<code>text</code>中<code>pattern</code>的出现次数（不是子串个数，如text=”ababab”中，pattern=”abab”出现了2次）</p>
<p>思路：</p>
<p>完全匹配一次pattern后，<code>j</code>需回退一定距离，使得不漏解且效率最高。由于<code>next[j]</code>的定义是最长前后缀匹配的前缀最后一位，完全匹配时<code>text[i-j..i] == pattern[0..j], j=m-1</code>，所以<strong>令<code>j=next[j]</code></strong>，在<code>next[j]</code>之前的位置都已完成匹配，省去了许多无意义的比较</p>
<p><img src="https://gitee.com/kingkongk/ImgBed/raw/master/img/image-20210316141352442.png" alt="image-20210316141352442" style="zoom:80%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> <span class="built_in">text</span>[], <span class="keyword">char</span> pattern[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(<span class="built_in">text</span>), m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    getNext(pattern, m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>; ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; <span class="built_in">text</span>[i] != pattern[j+<span class="number">1</span>])</span><br><span class="line">            j = next[j];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">text</span>[i] == pattern[j+<span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (j == m - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            j = next[j];	<span class="comment">// 关键一步</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结</p>
<ul>
<li>计算<code>next</code>数组实际上是<code>pattern</code>自我匹配的过程</li>
<li>KMP的关键是<code>j</code>回退的位置<code>j=next[j]</code>，实质就是回到一个已知匹配的长度，从而省去从头开始比较的开销。容易模糊的地方是如何证明这个回去的位置是有效而且最优的，可以多看看上面的解释，思路就是递推求解代替逐项匹配</li>
<li>$O(n+m)$的开销：i和j的变化是$O(n)$的，计算next数组的开销是$O(m)$</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="中缀表达式计算"><a href="#中缀表达式计算" class="headerlink" title="中缀表达式计算"></a>中缀表达式计算</h3><p>1）中缀转换为逆波兰（后缀表达式）：</p>
<p>（使用队列存储）</p>
<ol>
<li><p>如果是数字，直接入队</p>
</li>
<li><p>如果是运算符op：如果运算符栈空，压入运算符栈，否则与栈顶比较优先级（用<code>map</code>记录优先级）：<br><strong>只有在遇到” ) “的情况下我们才弹出” ( “，其他情况我们都不会弹出” ( “</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(栈非空 &amp;&amp; 栈顶 != <span class="string">'('</span> &amp;&amp; op小于或等于栈顶)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 栈顶入队</span></span><br><span class="line">    <span class="comment">// 弹栈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 表达式中的op压栈</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果遇到一个右括号，则将栈元素弹出（入队），将弹出的操作符输出直到遇到左括号为止。<strong>注意，左括号只弹出并不输出。</strong></p>
</li>
<li><p>表达式扫描结束后，若运算符栈非空，从栈顶依次入队</p>
</li>
</ol>
<hr>
<p>2）逆波兰表达式运算：</p>
<p>（由队首依次出队）</p>
<ol>
<li>如果是数字，压栈</li>
<li>如果是运算符，取栈顶两个数字，运算，将结果压栈</li>
<li>队列扫描结束后，栈顶数字即最终结果</li>
</ol>
<hr>
<p>3）中缀表达式直接计算：<br>（使用数字栈和运算符栈）</p>
<ol>
<li>如果是数字，压栈</li>
<li>如果是运算符，同1），不过弹栈时，取数字栈顶两个元素运算后压栈，而非入队</li>
<li>同1），弹栈时运算而非入队</li>
</ol>
<h3 id="C语言变长参数函数写法"><a href="#C语言变长参数函数写法" class="headerlink" title="C语言变长参数函数写法"></a>C语言变长参数函数写法</h3><p>使用头文件<strong><code>&lt;stdarg.h&gt;</code></strong>实现，下面为用到的四个宏：</p>
<ul>
<li><code>va_list</code>：声明指向变长参数的指针ap</li>
<li><code>va_start(ap, arg)</code>：用于初始化变长参数指针ap的位置，arg为最后一个固定参数</li>
<li><code>va_arg(ap, type)</code>：ap传入变长参数指针，type为参数类型。函数返回ap当前指向的类型为type的参数，并将ap指向参数列表的下一个参数</li>
<li><code>va_end(ap)</code>：置ap为空指针</li>
</ul>
<p>变长参数函数的参数中，先填写若干个固定参数，然后在最后一个固定参数的逗号后方添加3个点，表示变长参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	va_list ap;</span><br><span class="line">	va_start(ap, num);</span><br><span class="line">	<span class="keyword">char</span>* str;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		str = va_arg(ap, <span class="keyword">char</span>*);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">	&#125;</span><br><span class="line">	va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	test(<span class="number">3</span>, <span class="string">"hello"</span>, <span class="string">"fxxking"</span>, <span class="string">"world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Debug思路"><a href="#Debug思路" class="headerlink" title="Debug思路"></a>Debug思路</h2><ul>
<li>注意考虑<strong>边界情况</strong>，如0、有质数的题考虑1</li>
<li>没有编码错误的情况下，找<strong>逻辑错误</strong>（代码是否和题目逻辑一致），着重检查循环里的数组下标<code>i,j,k</code></li>
<li>注意浮点数精度：<code>float</code>能保证6位，<code>double</code>能保证到15位。有时float错了可能double能过</li>
<li>可能没有考虑多组输入</li>
<li>格式问题，有些题目可能输出点个数为0时需<strong>输出空行</strong></li>
<li>无法调试可能的原因：<ul>
<li>内存爆了，减小<strong>MAXN</strong></li>
<li>添加查看了<strong>STL容器</strong></li>
</ul>
</li>
<li>声明<code>const char []</code>型数据时，一定要检查后面<strong>有没有添加<code>&#39;\0&#39;</code></strong>，否则可能会出现本地没问题但交上去WA的情况。比如：<code>const char ONE[2] = {&#39;1&#39;, &#39;\0&#39;};</code>能过，但<code>const char ONE[1] = {&#39;1&#39;};</code>在Linux环境下会出现怪数，但windows下结果正常</li>
<li>同阶<strong>时间复杂度</strong>的算法，实际表现可能有很大差异。比如<code>O(nlogn)</code>和<code>O(2nlog(2n))</code>。当RE时，可能其他同阶算法能过</li>
<li>sort的<strong>cmp函数</strong>中如果使用<code>return a &gt;= b</code>可能会有段错误（原因不明），改用<code>return a &gt; b</code>，不影响语义</li>
<li>多组输入，记得对每个用到的数据结构进行<strong>初始化</strong></li>
</ul>
<h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><ul>
<li><p>字符转数字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	num = num * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意先找规律，n很大的不要一上来就递归DP，很容易超时。有时可能往简单想能做出来</p>
</li>
<li><p>int的范围[-2147483648, 2147483647]，10个0就无法支持了，一般取INF=1e9</p>
</li>
<li><p><code>ceil()</code>：向上取整；<code>floor()</code>：向下取整；<code>round()</code>：四舍五入；三者都返回<code>double</code>值</p>
</li>
<li><p>万能库：<code>include &lt;bits/stdc++.h&gt;</code></p>
</li>
<li><p><code>long</code>和<code>int</code>都是4字节，<code>long long</code>才是8字节</p>
</li>
<li><p>21！就超过了<code>long long</code>的范围</p>
</li>
<li><p><code>cin</code>和<code>cout</code><strong>远比</strong><code>scanf</code>和<code>printf</code>花费时间多，能不用尽量不用</p>
</li>
<li><p>运行时限为1s，算法复杂度不能超过百万级，也即不能超过一千万<br>比如$O(n^2)$，n应&lt;=3000</p>
</li>
<li><p><code>cin</code>的多组输入：<code>while(cin &gt;&gt; x)</code>，<code>cin</code>在读入EOF时返回0</p>
</li>
<li><p>浮点数比较，在经过大量计算后应考虑误差</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span></span><br><span class="line">#define Equ(a, b) (<span class="built_in">fabs</span>((a)-(b))&lt;(eps))</span><br></pre></td></tr></table></figure>
<p>大于、小于、大于等于，以及sqrt、asin、cos等也需要考虑</p>
</li>
<li><p>C的空指针为<code>NULL</code>，c++11引入<code>nullptr</code></p>
</li>
<li><p><code>scanf(&quot;%c&quot;)</code>会可以读入空格，需要考虑</p>
</li>
<li><p>下标的计算（i、j的加加减减之类的）从实体加减考虑，不要考虑加减位置</p>
</li>
<li><p>C语言中整型最大值和最小值的宏</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, INT_MAX);	<span class="comment">//2147483647</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, INT_MIN);	<span class="comment">//-2147483648</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>命令行输入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[ ])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;argc; i++)</span><br><span class="line">    	<span class="built_in">printf</span>(“%s%c”, argv[i], (i&lt; argc<span class="number">-1</span>)? <span class="string">' '</span>: <span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>ettercap+driftnet抓取同一无线网段中设备阅览的图片</title>
    <url>/2020/04/13/arp%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>OS：Ubuntu 16.04LTS</p>
<p>软件：ettercap, driftnet</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> install ettercap-graphical </span><br><span class="line">$ sudo apt-<span class="builtin-name">get</span> install driftnet</span><br></pre></td></tr></table></figure>
<p>ps：使用虚拟机vmware+kali体验更好</p>
<h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><ol>
<li><code>$sudo ettercap -G</code>打开ettercap图形化界面</li>
<li>Sniff-&gt;Unified sniffing-&gt;wlp2s0（无线网卡）</li>
<li>Host-&gt;scan for hosts，扫描连接在同一网段上的设备</li>
<li>设备IP地址Add to Target 1；路由器IP（通常是最后一位为1）Add to Target 2（注意不要反了，否则可能导致宽带认证错误，上不了网，只能打电话找运营商清除一下之前的缓存）</li>
<li>Mitm（中间人攻击）-&gt;Arp poisoning-&gt;Sniff remote connections-&gt;ok，至此，设备与路由器的通信会经过本主机，因此可以截获报文</li>
<li>Start-&gt;Start sniffing开始监听，View-&gt;View Connections查看截获的报文</li>
</ol>
<h2 id="图片监视"><a href="#图片监视" class="headerlink" title="图片监视"></a>图片监视</h2><p>监听无线网卡：<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo driftnet -i wlp2s0</span><br></pre></td></tr></table></figure><br>会弹出一个图片预览框，截取设备访问的图片</p>
<p>driftnet其他参数：</p>
<ul>
<li>-i 监听网卡</li>
<li>-b 声音提醒</li>
<li>-a 保存图片（这样的话图片不会显示在窗口）</li>
<li>-d 图片保存目录，例：driftnet -i wlan0 -b -a -d /pic </li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过本人的实验，可以抓取到微信朋友圈的视频帧、图片（很少），以及公众号中浏览的一些图片，原因可能是大部分图片还是经过加密传输的。但即使如此，还是见识到了连接在同一wifi上造成的信息泄露。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/zero9988/article/details/51866882?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2" target="_blank" rel="noopener">Wifi密码破解与局域网抓包监听（小白—纯工具版）</a></li>
<li><a href="https://blog.csdn.net/ghl1390490928/article/details/81460158" target="_blank" rel="noopener">NO.26——利用ettercap和driftnet截获数据流里的图片</a></li>
<li><a href="https://blog.csdn.net/u011500307/article/details/21736099" target="_blank" rel="noopener">ettercap与driftnet来实现中间人攻击</a></li>
</ul>
]]></content>
      <categories>
        <category>网安</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 820.单词的压缩编码</title>
    <url>/2020/03/30/leetcode_m_62/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="assets/md-2020-03-30-14-18-36.png" alt=""></p>
<p>约瑟夫环问题</p>
<h2 id="标准做法-递归-O-n"><a href="#标准做法-递归-O-n" class="headerlink" title="标准做法 递归 $O(n)$"></a>标准做法 递归 $O(n)$</h2><p>由于问题是求0到n-1里最后剩下的数字，所以问题也可以转换为安全数字的序号。对问题建模，令<code>f(n, m)</code>为问题的答案，即最终安全位置的序号。最开始，我们要删除的是第<code>m%n</code>个元素，之后，序列长度变为n-1，然后从第<code>m%n</code>位开始往后数。剩下的n-1长度的序列从第<code>m%n</code>位开始，只要往后数<code>f(n-1, m)</code>位就能达到安全位置，所以<code>(m%n+f(n-1,m))%n</code>即为所求。<code>(m%n+f(n-1,m))%n = (m+f(n-1, m)%n</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = f(n - <span class="number">1</span>, m);</span><br><span class="line">        <span class="keyword">return</span> (m + x) % n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(n, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="标准做法-迭代-DP-O-n"><a href="#标准做法-迭代-DP-O-n" class="headerlink" title="标准做法 迭代/DP $O(n)$"></a>标准做法 迭代/DP $O(n)$</h2><p>由上面的递归式，就可以得到DP所需的状态转移方程</p>
<script type="math/tex; mode=display">f_i = (m + f_{i-1})\%i</script><p>只有一个状态转换量，所以可以用简单变量替代</p>
<p>在<code>i=1</code>时，也就是长度为1的序列，安全位置就是0，即<code>f1 = 0</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i != n + <span class="number">1</span>; ++i)</span><br><span class="line">            f = (m + f) % i;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>模拟约瑟夫环的删除过程会超时</li>
<li>这种类似归纳法解决问题的逻辑很巧妙，希望能掌握下来</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/</a></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 820.单词的压缩编码</title>
    <url>/2020/03/28/leetcode_820/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://ftp.bmp.ovh/imgs/2020/03/8f129c0f84044b45.png" alt=""></p>
<a id="more"></a>
<h2 id="标准解法-字典树Trie-O-Sigma-wi"><a href="#标准解法-字典树Trie-O-Sigma-wi" class="headerlink" title="标准解法 字典树Trie $O(\Sigma wi)$"></a>标准解法 字典树Trie $O(\Sigma wi)$</h2><p>本题的核心就是如何找到<strong>是其他单词后缀的</strong>单词并删去。利用字典树，反向插入单词。这样后缀相同的单词在同一棵子树中，巧妙地过滤了需要删去的单词。最后只需要统计叶子所有叶子节点的高度，即为所求。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line">    TrieNode* children[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) children[i] = <span class="literal">NULL</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TrieNode* <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (children[c - <span class="string">'a'</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            children[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> children[c - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        TrieNode* trie = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;TrieNode*, <span class="keyword">int</span>&gt; nodes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)words.size(); ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> word = words[i];</span><br><span class="line">            TrieNode* cur = trie;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = word.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">                cur = cur-&gt;get(word[j]);</span><br><span class="line">            nodes[cur] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [node, idx] : nodes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">                ans += words[idx].length() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="个人解法-暴力"><a href="#个人解法-暴力" class="headerlink" title="个人解法 暴力"></a>个人解法 暴力</h2><p>按照题意填充<code>#</code>并查找判断。其中<code>find</code>的开销最大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.length() &gt; s2.length();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> zipstr = <span class="string">""</span>;</span><br><span class="line">        sort(words.begin(), words.end(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : words)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (zipstr.find(str + <span class="string">"#"</span>) == zipstr.npos)</span><br><span class="line">            &#123;</span><br><span class="line">                zipstr += str + <span class="string">"#"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; zipstr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> zipstr.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>可以用<code>auto&amp; [key, value]</code>来遍历<code>map</code>中的<code>pair</code>，很简洁的写法</li>
<li>尽量别一想到暴力就用，往深考虑更优的解法。同时记住一些通用的解法，比如这次的字典树。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 面试题 17.16. 按摩师</title>
    <url>/2020/03/26/leetcode_m_17_16/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://i.loli.net/2020/03/26/pVyUuftcH3iorGl.png" alt="image.png"></p>
<a id="more"></a>
<h2 id="标准解答-DP-O-n"><a href="#标准解答-DP-O-n" class="headerlink" title="标准解答 DP $O(n)$"></a>标准解答 DP $O(n)$</h2><p>01背包的思路，状态转移方程如下（dp[i][0/1]表示第i个预约选或不选得到的最长预约时间）</p>
<p>$dp[i][0] = max(dp[i-1][0], dp[i-1][1])$，即不选第i个预约的总时间为第i-1个预约选或不选的最大值</p>
<p>$dp[i][1] = dp[i-1][0] + nums[i]$，选第i个预约，则无法选择第i-1个</p>
<p>计算$dp[i][0/1]$时，只与前一个状态$dp[i-1][0/1]$有关，所以可以不用数组，而使用两个临时变量，通过状态转移计算，减小开销。（这个做法很巧妙）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp0 = <span class="number">0</span>, dp1 = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmpDp0 = max(dp0, dp1); <span class="comment">// dp0: dp[i-1][0], dp1: dp[i-1][1]</span></span><br><span class="line">            <span class="keyword">int</span> tmpDp1 = dp0 + nums[i];</span><br><span class="line"></span><br><span class="line">            dp0 = tmpDp0;   <span class="comment">// dp0: dp[i][0], dp1: dp[i][1]</span></span><br><span class="line">            dp1 = tmpDp1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(dp0, dp1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="网友的另一种dp思路"><a href="#网友的另一种dp思路" class="headerlink" title="网友的另一种dp思路"></a>网友的另一种dp思路</h2><p>状态转移方程：</p>
<p>$dp[i] = max(dp[i-2]+nums[i], dp[i-1])$，$dp[i]$为从0到i总共能取到的最长预约时间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(size, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]; <span class="comment">//dp[i] 表示nums[0...i] 能得到的最长时间</span></span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历迄今为止的最大值，两种情况取较大：</span></span><br><span class="line">            <span class="comment">//1：预约本次，则上一次不预约（dp[i-2] + nums[i]）</span></span><br><span class="line">            <span class="comment">//2：本次不预约，则值为预约到上一次的最大值</span></span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>] + nums[i], dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[size <span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="个人解法1-递归-超时"><a href="#个人解法1-递归-超时" class="headerlink" title="个人解法1 递归 超时"></a>个人解法1 递归 超时</h2><p>起初发现的规律是，在第i个位置时，由于i+1不能选，考虑走i+2或i+3，两种走法取最大值，是一种比较暴力的做法，但最终超时了，因为重复计算的子问题太多了（比如go(0,num)算过一次go(0+3, num)，go(1,num)又要再算一遍go(1+2, num)）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max(go(<span class="number">0</span>, nums), go(<span class="number">1</span>, nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= num.size()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num[pos] + max(go(pos + <span class="number">2</span>, num), go(pos + <span class="number">3</span>, num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="个人解法2-从尾DP"><a href="#个人解法2-从尾DP" class="headerlink" title="个人解法2 从尾DP"></a>个人解法2 从尾DP</h2><p>这是顺从递归的思路进而产生的DP，感觉思维还是不太精炼，没有dp内味。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            m[i] = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">3</span> &gt;= n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">2</span> &lt; n)</span><br><span class="line">                &#123;</span><br><span class="line">                    m[i] += m[i+<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m[i] += max(m[i+<span class="number">2</span>], m[i+<span class="number">3</span>]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(m[<span class="number">0</span>], m[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>选/不选的问题很容易归类到01背包类似的问题上去，没必要蛮力找规律再编码</li>
<li>边界问题考虑清楚</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/problems/the-masseuse-lcci/solution/an-mo-shi-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客作业-软件案例分析</title>
    <url>/2020/03/23/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BD%9C%E4%B8%9A-%E8%BD%AF%E4%BB%B6%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>本作业属于北航 2020 年春软件工程</td>
<td><a href="https://edu.cnblogs.com/campus/buaa/BUAA_SE_2019_LJ" target="_blank" rel="noopener">博客园班级连接</a></td>
</tr>
<tr>
<td>本作业是本课程个人项目作业</td>
<td><a href="https://edu.cnblogs.com/campus/buaa/BUAA_SE_2020_LJ/homework/10481" target="_blank" rel="noopener">作业要求</a></td>
</tr>
<tr>
<td>我在这个课程的目标是</td>
<td>提高软件开发能力、团队协作能力</td>
</tr>
<tr>
<td>这个作业在哪个具体方面帮助我实现目标</td>
<td>提高软件分析能力</td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<h2 id="第一部分-调研"><a href="#第一部分-调研" class="headerlink" title="第一部分 调研"></a>第一部分 调研</h2><h3 id="1-VS-VSCode简介"><a href="#1-VS-VSCode简介" class="headerlink" title="1 VS/VSCode简介"></a>1 VS/VSCode简介</h3><blockquote>
<p>微软公司有两个代码编辑器：Visual Studio、VS Code，它们的目标用户，主要功能有何不同？为何要有两个编辑器和开发环境？</p>
</blockquote>
<p>　　从本人角度去看，Visual Studio能够为编程人员提供一套完整的语言环境，包括编码、测试、代码分析和度量以及发布，软件开发的一套流程都可以在这款软件上实现，我认为它的目标用户应该是开发项目级软件的团队或个人。此外，Community，Professional和Enterprise三种版本也适应了不同群体的需要。下面是从<a href="https://visualstudio.microsoft.com/downloads/" target="_blank" rel="noopener">官网</a>截下的三种版本简介：</p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/03/d451d9d24d5d3c99.png" alt=""></p>
<p>　　VS Code则是一个轻量级、跨平台、可个性化拓展的开发工具。最广受褒奖的是VS Code的开源插件，这些插件很好地满足了个性化的需求，比如编写Markdown文档可以安装“Markdown ALL in One”插件，编写python脚本可以安装“python”插件以及其他辅助插件等等。此外，内置的git也让版本管理变得十分方便。我认为它面向的用户应该是轻量级开发的小团队和个人编程爱好者。下面是<a href="https://visualstudio.microsoft.com/downloads/" target="_blank" rel="noopener">官网</a>的软件简介：</p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/03/9d324858000003a6.png" alt=""></p>
<p>　　两个编译器的存在是为了满足不同人群的不同开发需要。举例来说，如果想要利用WPF框架开发window界面程序（本次<a href="https://edu.cnblogs.com/campus/buaa/BUAA_SE_2020_LJ/homework/10466" target="_blank" rel="noopener">结对项目作业</a>），在VS Code中不知从何处下手，需要十分费劲地搜索开发的环境依赖与插件、可用的模板等，而使用Visual Studio可以很轻松地创建一个WPF应用项目，直接就能够进行开发；但如果只是想要调试一份C++算法题的程序呢？VS Code中只要有“C/C++”插件，创建一个新的.cpp文件即可开始编码，而Visual Studio需要经历“新建项目-&gt;解决方案-&gt;源代码-&gt;新建项”，才可以开始编码，步骤繁琐的同时还会带来许多冗余文件。</p>
<h3 id="2-软件体验"><a href="#2-软件体验" class="headerlink" title="2 软件体验"></a>2 软件体验</h3><blockquote>
<p>使用10–30分钟这个软件的基本功能（请上传使用软件的照片）描述使用这个产品的过程，解决了用户的问题么？软件在数据量/界面/功能/准确度上各有什么优缺点？用户体验方面有问题么？对产品有什么改进意见？</p>
</blockquote>
<ol>
<li><p>使用Visual studio 2019 Community进行WPF应用开发</p>
<p> <img src="https://ftp.bmp.ovh/imgs/2020/03/8b9fb078e6c078fb.png" alt=""></p>
<p> 　　在使用Visual Studio进行开发的过程中，直观体验是十分顺手，更具体的描述是：代码补全完善、调试功能齐全、项目管理清晰、界面美观大方、各种工具应有尽有。当遇到错误、警告时，可以快速定位到有问题的代码行，并提供完善的官方文档解答，非常人性化。</p>
<p> <img src="https://ftp.bmp.ovh/imgs/2020/03/701d0c96fb8dd540.png" alt=""></p>
<p> 　　其中存在一点界面上的不足是，解决方案资源管理器作为项目管理最重要的栏目，个人直觉是点击关闭后会停靠在侧栏，再次点击还能够弹出。而Visual Studio中的处理是直接关闭，没有提示，不熟悉的用户还需要到上方工具栏中逐一寻找才能在“视图”中找到并还原，体验不是很好。虽然资源管理器上有“自动隐藏”按钮，但是点击后又会带来尺寸的变化，且只要不操作就会自动隐藏也会带来重复的点击操作。</p>
<p> <img src="https://i.bmp.ovh/imgs/2020/03/f0b46e3e30db49e0.png" alt=""></p>
<p> 　　（还有一个建议是，希望能少吃一点C盘空间。</p>
</li>
<li><p>使用VS Code进行C++编程</p>
<p> 　　编写C++程序时有内置代码高亮，如果缺少相关插件VS Code还会给予提醒，只需傻瓜式点击即可安装。编码完成后，使用快捷键<code>Ctrl+Alt+N</code>即可编译运行。此外，为了展现VS Code插件的优越性，本人还展示了<a href="https://zhuanlan.zhihu.com/p/63303926" target="_blank" rel="noopener"><code>Todo Tree</code>插件的使用</a>。通过<code>Todo Tree</code>，可以很直观地展示程序中未完成、待修改以及其他标注事项。</p>
<p> <img src="https://i.bmp.ovh/imgs/2020/03/7b9083f80ba9c9e3.png" alt=""></p>
<p> 　　此外，内置的git也可以很直观地展示版本差异</p>
<p> <img src="https://i.bmp.ovh/imgs/2020/03/081c2b009865108f.png" alt=""></p>
<p> 　　总之，VS Code的使用体验非常棒，这也是得到业界认可的。无论是代码高亮、界面设计、还是开源插件，都很好地满足了轻量级开发的需要。美中不足的一点是，代码补全和查错的反应速度有点慢，有时已经修改好的错误，在对应代码行的红色波浪线还是会停留一会。建议对代码补全和查错这两个功能进行性能优化优化（如果是插件的影响，也可以通过官方渠道将主要编程语言的开源插件收录并进行优化）。</p>
</li>
</ol>
<h3 id="3-功能性bug"><a href="#3-功能性bug" class="headerlink" title="3 功能性bug"></a>3 功能性bug</h3><blockquote>
<p>按照描述的bug定义，找出至少2个功能性bug。用专业的语言描述(每个bug不少于40字)</p>
</blockquote>
<ol>
<li><p>Visual Studio中CPU使用率的bug</p>
<p> 　　在使用性能探查器的CPU使用率分析功能对程序进行分析时，CPU使用百分比能正常显示，但各个函数的CPU使用率详细分析结果无法显示，取而代之的是出现“在所选时间范围内没有代码运行”字样，没有任何错误或警告提示（经测试，该bug与程序无关，且重装或修复Visual Studio无法解决）。</p>
<p> <img src="https://ftp.bmp.ovh/imgs/2020/03/423cb2a11f1f635a.png" alt=""></p>
</li>
<li><p>Visual搜索栏不显示下划线bug</p>
<p> 　　在代码编辑界面使用<code>Ctrl+F</code>打开搜索界面，输入带有下划线的名称进行搜索，在搜索框中不显示下划线，但能够匹配对应的段落。</p>
<p> <img src="https://ftp.bmp.ovh/imgs/2020/03/2e96b583e2df0566.png" alt=""></p>
</li>
</ol>
<h3 id="4-评价"><a href="#4-评价" class="headerlink" title="4 评价"></a>4 评价</h3><blockquote>
<p>经过这么多工作，你一定有充分的理由给这个软件下一个评价.请选择一个结论。除了定性的结论，是否能有定量的结论（就像最近比较时髦的手机评测那样，跑个分），如何定量地评价一个软件？</p>
</blockquote>
<p>经过调研工作后，我的总体评价是：</p>
<ul>
<li>VisualStudio： d）好，不错</li>
<li>VS Code：   e）非常推荐</li>
</ul>
<p>定量评价：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>Visual Studio</th>
<th>VS Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能</td>
<td>核心功能</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td></td>
<td>细节</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td>用户体验</td>
<td>7</td>
<td>9</td>
</tr>
<tr>
<td></td>
<td>辅助功能</td>
<td>8</td>
<td>10</td>
</tr>
<tr>
<td></td>
<td>差异化功能</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td>软件效能</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>体验</td>
<td>软件适应性</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td></td>
<td>成长性</td>
<td>9</td>
<td>7</td>
</tr>
<tr>
<td></td>
<td>用户有控制权</td>
<td>10</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第二部分-分析"><a href="#第二部分-分析" class="headerlink" title="第二部分 分析"></a>第二部分 分析</h2><blockquote>
<p>使用此服务的所有功能，估计这个软件/网站/服务做到这个程度大约需要多少时间(团队人数6人左右，计算机大学毕业生，并有专业UI支持)。（必答）     </p>
</blockquote>
<p>　　对于Visual Studio这个迭代了20余年的IDE老怪物来说，团队6个人开发到支持其所有功能的程度难于登天。首先需要完成基本编辑器的核心功能，支持代码编辑、项目管理等基础功能；然后需要完成对各语言环境的支持，如C++，.Net桌面开发等等，并完成项目编译、调试、测试等基本开发功能；之后是辅助工具诸如代码分析、性能分析以及插件实现。综合这些工作应该需要3-5年甚至更长的时间开发。</p>
<p>　　VS Code已经<a href="https://github.com/Microsoft/vscode" target="_blank" rel="noopener">开源</a>，理论上完成时间与网速相关（/狗头）。拥有开源项目的指导，VS Code的开发速度应该能加快速度，估计开发时间在1年左右。但是数以万计的开源插件的开发就是不可衡量的了，还需要依靠热心网友的支持，或者对现有插件做移植。</p>
<blockquote>
<p>分析这个软件目前的优劣(和类似软件相比)，这个产品的质量在同类产品中估计名列第几？（必答）</p>
</blockquote>
<p>网上查到的<a href="https://pypl.github.io/IDE.html" target="_blank" rel="noopener">排名信息</a>如下：</p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/03/ddb247743cb236ce.png" alt=""></p>
<p>　　可以看到，VS高居榜首，VS Code也在大步向前。</p>
<blockquote>
<p>从各方面的问题，推理出这个软件团队在软件工程方面可以提高的一个重要方面(具体建议)。</p>
</blockquote>
<p>　　Visual Studio为开发者准备的功能十分齐全，但也有不少身边的用户反映：看着C盘被占用的空间心在滴血，最后在某些课程项目完成后，为了缓解C盘空间而卸载VS。所以，我认为可以在储存空间方面进行提高，适当地将一些功能作为可选项，或是删除、压缩某些功能，减小系统盘的占用量。</p>
<blockquote>
<p>你在第一部分发现的bug，为何软件团队不能在发布前修复？他们是不知道，还是有意不修复？你觉得是什么原因？</p>
</blockquote>
<p>　　对于CPU使用率的Bug，在微软开发者社区中的问题由于信息不足已被关闭。</p>
<p><img src="https://i.loli.net/2020/03/23/RQcDVFy14t7sgNo.png" alt="2020-03-23-14-58-23.png"></p>
<p>　　在询问结对伙伴这个问题后，他找到的解答是：“开发者员工称这个问题是Windows的问题，大概是1903版本破坏了VS一直使用的ETW profiling功能”。</p>
<p><img src="https://i.loli.net/2020/03/23/FDkEvYGwirmzVH4.png" alt="2020-03-23-15-11-40.png"></p>
<p>　　对于搜索栏无法显示下划线的Bug，我在开发者社区或其他网站上都没有看到类似问题，猜测可能是问题出现范围小，开发者没有注意到，所以我向开发者社区报告了这一问题</p>
<p><img src="https://i.loli.net/2020/03/23/R4qcNXM9H8VKmQT.png" alt="2020-03-23-15-52-34.png"></p>
<p>-----------------（2020.3.24更新）</p>
<p>开发者社区的回复速度也太快了，真的很用心。经过VS installer的修复之后，问题被解决了。</p>
<p><img src="https://i.bmp.ovh/imgs/2020/03/ca31af4f198d07e3.png" alt=""></p>
<h2 id="第三部分-建议和规划"><a href="#第三部分-建议和规划" class="headerlink" title="第三部分 建议和规划"></a>第三部分 建议和规划</h2><blockquote>
<p>首先，市场有多大？潜在的用户有多少？</p>
</blockquote>
<p>　　在“第二部分 分析”一栏中有列出，据今年三月的最新数据，Visual Studio占IDE市场份额的24.08%，居高不下，VS Code占6.49%，有明显的上升趋势。Visual Studio面向大小型开发团队、个人开发者、学生等群体，其潜在用户还有编程初学者、需要编程的实验人员等，以及其他平台的开发人员；VS Code作为跨平台的轻量级IDE，其文本编辑功能配合插件也十分受众，其潜在用户可能有文字工作者、进行轻量开发的编程爱好者等。</p>
<blockquote>
<p>目前市场上有什么样的产品了，它们的优势劣势在哪里?和它直接竞争的产品在那里？</p>
</blockquote>
<p>目前市场上与Visual Studio这种工程级别IDE竞争的产品有：</p>
<ul>
<li>Eclipse<ul>
<li>优点：很适用Java，更新速度快，插件功能强大</li>
<li>缺点：大工程的内存、CPU消耗大</li>
</ul>
</li>
<li>IntelliJ IDEA<ul>
<li>优点：对重构的优越支持，GUI简洁易用</li>
<li>缺点缺乏技术文章，同一页面只支持单工程开发</li>
</ul>
</li>
<li>NetBeans<ul>
<li>优点：人性化，功能强大</li>
<li>缺点：界面设计存在不足</li>
</ul>
</li>
<li>……</li>
</ul>
<p>此外，VS Code作为轻量级编辑器，其竞争对手有：</p>
<ul>
<li>Sublime Text<ul>
<li>优点：体积小、运行快，内嵌python解释器，主流前端开发工具</li>
<li>缺点：收费闭源，同时编辑多项目存在缺陷，多插件影响使用</li>
</ul>
</li>
<li>Atom<ul>
<li>优点：bug修复迅速，稳定，插件生态圈发展快</li>
<li>缺点：启动速度慢，技术不成熟</li>
</ul>
</li>
<li>……</li>
</ul>
<blockquote>
<p>功能：你要设计什么样的功能？为何要做这个功能，而不是其他功能？为什么用户会用你的产品/功能？你的创新在哪里？可以用NABCD分析.</p>
</blockquote>
<p>　　我认为可以设计“编程初学者支持”功能，作为VS/VS Code的插件或可开关的功能选项。这个功能是为了解决编程初学者编码困难的需求（<strong>Need</strong>），现有的IDE或代码编辑器只支持代码补全、高亮等编码基本辅助功能，或是对编码风格的提醒约束，但这款功能可以为编程初学者提供相关语言的编码提示或知识的深入引导（<strong>Approach</strong>），比如编写二维数组遍历时，可给出不同遍历顺序造成的性能影响；使用容器时，给出其他可选容器的使用方法等等。该功能可以有效地帮助编程初学者熟悉相关语言的编程知识，了解性能更高的编程方式以及规范的编码技巧（<strong>Benefit</strong>），从而让软件能够吸收编程初学者用户，扩大市场，在从事IT事业人员迅速增长的环境下占据有利地位（<strong>Competitor</strong>）。同时，高影响力的发布会和成熟的官方平台也可以让用户更快地了解我们的功能，进一步扩大传播（<strong>Delivery</strong>）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://stackoverflow.com/questions/30527522/what-are-the-differences-between-visual-studio-code-and-visual-studio" target="_blank" rel="noopener">What are the differences between Visual Studio Code and Visual Studio?</a></li>
<li><a href="https://www.zhihu.com/question/311047616/answer/600764352" target="_blank" rel="noopener">Visual Studio 和 Visual Studio Code 什么关系？</a></li>
<li><a href="https://visualstudio.microsoft.com/downloads/" target="_blank" rel="noopener">Microsoft Visual Studio 产品下载</a></li>
<li><a href="http://www.6ke.com.cn/it/2019/1210/28901.html" target="_blank" rel="noopener">微软visual studio诞生20年回顾</a></li>
<li><a href="https://github.com/Microsoft/vscode" target="_blank" rel="noopener">VS Code开源仓库</a></li>
<li><a href="https://pypl.github.io/IDE.html" target="_blank" rel="noopener">Top IDE index</a></li>
<li><a href="https://www.cnblogs.com/iammatthew/archive/2010/11/28/1890100.html" target="_blank" rel="noopener">解读IntelliJ IDEA的优缺点</a></li>
<li><a href="https://blog.csdn.net/meism5/article/details/84075499" target="_blank" rel="noopener">eclipse的优缺点</a></li>
<li><a href="https://www.jianshu.com/p/ede0b6107548" target="_blank" rel="noopener">Atom、Sublime Text、VSCode 三者比较</a></li>
<li><a href="https://www.cnblogs.com/xinz/archive/2010/12/01/1893323.html" target="_blank" rel="noopener">现代软件工程课件 需求分析 如何提出靠谱的项目建议 NABCD</a><!-- * https://zhuanlan.zhihu.com/p/54164612 --></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>个人项目作业-Intersect</title>
    <url>/2020/03/23/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th>项目</th>
<th>内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td>这个作业属于哪个课程</td>
<td><a href="https://edu.cnblogs.com/campus/buaa/BUAA_SE_2020_LJ" target="_blank" rel="noopener">2020春季计算机学院软件工程（罗杰、任建）</a> </td>
</tr>
<tr>
<td>这个作业的要求在哪里</td>
<td><a href="https://edu.cnblogs.com/campus/buaa/BUAA_SE_2020_LJ/homework/10429" target="_blank" rel="noopener">个人项目作业 </a> </td>
</tr>
<tr>
<td>我在这个课程的目标是</td>
<td>提高软件开发能力、团队协作能力 </td>
</tr>
<tr>
<td>这个作业在哪个具体方面帮助我实现目标</td>
<td>个人开发实践 </td>
</tr>
<tr>
<td>教学班级</td>
<td>006</td>
</tr>
<tr>
<td>项目地址</td>
<td><a href="https://github.com/kongkongNG/Intersection_proj" target="_blank" rel="noopener">https://github.com/kongkongNG/Intersection_proj</a></td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<p><br></p>
<h2 id="一、PSP表格"><a href="#一、PSP表格" class="headerlink" title="一、PSP表格"></a>一、PSP表格</h2><div class="table-container">
<table>
<thead>
<tr>
<th>PSP2.1</th>
<th>Personal Software Process Stages</th>
<th>预估耗时（分钟）</th>
<th>实际耗时（分钟）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Planning</td>
<td>计划</td>
<td></td>
<td></td>
</tr>
<tr>
<td>· Estimate</td>
<td>估计这个任务需要多少时间</td>
<td>30</td>
<td>30</td>
</tr>
<tr>
<td>Development</td>
<td>开发</td>
<td></td>
<td></td>
</tr>
<tr>
<td>· Analysis</td>
<td>需求分析 (包括学习新技术)</td>
<td>30</td>
<td>40</td>
</tr>
<tr>
<td>· Design Spec</td>
<td>生成设计文档</td>
<td>60</td>
<td>20</td>
</tr>
<tr>
<td>· Design Review</td>
<td>设计复审 (和同事审核设计文档)</td>
<td>20</td>
<td>5</td>
</tr>
<tr>
<td>· Coding Standard</td>
<td>代码规范 (为目前的开发制定合适的规范)</td>
<td>10</td>
<td>5</td>
</tr>
<tr>
<td>· Design</td>
<td>具体设计</td>
<td>60</td>
<td>60</td>
</tr>
<tr>
<td>· Coding</td>
<td>具体编码</td>
<td>120</td>
<td>240</td>
</tr>
<tr>
<td>· Code Review</td>
<td>代码复审</td>
<td>30</td>
<td>60</td>
</tr>
<tr>
<td>· Test</td>
<td>测试（自我测试，修改代码，提交修改）</td>
<td>60</td>
<td>360</td>
</tr>
<tr>
<td>Reporting</td>
<td>报告</td>
<td></td>
<td></td>
</tr>
<tr>
<td>· Test Report</td>
<td>测试报告</td>
<td>40</td>
<td>20</td>
</tr>
<tr>
<td>· Size Measurement</td>
<td>计算工作量</td>
<td>20</td>
<td>10</td>
</tr>
<tr>
<td>· Postmortem &amp; Process Improvement Plan</td>
<td>事后总结, 并提出过程改进计划</td>
<td>60</td>
<td>30</td>
</tr>
<tr>
<td></td>
<td>合计</td>
<td>540</td>
<td>880</td>
</tr>
</tbody>
</table>
</div>
<p>　　从表格中可以看到，事前预估的编码与测试的时间估计差距比较大，原因总结如下：</p>
<ol>
<li>设计时本着“先让它跑起来”的想法，对于一些精度、边界问题没有考虑充分，导致测试时bug层出不穷。</li>
<li>编码时对于C++的容器、某些特性不够熟悉，边查边写导致效率很低。这里充分体会到了讲义里<a href="https://www.cnblogs.com/xinz/archive/2011/08/07/2129751.html" target="_blank" rel="noopener">技能的反面</a>所说的痛处。</li>
<li>在家里惰性较重，常常分心导致思路不连贯。</li>
</ol>
<p><br></p>
<h2 id="二、解题思路描述"><a href="#二、解题思路描述" class="headerlink" title="二、解题思路描述"></a>二、解题思路描述</h2><p>　　刚拿到题目，首先思考的是寻找通过数学技巧直接判断交点数而无需求交点的方法，然而当考虑到可能会出现重复交点的情况，数学技巧只能求最少交点数与最大交点数，进而转向暴力求解交点，并通过比较去重的方法。</p>
<p>　　之后开始通过计算验证和查找的方式得到各种交点公式，判断可行性。所有用到的公式都放在<a href="https://github.com/kongkongNG/Intersection_proj/blob/master/README.md" target="_blank" rel="noopener">设计文档</a>的“数学准备”一栏中，故不再赘述。</p>
<p>　　接下来考虑的是交点去重问题。查资料得知C++的<code>set</code>类采用RB树的数据结构，能够自动去重，所以选择<code>set</code>作为储存交点的数据结构。</p>
<p><br></p>
<h2 id="三、设计实现过程。"><a href="#三、设计实现过程。" class="headerlink" title="三、设计实现过程。"></a>三、设计实现过程。</h2><p>　　本次项目的实现思路为：每次接收一个几何对象时，判断它与之前存下的所有几何对象是否相交，若相交则求交点，并加入交点的<code>set</code>集合。</p>
<p>　　类的设计大致是：通过一个<code>Geometry</code>类作为几何对象的总纲，其中有判断是否相交和求交点两个函数，<code>Line</code>类和<code>Circle</code>类实现这个接口；<code>Intersection</code>类负责实现接受外部参数、实现业务的功能。</p>
<p>　　如图为<code>Line</code>类, <code>Circle</code>类与<code>Geomtry</code>类的关系：</p>
<p><img src="https://i.loli.net/2020/03/10/KqYXkWatJHIcySF.png" alt="md_2020-03-09-23-13-20.png"></p>
<p>　　由于关键函数中的内容基本为数学公式的编码，故下面只展示基本需求——求两直线交点的流程图：<br><img src="https://i.loli.net/2020/03/10/QRqUsIngV7vNEmO.png" alt="md_2020-03-09-23-28-26.png"></p>
<p>　　单元测试的设计有常规样例测试与边界样例测试，检测几何对象之间是否相交以及相交得到的交点坐标是否准确。其中，<strong>直线与直线</strong>的相交检测考虑：任一条直线与坐标轴平行、两条直线都与坐标轴平行、两条直线都不与坐标轴平行三种情况；<strong>直线与圆</strong>相交检测考虑：直线与圆相交、直线与圆相切、直线与圆相离、直线与坐标轴平行四种样例；<strong>两圆</strong>相交检测：两圆相交、两圆内切、两圆外切、两圆内离、两圆外离五种情况；<strong>多个几何对象</strong>测试中考虑交点重合以及不重合的情况。</p>
<p><br></p>
<h2 id="四、性能分析"><a href="#四、性能分析" class="headerlink" title="四、性能分析"></a>四、性能分析</h2><p>　　这里的性能分析采用的输入数据是1000+组直线数据：<br><img src="https://i.loli.net/2020/03/10/OupcF32WYCbed9D.png" alt="md_2020-03-10-10-21-34.png"></p>
<p>　　从图中可以看到，在<code>main</code>中开销最大的是主业务函数<code>count_intersection()</code>，其中，有两个“热函数”：<code>std::_Tree</code>的构造函数（也就是<code>set</code>的插入与去重），以及<code>Line::getInterPoint()</code>（即直线的交点计算函数）</p>
<p>　　性能改进大概花费了1h左右，改进的地方不多，思路是将中间运算尽可能简化，比如将相同的开方操作、乘除运算等重复运算提前算出结果，重复使用。</p>
<p><br></p>
<h2 id="五、代码说明。"><a href="#五、代码说明。" class="headerlink" title="五、代码说明。"></a>五、代码说明。</h2><h3 id="1）直线与直线相交"><a href="#1）直线与直线相交" class="headerlink" title="1）直线与直线相交"></a>1）直线与直线相交</h3><p><strong>相交检测：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;isVerticalToX()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ln-&gt;isVerticalToX()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ln-&gt;isVerticalToX()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;isVerticalToX()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="keyword">this</span>-&gt;k - ln-&gt;k) &gt; EPS;</span><br></pre></td></tr></table></figure><br>　　思路很简单，就是考虑垂直坐标轴的直线后，判断<code>k</code>是否相等（这里用<code>fabs()&gt;EPS</code>考虑了double的精度问题），从而判断两直线是否平行，平行则无交点。</p>
<p><strong>求交点：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;isVerticalToX()) &#123;</span><br><span class="line">    x = <span class="keyword">this</span>-&gt;x;</span><br><span class="line">    y = ln-&gt;k * x + ln-&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ln-&gt;isVerticalToX()) &#123;</span><br><span class="line">    x = ln-&gt;x;</span><br><span class="line">    y = <span class="keyword">this</span>-&gt;k * x + <span class="keyword">this</span>-&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;	<span class="comment">// no need to consider vertical to y because we can handle it</span></span><br><span class="line">    x = (ln-&gt;b - <span class="keyword">this</span>-&gt;b) / (<span class="keyword">this</span>-&gt;k - ln-&gt;k);</span><br><span class="line">    y = <span class="keyword">this</span>-&gt;k * x + <span class="keyword">this</span>-&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pvec.push_back(&#123; x, y &#125;);</span><br></pre></td></tr></table></figure>
<p>　　由于采用斜率式的储存方法，所以当直线垂直于X轴时，交点的x值可以直接取得（在输入中作了判断并存值）。代码中注释的意思是：当某直线垂直于Y轴时，无需特殊考虑，因为仍可以通过公式正常求解（不会出现两条直线都垂直Y轴的情况，已经通过相交检测过滤）。其他正常直线通过公式求解即可得到交点。</p>
<h3 id="2）直线与圆相交"><a href="#2）直线与圆相交" class="headerlink" title="2）直线与圆相交"></a>2）直线与圆相交</h3><p><strong>相交检测：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isVerticalToX()) &#123;</span><br><span class="line">    d = <span class="built_in">fabs</span>(cc-&gt;n - <span class="keyword">this</span>-&gt;x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isVerticalToY()) &#123;</span><br><span class="line">    d = <span class="built_in">fabs</span>(cc-&gt;m - <span class="keyword">this</span>-&gt;b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    up = <span class="keyword">this</span>-&gt;k * cc-&gt;n - cc-&gt;m + <span class="keyword">this</span>-&gt;b;</span><br><span class="line">    down = <span class="built_in">sqrt</span>(<span class="keyword">this</span>-&gt;k * <span class="keyword">this</span>-&gt;k + <span class="number">1</span>);</span><br><span class="line">    d = <span class="built_in">fabs</span>(up / down);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d &gt; cc-&gt;r) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　思路是：考虑直线垂直于X轴、垂直于Y轴与正常直线三种情况时圆心到直线距离，通过距离与圆半径的比较即可得到圆与直线相交关系：<code>d&lt;r</code>则相交，否则不相交（这里将相切与相交合并为相交，因为求交点时会通过求得的值判定交点是1个还是2个）</p>
<p><strong>求交点：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A = <span class="number">1</span> + k * k;</span><br><span class="line">B = <span class="number">2</span> * k * (b - cc-&gt;m) - <span class="number">2</span> * cc-&gt;n;</span><br><span class="line">C = (b - cc-&gt;m) * (b - cc-&gt;m) + cc-&gt;n * cc-&gt;n - cc-&gt;r * cc-&gt;r;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans = Geomtry::solve(A, B, C);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = ans.<span class="built_in">begin</span>(); it != ans.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">double</span> yi = k * *it + b;</span><br><span class="line">    pvec.push_back(&#123; *it, yi &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　垂直坐标轴的特殊直线与圆交点求法就是带入已知x值或y值，利用几何知识求解，代码不再赘述。上述代码是正常直线与圆相交的情况，数学公式见<a href="https://github.com/kongkongNG/Intersection_proj/blob/master/README.md" target="_blank" rel="noopener">设计文档</a>的“数学准备”一栏，思路是得到直线与圆相交的一元二次方程组后，通过<code>Geomtry::solve(A, B, C)</code>求解方程得到横坐标（如果相切只返回一个），然后带入直线得到纵坐标。</p>
<h3 id="3）两圆相交"><a href="#3）两圆相交" class="headerlink" title="3）两圆相交"></a>3）两圆相交</h3><p><strong>相交检测：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dcenter = <span class="built_in">sqrt</span>((n - cc-&gt;n) * (n - cc-&gt;n) </span><br><span class="line">	+ (m - cc-&gt;m) * (m - cc-&gt;m));	<span class="comment">// d = sqrt((x1-x2)^2 + (y1-y2)^2)</span></span><br><span class="line"><span class="keyword">if</span> (dcenter &gt; r + cc-&gt;r || dcenter &lt; <span class="built_in">fabs</span>(r - cc-&gt;r) ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　思路是通过计算两圆心距离与半径关系进行判断。若圆心距大于半径之和，表示两圆外离；若圆心距小于半径差的绝对值，表示两圆內离。其他情况为存在交点。</p>
<p><strong>求交点：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">d = <span class="built_in">sqrt</span>((n - cc-&gt;n) * (n - cc-&gt;n)</span><br><span class="line">        + (m - cc-&gt;m) * (m - cc-&gt;m));	<span class="comment">// distance of two centers</span></span><br><span class="line">AE = (<span class="keyword">this</span>-&gt;r * <span class="keyword">this</span>-&gt;r - cc-&gt;r * cc-&gt;r + d * d) / (<span class="number">2</span> * d);</span><br><span class="line">x0 = <span class="keyword">this</span>-&gt;n + AE / d * (cc-&gt;n - <span class="keyword">this</span>-&gt;n); <span class="comment">// x0 = x1 + AE/d * (x2-x1)</span></span><br><span class="line">y0 = <span class="keyword">this</span>-&gt;m + AE / d * (cc-&gt;m - <span class="keyword">this</span>-&gt;m); <span class="comment">// x0 = x1 + AE/d * (x2-x1)</span></span><br><span class="line">CE = <span class="built_in">sqrt</span>(r * r - AE * AE); <span class="comment">// CE^2 + AE^2 = AC^2 = r^2</span></span><br><span class="line"></span><br><span class="line">x1 = x0 - CE / d * (cc-&gt;m - m);</span><br><span class="line">y1 = y0 + CE / d * (cc-&gt;n - n);</span><br><span class="line">x2 = x0 + CE / d * (cc-&gt;m - m);</span><br><span class="line">y2 = y0 - CE / d * (cc-&gt;n - n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2) &#123;</span><br><span class="line">    pvec.push_back(&#123; x1, y1 &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    pvec.push_back(&#123; x1, y1 &#125;);</span><br><span class="line">    pvec.push_back(&#123; x2, y2 &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　同样是几何关系推演得到的结果进行编码，公式在<a href="https://github.com/kongkongNG/Intersection_proj/blob/master/README.md" target="_blank" rel="noopener">设计文档</a>的“数学准备”一栏能找到。推导思路是先求得两圆交点连线与圆心连线的交点，再通过相似三角形的性质得到横纵坐标。</p>
<h3 id="4）主逻辑"><a href="#4）主逻辑" class="headerlink" title="4）主逻辑"></a>4）主逻辑</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = geoms.<span class="built_in">begin</span>(); it != geoms.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (gmt-&gt;isInterset(*it)) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Point&gt; pvec = gmt-&gt;getInterPoint(*it);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> pIt = pvec.<span class="built_in">begin</span>(); pIt != pvec.<span class="built_in">end</span>(); pIt++) &#123;</span><br><span class="line">            pIt-&gt;id = points.<span class="built_in">size</span>();</span><br><span class="line">            points.insert(*pIt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">geoms.push_back(gmt);</span><br></pre></td></tr></table></figure>
<p>　　主程序的思路就是每次将输入的几何对象与当前所有几何对象做相交检测，若存在交点，则计算交点并加入点集。其中<code>gmt</code>是当前输入的几何对象，<code>geoms</code>是几何对象集合，<code>points</code>是结构体<code>Point</code>的<code>set</code>集合，能够通过<code>operator&lt;</code>的判断进行去重。<code>Point</code>中重写了<code>operator&lt;</code>，在精度范围内两个点相同则返回<code>false</code>。</p>
<p>　　下面是Point结构体的细节：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">	<span class="keyword">double</span> x, y;</span><br><span class="line">	Point(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;p) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fabs</span>(x - p.x) &lt;= EPS &amp;&amp; <span class="built_in">fabs</span>(y - p.y) &lt;= EPS) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (x!=p.x)? x &lt; p.x : y &lt; p.y;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br></p>
<h2 id="六、代码分析与单元测试结果"><a href="#六、代码分析与单元测试结果" class="headerlink" title="六、代码分析与单元测试结果"></a>六、代码分析与单元测试结果</h2><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p><strong>消除警告前：</strong></p>
<p><img src="https://i.loli.net/2020/03/10/lgPrLWZ4cqf1xHn.png" alt="md_2020-03-10-16-37-34.png"></p>
<p>代码中存在的问题及解决办法如下：</p>
<ul>
<li><code>C26435</code>：存在未初始化的成员。解决办法是给每个可能无初值的成员赋初值</li>
<li><code>C26451</code>：算术溢出，将4byte的值用于减法运算并赋给8byte的结果。解决办法是在<code>int</code>型数据前强制转换为<code>double</code>参与减法运算。</li>
</ul>
<p><strong>消除警告后：</strong></p>
<p><img src="https://i.loli.net/2020/03/10/t9sjDHPoAiNWaqL.png" alt="md_2020-03-10-16-41-43.png"></p>
<h3 id="单元测试结果"><a href="#单元测试结果" class="headerlink" title="单元测试结果"></a>单元测试结果</h3><p>　　单元测试的<a href="https://github.com/kongkongNG/Intersection_proj/blob/master/test/IntersectionUnitTest.cpp" target="_blank" rel="noopener">测试文件</a>按照“三、设计实现过程”中的设计来完成，即直线与直线、直线与圆、圆与圆以及总体业务逻辑测试，测试结果如下：</p>
<p><img src="https://i.loli.net/2020/03/10/Q7FkWcPrJgeqHiO.png" alt="md_2020-03-10-18-41-02.png"></p>
]]></content>
      <categories>
        <category>SoftWareEngineering</category>
      </categories>
      <tags>
        <tag>CourseHomework</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客作业-讲义阅读</title>
    <url>/2020/03/23/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th>项目</th>
<th>内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td>这个作业属于哪个课程</td>
<td><a href="https://edu.cnblogs.com/campus/buaa/BUAA_SE_2020_LJ" target="_blank" rel="noopener">2020春季计算机学院软件工程（罗杰、任建）</a> </td>
</tr>
<tr>
<td>这个作业的要求在哪里</td>
<td><a href="https://edu.cnblogs.com/campus/buaa/BUAA_SE_2020_LJ/homework/10410" target="_blank" rel="noopener">个人博客作业 </a> </td>
</tr>
<tr>
<td>我在这个课程的目标是</td>
<td>提高软件开发能力、团队协作能力 </td>
</tr>
<tr>
<td>这个作业在哪个具体方面帮助我实现目标</td>
<td>了解与总结软件工程的一些方法论 </td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<h2 id="一、阅览教材-讲义后问题汇总"><a href="#一、阅览教材-讲义后问题汇总" class="headerlink" title="一、阅览教材/讲义后问题汇总"></a>一、阅览教材/讲义后问题汇总</h2><p><br></p>
<p> <strong>1）<a href="https://www.cnblogs.com/xinz/archive/2011/10/22/2220872.html" target="_blank" rel="noopener">PSP: Personal Software Process</a>：每个人的工作质量直接影响最终软件的质量？</strong></p>
<p>读到“每个人的工作质量直接影响最终软件的质量”这一段话，我有一个小问题：也许只有团队中少部分人真正影响了最终软件的质量呢？当经过软件的设计与任务的分配，团队不免会有“划水”的人存在，也就是<a href="https://www.cnblogs.com/xinz/archive/2010/12/11/1902933.html" target="_blank" rel="noopener">非P1的人</a>，他们的工作无非只会延长成果的完成时间。而团队中能力较强的人能够完成这些“额外”单工作，将进度拉回正轨，最终的软件质量也就不受影响了。</p>
<p><br></p>
<p><strong>2）<a href="https://www.cnblogs.com/xinz/archive/2011/08/07/2129751.html" target="_blank" rel="noopener">技能的反面</a>：技能的反面是problem solving？</strong></p>
<p>读到“技能的反面是Problem solving”这句话，我存在疑惑。这里对Problem Solving的解释有些生硬，将其意思约束在了能力差的人的行为表现。然而Problem Solving也是一项能力，如果一个人称自己精通编程，在被要求用特定语言完成一个问题的情况下，通过“Problem Solving”迅速了解了这门语言的基本用法，并完成了题目，这又何尝不是技能的精通呢？</p>
<p><br></p>
<p><strong>3）<a href="https://www.cnblogs.com/xinz/archive/2011/08/07/2130332.html" target="_blank" rel="noopener">结对编程</a> 测试的极致做法是TDD？</strong></p>
<p>文中对极限编程的表格中，有这么一项：“测试/单元测试能帮助提高质量”的极致做法是“先写单元测试，从测试开始写程序——TDD”。通过网上查阅得知，TDD的基本思想是在开发功能代码之前，先编写测试代码，其理念是</p>
<ul>
<li>确保所有需求都能被照顾到</li>
<li>在代码不断增加和重构的过程中，可以检查所有功能是否正确</li>
</ul>
<p>从上述的解释来看，如果需求在不断改变，一旦某段实际功能代码作废，其测试代码也将报废。若面临软件重构的情况，带来的测试程序的改动将是十分巨大的。此外，如果只根据需求分析编写测试程序，而不去考虑实际程序，结果测试只能覆盖结果的正确性，而无法保证其实现过程正确，程序的bug往往出现在对实现细节的考虑不周。</p>
<p>因此，我对“测试能提高质量的极致是TDD”的推理仍存在疑惑。</p>
<p><br></p>
<p><strong>4）<a href="https://www.cnblogs.com/xinz/archive/2010/12/11/1902849.html" target="_blank" rel="noopener">敏捷宣言</a>：敏捷求成品，而不需要文档？</strong>  </p>
<p>读到现有做法与敏捷的对比表格：“现有的做法：完整的文档；敏捷的做法：可用的软件”，我存在一些疑惑。面向对象程序设计课程中教给我们，编码之前应充分设计，且需充分考虑其可扩展性，在实践过程中，我发现明确的设计文档确实对编码思路、增量开发有很大帮助。而敏捷目标在于“可用的软件”，当遇到需求的变化时，没有经过充分设计的文档指导与代码支撑，增量开发会不会变得十分困难，反而不那么“敏捷”了？</p>
<p><br></p>
<p><strong>5）<a href="https://www.cnblogs.com/xinz/archive/2011/03/13/1982585.html" target="_blank" rel="noopener">画扇面</a>：速成还是求全？</strong></p>
<p>博客中利用画扇面的例子形象描述出软件工程团队项目进展，引起了我的思考：如果团队项目在进行中途不断添加需求，最终会导致问题层出不穷复杂从而项目流产，那么团队在最初的需求分析时，应该尽可能将需求简化，以达到“速成”的目的，还是应该将需求的功能充分考虑呢？</p>
<p>以我的个人经验来看，如果作为学生，项目的最终目的是为了的高分，那么前期的充分需求分析、创新性想法就成了争夺高分的利器，而且在准备做足的基础上，项目进展的加速度大，动力也足；而如果追求敏捷而抛弃充分分析的话，导致成果得分不高的同时，还会出现项目完成时处于距离交差不上不下的时间、没有动力增加新功能的窘况。当然在如果交差时间很局限的话，削减需求、敏捷开发还是很必要的。</p>
<p><br></p>
<p><strong>6）<a href="https://www.cnblogs.com/xinz/archive/2011/07/10/2102310.html" target="_blank" rel="noopener">创新的迷思  连载(2)</a>：技术创新不一定是关键？</strong> </p>
<p>在“迷思之六-技术的创新是关键”一节中，作者的观点是，除了技术的创新，其他方面的创新也显得尤为重要。而我认为，相比于其他创新带来的昙花一现，技术的创新才是关键。ipod成功的真正原因并不是用户界面上的创新，而是它实现了“把1000首歌塞进口袋”的技术；苹果生态能够取得成功，得益于其内部软硬件技术的一次次创新；网络购物理念出现时，Paul Graham使用Lisp语言编写Viaweb，在技术上一直领先竞争者，并具有更快的迭代速度，从而占据领先地位。其他方面的创新固然能产生显著效果，比如共享经济、电商经济，但谁才能真正享有成功的果实？只有技术创新才能带来一骑绝尘的实力。因此，对于作者在“技术的创新是关键”的迷思上，我存有疑惑。</p>
<p><br></p>
<h2 id="二、“软件”、“软件工程”词汇的产生"><a href="#二、“软件”、“软件工程”词汇的产生" class="headerlink" title="二、“软件”、“软件工程”词汇的产生"></a>二、“软件”、“软件工程”词汇的产生</h2><p><strong>“软件”的产生</strong></p>
<blockquote>
<p>In 2000, Fred Shapiro, a librarian at the Yale Law School, published a letter revealing that <strong>Tukey</strong>‘s 1958 paper “The Teaching of Concrete Mathematics” contained the earliest known usage of the term “software” found in a search of JSTOR’s electronic archives, predating the OED’s citation by two years. This led many to credit Tukey with coining the term, particularly in obituaries published that same year, although Tukey never claimed credit for any such coinage. In 1995, <strong>Paul Niquette</strong> claimed he had originally coined the term in October 1953, although he could not find any documents supporting his claim. The earliest known publication of the term “software” in an engineering context was in August 1953 by <strong>Richard R. Carhart</strong>, in a RAND Corporation research memorandum.</p>
</blockquote>
<p>上文中说明了“软件”一词的3种起源：</p>
<ul>
<li>1958年Tukey在论文《The Teaching of Concrete Mathematics》中包含了“软件”一词的最早用法</li>
<li>Paul Niquette 声称自己在1953年10月创造了“软件”这个词，经管他找不到支持他说法的文件</li>
<li>“软件”在工程领域的最早出现是1953年8月Richard R.Carhart在RAND公司的研究备忘录中</li>
</ul>
<p><br></p>
<p><strong>“软件工程”的产生</strong></p>
<blockquote>
<p><strong>Hamilton</strong> details how she came to make up the term “software engineering”:<br>When I first came up with the term, no one had heard of it before, at least in our world. It was an ongoing joke for a long time. They liked to kid me about my radical ideas. It was a memorable day when one of the most respected hardware gurus explained to everyone in a meeting that he agreed with me that the process of building software should also be considered an engineering discipline, just like with hardware. Not because of his acceptance of the new ‘term’ per se, but because we had earned his and the acceptance of the others in the room as being in an engineering field in its own right.</p>
</blockquote>
<p>“软件工程”是在1960s阿波罗计划执行期间由Margaret Hamilton提出。上面是Margaret Hamilton描述自己如何提出“软件工程”这一词汇的细节。</p>
<p><br></p>
<h2 id="三、软件工程发展的过程中的冷知识"><a href="#三、软件工程发展的过程中的冷知识" class="headerlink" title="三、软件工程发展的过程中的冷知识"></a>三、软件工程发展的过程中的冷知识</h2><blockquote>
<p>Unix的命名：上世纪六七十年代，计算机工业几大巨头聚在一起，合作研发官方版的下一代操作系统Multics。但是，另外两个年轻人——26岁的肯·汤普森和28岁的丹尼斯·里奇——觉得Multics过分负载，就另起炉灶，写出了一个自己的操作系统。他们参照Multics，为它取了一个搞笑式的名字Unix（注：前缀Multi-意思是“多个”，而前缀Uni-意思是“单个”）<br>                                                   ——《黑客与画家》</p>
</blockquote>
<p><br></p>
<h2 id="四、源代码与项目管理软件调研"><a href="#四、源代码与项目管理软件调研" class="headerlink" title="四、源代码与项目管理软件调研"></a>四、源代码与项目管理软件调研</h2><p>目前主要流行的源代码和项目管理软件有Microsoft TFS，GitHub，Trac，Bugzilla，Apple XCode等。优缺点如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Microsoft TFS</td>
<td>对敏捷、CMMI等项目、过程管理改善有较好支持，需求、项目进度一览无余，对小团队开发有利</td>
<td>用户量少，源代码功能使用较多，但并不是软件定位</td>
</tr>
<tr>
<td>Git</td>
<td>支持多人维护庞大项目，分支能力强大、体验好，支持离线提交、非线性开发，是的协作流畅</td>
<td>上手难，代码保密性差</td>
</tr>
<tr>
<td>Mercurial</td>
<td>命令行简单，易上手，可扩展性好，对网络依赖性低</td>
<td>功能较弱，分支方式杂多不便，改写历史麻烦；没有命名空间，容易混淆</td>
</tr>
<tr>
<td>GitHub</td>
<td>基于web，允许使用Git的源代码管理功能，开源</td>
<td>适合代码跟踪，但不适合设计跟踪，对国内用户不友好</td>
</tr>
<tr>
<td>Bitbucket</td>
<td>免费支持私有仓库，且同时支持hg/Git，自定义域名，有Bug追踪功能</td>
<td>鲜为人知</td>
</tr>
<tr>
<td>Trac</td>
<td>有良好的扩充性，权限体系的设计较完备，灵活、可随心所欲定制</td>
<td>不支持多项目，核心功能少，中文化不完整，本地化很差</td>
</tr>
<tr>
<td>Bugzilla</td>
<td>bug管理系统，检索功能强大，后端数据库强大，配置设定丰富多样</td>
<td>安装繁琐，不支持中文</td>
</tr>
<tr>
<td>Apple XCode</td>
<td>文件转移快速，可自由撤销，能够辅助开发</td>
<td>只支持Mac OS</td>
</tr>
</tbody>
</table>
</div>
<p>按照用户数和流行度排序排序如下（<a href="https://en.wikipedia.org/wiki/Comparison_of_source-code-hosting_facilities#Popularity" target="_blank" rel="noopener">参照Wiki</a>)</p>
<p><img src="https://i.loli.net/2020/03/06/p2chV1qsWZDaKjU.png" alt="md_2020-03-06-22-19-20.png"></p>
<p><br></p>
<h2 id="五、源代码与项目管理软件使用"><a href="#五、源代码与项目管理软件使用" class="headerlink" title="五、源代码与项目管理软件使用"></a>五、源代码与项目管理软件使用</h2><h3 id="1）Git"><a href="#1）Git" class="headerlink" title="1）Git"></a>1）Git</h3><ul>
<li>使用git初始化仓库<br><img src="https://i.loli.net/2020/03/06/hQrAsK31p8vNtcL.png" alt="md_2020-03-06-22-35-34.png"></li>
</ul>
<ul>
<li>使用git添加新版本并记录<br><img src="https://i.loli.net/2020/03/06/NmlS3hunpvCHrPd.png" alt="md_2020-03-06-22-41-38.png"></li>
</ul>
<p>使用体验：虽然需要记住几个命令行，但是一旦熟悉之后，使用非常方便，且支持离线管理。理解分支操作之后对团队开发将更有帮助。<br><br></p>
<h3 id="2）BitBucket"><a href="#2）BitBucket" class="headerlink" title="2）BitBucket"></a>2）BitBucket</h3><ul>
<li>在<a href="https://bitbucket.org/product/features" target="_blank" rel="noopener">BitBucket官网</a>完成注册登录后，可以创建新的私人仓库<br><img src="https://i.loli.net/2020/03/06/yqXMEkCOSvBuF5e.png" alt="md_2020-03-06-22-48-50.png"></li>
<li>创建仓库流程<br><img src="https://i.loli.net/2020/03/06/kmqg1CRHOKYVLrB.png" alt="md_2020-03-06-22-49-43.png"></li>
<li>完成仓库创建<br><img src="https://i.loli.net/2020/03/06/5wu2yejhJLSfTbE.png" alt="md_2020-03-06-22-51-08.png"></li>
<li>使用Git将仓库克隆到本地<br><img src="https://i.loli.net/2020/03/06/gujaUX2fHmwex5b.png" alt="md_2020-03-06-22-59-35.png"></li>
</ul>
<p><br></p>
<ul>
<li>使用Git添加本地项目文件，然后push到仓库中<br><img src="https://i.loli.net/2020/03/06/Af9JRKBZasMdveE.png" alt="md_2020-03-06-23-02-06.png"></li>
</ul>
<p>使用体验：BitBucket和Github很类似，对Git也有很好的支持，区别是Github私人仓库要收费，而BitBucket是免费的。此外，BitBucket用户界面美观大方，使用体验也很方便很赞。</p>
]]></content>
      <categories>
        <category>SoftWareEngineering</category>
      </categories>
      <tags>
        <tag>CourseHomework</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次作业-热身！</title>
    <url>/2020/03/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A-%E7%83%AD%E8%BA%AB/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th>项目</th>
<th>内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td>这个作业属于哪个课程</td>
<td><a href="https://edu.cnblogs.com/campus/buaa/BUAA_SE_2020_LJ" target="_blank" rel="noopener">2020春季计算机学院软件工程（罗杰、任建）</a> </td>
</tr>
<tr>
<td>这个作业的要求在哪里</td>
<td><a href="https://edu.cnblogs.com/campus/buaa/BUAA_SE_2020_LJ/homework/10410" target="_blank" rel="noopener">第一次作业-热身！</a> </td>
</tr>
<tr>
<td>我在这个课程的目标是</td>
<td>提高软件开发能力、团队协作能力 </td>
</tr>
<tr>
<td>这个作业在哪个具体方面帮助我实现目标</td>
<td>认清现状、明确规划 </td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<p><br></p>
<h1 id="一、结缘计算机"><a href="#一、结缘计算机" class="headerlink" title="一、结缘计算机"></a>一、结缘计算机</h1><p><br></p>
<h2 id="1-1-你为什么选择计算机专业？你认为你的条件如何？和这些博主比呢？"><a href="#1-1-你为什么选择计算机专业？你认为你的条件如何？和这些博主比呢？" class="headerlink" title="1.1 你为什么选择计算机专业？你认为你的条件如何？和这些博主比呢？"></a>1.1 你为什么选择计算机专业？你认为你的条件如何？和这些博主比呢？</h2><p>　　学生时代的我，与计算机的关系只停留在了娱乐一项。小学时老爸带回来的第一台电脑，在我眼里只是一个可以玩蜘蛛纸牌的。由于参与游泳特长训练，加之需要维持学业成绩，我没有将过多的精力投入在探索计算机的运行原理中，而是将其作为一个释放压力和追赶潮流的工具。同时，“编程”这个词在我生活中几乎从未出现过，除了电影。对它的印象只停留在黑客所掌握的酷酷的技能点。</p>
<p>　　平凡地经历高考之后，拿到了意外的好成绩，这是鼓励我投身信息专业的重要因素。经过反复思索后，我坚定了一个观点：信息专业是通向未来的专业，我想要探究信息世界是如何形成与发展的（也许是迟到的好奇心在作怪），这是决定性因素。很幸福的是，父母也十分尊重我的选择。所以，我最终填报了北航的信息大类志愿，也幸运地被压线录取。后来专业分流时选择选择计算机学院，有一部分“业界好评”的原因，有一部分热心向学的原因，也有一部分受周围环境影响的原因。</p>
<p>　　作为一个从大学才开始接触编程的计算机系本科生，我自认为条件自然是远远不如其他优秀的同学。从来到士谔书院起，我就十分敬仰那些中学参与信息学竞赛、热爱计算机、动手能力超强、理解能力超强的同学。虽然自己也在努力维持成绩，但编程能力、思维能力的不足还是让自己有些自卑。</p>
<p>　　与<a href="https://www.cnblogs.com/unruledboy/p/DevCareer.html" target="_blank" rel="noopener">博客I</a>的博主相比，我虽然没有他在学生时代钻研电脑的热情与经历，但拥有深入计算机专业的大学教育资源。我认为与他的条件相比，我无法区分谁好谁坏。都说“兴趣是最好的老师”，博主虽然读的是英语专业，却对计算机有十分浓厚的兴趣，这份热情驱使着他不断学习计算机领域新兴技术。而我虽然拥有十分优秀的教育资源，但仍在迷茫途中，对计算机的感情反复无常，但说不定随着理解的深入，我会在计算机领域找到一个自己热爱的方向呢？</p>
<p><br></p>
<h2 id="1-2-计算机是你喜欢的领域吗？是你擅长的领域吗？"><a href="#1-2-计算机是你喜欢的领域吗？是你擅长的领域吗？" class="headerlink" title="1.2 计算机是你喜欢的领域吗？是你擅长的领域吗？"></a>1.2 计算机是你喜欢的领域吗？是你擅长的领域吗？</h2><p>　　严格来说，不是。对于计算机体系结构，从计算机组成、操作系统到编译原理的课程学习来看，我很少感受到沉浸在解决难题的喜悦中，而更多的是害怕无法完成任务、跟不上系里其他同学的学业压力。当然，随着课程的学习，自己对计算机的一些问题也慢慢得到解答，这是使我感到充实的。从程序设计来看，解题过程对我来说也是比较煎熬的，且容易产生自我否定。那“不严格”来说呢？也许后续的学习会接触到某些方向，将运用之前学习的计算机领域知识系统地解决问题，那时也许我会非常乐意地说“我喜欢计算机”吧！</p>
<p>　　计算机绝对不是我擅长的领域。从本科的动手能力就能看出，程序设计、数据结构、计组等等，这些实验课中多数我都没有取得理想的成绩。且在计算机领域的知识广度、掌握的技能、实践的经历等我也远远比不上同系生。但我一直饱受心理问题的困扰——不自信。如果一直不相信自己有能力去解决某些问题，那么自己就会始终不愿意去深入、始终因为能力问题而兜兜转转。如果一直暗示自己不擅长计算机领域，也许我就再没有动力去学习领域内的新知识了。所以，还是试试相信自己的能力吧。</p>
<p><br></p>
<h2 id="1-3-你热爱这一专业吗？你对计算机的热爱是怎样的？仅仅是口头的吗？"><a href="#1-3-你热爱这一专业吗？你对计算机的热爱是怎样的？仅仅是口头的吗？" class="headerlink" title="1.3 你热爱这一专业吗？你对计算机的热爱是怎样的？仅仅是口头的吗？"></a>1.3 你热爱这一专业吗？你对计算机的热爱是怎样的？仅仅是口头的吗？</h2><p>　　目前并不热爱。我对计算机的感情有些复杂，有时会因为创造可行的程序而激动，有时又会因深陷在复杂的知识点中而被挫败。从大学学习开始，我按部就班地完成计算机专业安排的课程，对于可选的一般专业课，我也秉持着“能学多学”的原则，旨在增长见识去选课。但是目前为止，我没有被计算机专业所吸引，仍然被动地为学业而学，自然谈不上热爱。</p>
<p>　　反观<a href="https://www.cnblogs.com/geniusvczh/archive/2011/12/16/2290808.html" target="_blank" rel="noopener">博客M</a>的博主，我认为那便是热爱。从自学编程、尝试制作游戏，到解释高级语言、写脚本引擎，他的行动以兴趣为驱动，解决问题带来的正反馈效应又更加坚定他的热爱。</p>
<p><br></p>
<h1 id="二、在计算机系里学习"><a href="#二、在计算机系里学习" class="headerlink" title="二、在计算机系里学习"></a>二、在计算机系里学习</h1><p><br></p>
<h2 id="2-1-你对你的大学生活有什么想要吐槽的地方吗？你理想的大学教育应该是什么样子的？跟学校给你的有什么区别？比较你在中国大学的经历，你的老师和学校能做到和国外那样吗？如果不能，请分析一下为什么。"><a href="#2-1-你对你的大学生活有什么想要吐槽的地方吗？你理想的大学教育应该是什么样子的？跟学校给你的有什么区别？比较你在中国大学的经历，你的老师和学校能做到和国外那样吗？如果不能，请分析一下为什么。" class="headerlink" title="2.1 你对你的大学生活有什么想要吐槽的地方吗？你理想的大学教育应该是什么样子的？跟学校给你的有什么区别？比较你在中国大学的经历，你的老师和学校能做到和国外那样吗？如果不能，请分析一下为什么。"></a>2.1 你对你的大学生活有什么想要吐槽的地方吗？你理想的大学教育应该是什么样子的？跟学校给你的有什么区别？比较你在中国大学的经历，你的老师和学校能做到和国外那样吗？如果不能，请分析一下为什么。</h2><p>　　我的大学生活十分中规中矩，跟随着课程设置按部就班地完成学习。想要吐槽的地方是，学院的课程压力分配不太合理。比如大二上学期的计算机组成课，一门实验课可以说是占据了这一学期全部的重心，每周除了空闲时间，甚至理论课的时间、其他课堂的时间，也消耗在编写实验课任务上，此外，还对每周四的上机考核实验忧心忡忡。这样，每周的精力完全放在有没有通过本周Project上，而忽视了其他如离散数学、概率统计之类的重要数学基础课的学习，我认为有些得不偿失。且这种高压并不利于激发我改进设计的动力，反而更加迫使我按照课程要求的“模板”去完成设计，因害怕无法通过测试而不敢思考其他可行方案。</p>
<p>　　我理想的大学教育应该是与生产实践想结合的。如果在教授课程的同时，能够加入这门课在当今生产实践中的实际运用，也许能让学生对课程整体有更直观的认识，也能够激发学生对某个领域的兴趣。比如算法课，按照课程大纲一个个算法细讲十分枯燥，而如果能够将这些算法在当今各大软件中的实际应用带入讲解，并进行编程实践，或许这些算法就很难忘记了。</p>
<p>　　学校里的教育比较按部就班，有时上完一门课，却不知道这门课是做什么的。课程的知识点大多平铺罗列，着重于记忆而非联系。</p>
<p>　　我没有经历过国外教育，但我认为国内大学和国外应该还是有一定区别。国外大学学费高，学校能够将资金转换为更优质的教育环境和资源，且国外高校教授的薪资也更能促进优质课程的产生。相比较，国内高校人数多，旨在为更多人提供平均的教育，老师有发表论文的压力，薪资水平一般，难以有动力精心准备课堂。当然如今也有越来越多的老师因课堂质量深受学生喜爱。</p>
<p><br></p>
<h2 id="2-2-迄今为止，你写了多少代码，描述你做的最复杂的软件项目-作业。"><a href="#2-2-迄今为止，你写了多少代码，描述你做的最复杂的软件项目-作业。" class="headerlink" title="2.2 迄今为止，你写了多少代码，描述你做的最复杂的软件项目/作业。"></a>2.2 迄今为止，你写了多少代码，描述你做的最复杂的软件项目/作业。</h2><p>　　大一程序设计课总共约500行，数据结构课约1000行；大二计组课程约2000行，OO课程四个单元约4000行，暑期课OpenGL项目约500行；大三的编译器约5000行。合计不超过2w行吧，当然这都是粗略的估计。</p>
<p>　　最复杂的项目是大三上学期的C0编译器设计，总共5340行，包含词法分析、语法分析、语义分析、错误处理、中间代码生产、目标代码生成以及优化七个大模块，内部还有符号表之类的小设计。这是一个自己制作出来的比较有成就感的作业，课程只讲解大体的设计思路，其中实现细节经过了反复的思考、添加与修改。最终虽然错误处理测试没能通过，但优化目标代码的测试通过了，还是比较满足。</p>
<p><br></p>
<h2 id="2-3-科班出身和北大青鸟有什么区别？"><a href="#2-3-科班出身和北大青鸟有什么区别？" class="headerlink" title="2.3 科班出身和北大青鸟有什么区别？"></a>2.3 科班出身和北大青鸟有什么区别？</h2><p>　　我还依稀记得大一程序设计课荣欣老师在第一堂课就强调过这个问题：“你们和技校、培训班培养出来的码农不一样，你们不仅要会写程序，还要会设计程序”。我认为，当一个软件、或是一个程序的设计完成后，剩下的编码任务其实很容易完成，这点在面向对象课程中深有体会。科班出身的人在掌握编码的同时，还应具备的是设计复杂系统、解决疑难问题的能力；而北大青鸟，如<a href="https://www.cnblogs.com/Tpf386/p/4798437.html" target="_blank" rel="noopener">博客F</a>博主的经历所见，是以就业为目的、学习技能为导向的培训。</p>
<p><br></p>
<h2 id="2-4-速成的培训班和打基础的大学教育还有mooc之间有区别吗？"><a href="#2-4-速成的培训班和打基础的大学教育还有mooc之间有区别吗？" class="headerlink" title="2.4 速成的培训班和打基础的大学教育还有mooc之间有区别吗？"></a>2.4 速成的培训班和打基础的大学教育还有mooc之间有区别吗？</h2><p>　　速成培训班以求职技巧为核心，着重教授基本编程技能、美化简历，目的是让学员找到工作；mooc为教育资源差但学习热情高、自学能力强的学生提供名校课程教学，个人的自主学习能力尤为重要；大学教育不仅仅只有老师讲授的实体课堂，大学里提供的专业资源、社交资源、实践平台也十分重要。</p>
<p><br></p>
<h2 id="2-5学线性代数和概率论的时候，你是否有过这样的疑问“我们为什么要学这么多数学，这和我们的计算机有关系吗”，你现在是否还有这样的疑问？对这个问题，你有自己的解答了吗？那么其他学科呢？"><a href="#2-5学线性代数和概率论的时候，你是否有过这样的疑问“我们为什么要学这么多数学，这和我们的计算机有关系吗”，你现在是否还有这样的疑问？对这个问题，你有自己的解答了吗？那么其他学科呢？" class="headerlink" title="2.5学线性代数和概率论的时候，你是否有过这样的疑问“我们为什么要学这么多数学，这和我们的计算机有关系吗”，你现在是否还有这样的疑问？对这个问题，你有自己的解答了吗？那么其他学科呢？"></a>2.5学线性代数和概率论的时候，你是否有过这样的疑问“我们为什么要学这么多数学，这和我们的计算机有关系吗”，你现在是否还有这样的疑问？对这个问题，你有自己的解答了吗？那么其他学科呢？</h2><p>　　我曾经有过很多次这样的疑问，因为在这些数学基础课与计算机之间建立不起任何联系。现在这些疑问淡化了，因为随着专业课程的学习深入，这些数学知识或多或少地都得到了一些运用，比如OpenGL的光照运用到了线性代数的向量变换知识。但还有部分未得到解答，可能是因为学习的专业课不够多、不够深入，且见识短浅，可能还需在未来的研究实践中才能得到解答。其他学科如数学分析的知识在机器学习的SVM模型中得到了运用，离散数学的知识在计组的状态机中也有运用。进一步的解答还需等待眼界更加开阔。</p>
<p><br></p>
<h1 id="三、未来规划"><a href="#三、未来规划" class="headerlink" title="三、未来规划"></a>三、未来规划</h1><p><br></p>
<h2 id="3-1-对于你未来在IT行业的发展，你有什么样的梦想或者未来想从事什么样的工作？你准备怎样来规划你技术道路，职业道路和社会道路？（必答）"><a href="#3-1-对于你未来在IT行业的发展，你有什么样的梦想或者未来想从事什么样的工作？你准备怎样来规划你技术道路，职业道路和社会道路？（必答）" class="headerlink" title="3.1 对于你未来在IT行业的发展，你有什么样的梦想或者未来想从事什么样的工作？你准备怎样来规划你技术道路，职业道路和社会道路？（必答）"></a>3.1 对于你未来在IT行业的发展，你有什么样的梦想或者未来想从事什么样的工作？你准备怎样来规划你技术道路，职业道路和社会道路？（必答）</h2><p>　　这是大学里最困扰我的问题。曾经想过做与图形图像相关的技术工作，因为比起思考枯燥的程序算法，制作出肉眼可见的成果更能使我兴奋；作为英雄联盟的游戏爱好者，我也想过进入游戏行业，看过拳头游戏出品的《听说你想做游戏？？》系列宣传片中介绍的技术美工，更是十分向往；内心深处还有一个想法是依靠计算机积累原始资本，之后转行，投身自己真正感兴趣的领域。总之，这些都是迷茫摇摆的表现。</p>
<p>　　拜读过<a href="https://book.douban.com/subject/4006425/discussion/22803733/" target="_blank" rel="noopener">博客A</a>后，我对“产品经理”这一职位有了动念，源于文中这一句话：“产品经理是谷歌一个非常特殊的角色，一个产品除了开发和测试之外的事情，基本都由产品经理主导。其中最重要也是最令人激动的是产品功能设计，也就是说，你对产品功能的任何合理的想法，都可以在产品经理这个平台上得到实现，最终被全球数以亿计的网民使用，改变他们的生活！”。当然公司之间的产品经理或许职能会有不同，但是主导产品的创作确实令人十分兴奋。</p>
<p>　　<a href="">博客K</a>的博主说：“做规划时最重要的是两个方面：一是清楚地认识自己的能力、优势和性格；二是确定自己的专业和想从事的行业。只有在确定这两方面后，才能做出自己的职业规划”。对这两方面，我都没有很好的认识，所以谈如何规划道路，或许我不能叫规划，应该只能说是尝试，是迷茫期的探索。<a href="https://book.douban.com/subject/4006425/discussion/22802960/">博客B</a>给我很大的启发。书籍中成体系的知识能够为自己在技术道路上的准备打下坚实的内功基础，我也深深意识到光靠老师的PPT糊弄过考试并不是真正掌握知识。所以，阅读是不可或缺的准备手段；同时，结合实践去提升自己的“硬实力”也是不可或缺的。职业道路的规划将是通过不断探索，获取关于感兴趣职业尽可能多的信息，有目的地进行求职准备，当然在这之前要面临争夺研究生资格的求学道路；因为性格内向的原因，社会道路的规划对我来说有一定难度，目前所能做的只有强迫自己去参与交流，走出自己的社交舒适圈，接触更多有趣有才的人。</p>
<p><br></p>
<h2 id="3-2-你对于实现自己的梦想已经做了或者计划做什么样的准备？"><a href="#3-2-你对于实现自己的梦想已经做了或者计划做什么样的准备？" class="headerlink" title="3.2 你对于实现自己的梦想已经做了或者计划做什么样的准备？"></a>3.2 你对于实现自己的梦想已经做了或者计划做什么样的准备？</h2><p>　　如上一个问题中所述，同时还要在试错的过程中找到自己擅长的、感兴趣的方向。</p>
<p><br></p>
<h2 id="3-3-你们马上就要面临实习了，你打算在企业内实习还是在实验室实习？"><a href="#3-3-你们马上就要面临实习了，你打算在企业内实习还是在实验室实习？" class="headerlink" title="3.3 你们马上就要面临实习了，你打算在企业内实习还是在实验室实习？"></a>3.3 你们马上就要面临实习了，你打算在企业内实习还是在实验室实习？</h2><p>　　我打算在企业内实习。据了解到的信息，实验室实习是给出课题进行研究，以发论文为目标，而企业实习是参与到项目中，锻炼实际解决问题的能力。因为大学学习阶段，知识都停留在书本，我更希望体验知识所带来的实际影响力，这点企业实习能够提供更好的平台。</p>
<p><br></p>
<h2 id="3-4-实习经验究竟有多重要？是否需要马上开始积累实习经验？"><a href="#3-4-实习经验究竟有多重要？是否需要马上开始积累实习经验？" class="headerlink" title="3.4 实习经验究竟有多重要？是否需要马上开始积累实习经验？"></a>3.4 实习经验究竟有多重要？是否需要马上开始积累实习经验？</h2><p>　　这点我没有发言权，因为我从未在企业或实验室中实习过，但我认为应该是十分重要的，因为能够了解到课堂以外的知识和领域内研究热点或技术热点。是否需要马上开始累积实习经验还要看个人情况，学院的课程压力比较大，我认为应该在基础扎实的情况下参与实习，而这也是我没有参加实习的原因，但我认为应该要尽快了。</p>
<p><br></p>
<h1 id="四、写在最后"><a href="#四、写在最后" class="headerlink" title="四、写在最后"></a>四、写在最后</h1><p>　　趁着这个机会回顾了自己走上计算机这条路的前前后后，感触良多。在迷雾中来回穿行，反反复复地问自己：这条路走对了吗？你的能力足够吗？你足够感兴趣吗？…翻阅过许多人的思考，阅读过许多名人的经历，乔布斯对科技与艺术的追求让我仰慕不已，即使他是个古怪的人，也许天才都比较古怪吧；Paul Graham拿到计算机博士学位后，远赴欧洲学习绘画，为“解决收入问题”创业，达成目的后又成立创业孵化公司，影响更多的人。</p>
<p>　　然而我的迷茫始终都在，导致在探索的过程浪费了许多精力，甚至失去探索的动力。这一次思考点醒我的是，总结与规划十分重要，它提醒我不应驻足现状，受限与迷茫，而应理清困惑，回顾总结，做好规划并继续前行，永远不停止思考。</p>
]]></content>
      <categories>
        <category>SoftWareEngineering</category>
      </categories>
      <tags>
        <tag>CourseHomework</tag>
      </tags>
  </entry>
  <entry>
    <title>结对项目作业-Intersect+GUI</title>
    <url>/2020/03/23/%E7%BB%93%E5%AF%B9%E9%A1%B9%E7%9B%AE%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>本作业属于北航 2020 年春软件工程</td>
<td><a href="https://edu.cnblogs.com/campus/buaa/BUAA_SE_2019_LJ" target="_blank" rel="noopener">博客园班级连接</a></td>
</tr>
<tr>
<td>本作业是本课程个人项目作业</td>
<td><a href="https://edu.cnblogs.com/campus/buaa/BUAA_SE_2020_LJ/homework/10429" target="_blank" rel="noopener">作业要求</a></td>
</tr>
<tr>
<td>我在这个课程的目标是</td>
<td>提高软件开发能力、团队协作能力</td>
</tr>
<tr>
<td>这个作业在哪个具体方面帮助我实现目标</td>
<td>增加协作开发经验</td>
</tr>
<tr>
<td>项目代码</td>
<td><a href="https://github.com/btapple/Intersect" target="_blank" rel="noopener">https://github.com/btapple/Intersect</a></td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<p><br></p>
<h2 id="一、需求分析与UML图"><a href="#一、需求分析与UML图" class="headerlink" title="一、需求分析与UML图"></a>一、需求分析与UML图</h2><p>　　与上一次的个人项目作业相类似，本次的任务关键在于交点的求解。至于新需求“交点绘制”，是简单扩展，实际上是将每个交点的坐标反馈到用户。</p>
<p>　　本次任务增加了两种图形：线段与射线，它们都是特殊的直线。为什么是特殊的“直线”呢？因为本质上，这两种图形都是将无限长直线进行截断而形成的。</p>
<p>　　由于这种性质，我们不难发现，整体的求解过程几乎没有改变。上一次的求解划分方法抄录如下</p>
<ul>
<li>直线与直线<ul>
<li>平行：交点个数 0</li>
<li>同一条直线：交点个数无限</li>
<li>相交：交点个数 1</li>
</ul>
</li>
<li>直线与圆<ul>
<li>相离：交点个数 0</li>
<li>相切：交点个数 1</li>
<li>相交：交点个数 2</li>
</ul>
</li>
<li>圆与圆<ul>
<li>相离：交点个数 0</li>
<li>相切：交点个数 1</li>
<li>相交：交点个数 2</li>
<li>内含：交点个数 0</li>
</ul>
</li>
</ul>
<p>　　但是，射线与线段毕竟不是直线，因此我们需要考虑因截断带来的影响，即所求得的交点是否在图形上。而求解交点的过程，依旧是参见 Paul Bourke 先生的<a href="http://paulbourke.net/geometry/circlesphere/" target="_blank" rel="noopener">文章</a>。</p>
<p>　　除此以外，我们还需要考虑射线与线段之间的新的交点，即端点的重合。</p>
<p>UML图如下：</p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/03/b40b4c697fbedfce.png" alt=""></p>
<h2 id="二、接口设计与实现"><a href="#二、接口设计与实现" class="headerlink" title="二、接口设计与实现"></a>二、接口设计与实现</h2><h3 id="Information-Hiding，Interface-Design，Loose-Coupling"><a href="#Information-Hiding，Interface-Design，Loose-Coupling" class="headerlink" title="Information Hiding，Interface Design，Loose Coupling"></a>Information Hiding，Interface Design，Loose Coupling</h3><p>　　我们本次的接口设计依照了Imformation Hiding（信息隐藏）原则与Loose Coupling（松耦合）原则，体现在通过一个特定的管理器指针与调用方互动，不会涉及类成员的修改，保证信息的隐藏；通信的参数都是基本类型参数，双方不必为各自的实现考虑，保证松耦合特性。</p>
<h3 id="Design-by-Contract，Code-by-Contract"><a href="#Design-by-Contract，Code-by-Contract" class="headerlink" title="Design by Contract，Code by Contract"></a>Design by Contract，Code by Contract</h3><p>　　Design by Contract，契约式设计，其强调前置条件、后置条件与不变式，是一种形式约束。DbC的优点正如它的初衷，能够保证程序正确，它是一种形式逻辑上的正确，而不是测试之后得出的正确率，所以非常可靠，但其缺点是使得代码臃肿、工作量增大。OO课程中有一个单元练习的JML体现的便是这种思想，当程序复杂时带来的约束编写的工作量也会成倍增加。Code By Contract也是同样的道理，按照约束编写能够保证可靠，但是强行依照断言编写程序会造成代码的冗余和复杂，且如果约束复杂，也会增加理解交流的成本，降低效率。</p>
<p>本次结对项目中，我们没有过多使用Contract这种理念，而是在需求分析时确定应有的约束，保证项目“敏捷”地进行下去。</p>
<h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><p>　　考虑到我们所要编写的库需要面对的环境是未知的，即不清楚会被什么语言以什么形式调用，因此我们选择了最广泛的 C 形式。我们希望，调用语言只要能够获取变量的地址，就能顺利地调用我们的库。具体的接口如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下的 CORE_API 均是 __declspec(dllexport)，声明将要在 dll 中导出</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">CORE_API GraphManager * <span class="title">create_graph_manager</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">CORE_API <span class="keyword">int</span> <span class="title">add_line</span><span class="params">(GraphManager*, <span class="keyword">char</span>*, Type, INTTYPE, INTTYPE, INTTYPE, INTTYPE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">CORE_API <span class="keyword">int</span> <span class="title">add_circle</span><span class="params">(GraphManager*, <span class="keyword">char</span>*, Type, INTTYPE, INTTYPE, INTTYPE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">CORE_API <span class="keyword">void</span> <span class="title">remove_graph</span><span class="params">(GraphManager*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">CORE_API <span class="keyword">int</span> <span class="title">calculate_intersect</span><span class="params">(GraphManager*, <span class="keyword">char</span>*, INTTYPE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">CORE_API <span class="keyword">int</span> <span class="title">fetch_intersect</span><span class="params">(GraphManager*, <span class="keyword">char</span>*, FLOATTYPE*, FLOATTYPE*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">CORE_API <span class="keyword">void</span> <span class="title">clear_manager</span><span class="params">(GraphManager*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">CORE_API <span class="keyword">void</span> <span class="title">dispose_graph_manager</span><span class="params">(GraphManager*)</span></span>;</span><br></pre></td></tr></table></figure>
<p>各个接口分别的作用是：</p>
<ul>
<li><code>create_graph_manager</code>：创建 GraphManager</li>
<li><code>add_line</code>：向指定的 GraphManager 添加一条线（可能是直线、线段或射线，由 Type 指定）</li>
<li><code>add_circle</code>：向指定的 GraphManager 添加一个圆</li>
<li><code>remove_graph</code>：从指定的 GraphManager 中删除一个图形</li>
<li><code>calculate_intersect</code>：计算指定的 GraphManager 中所管理的图形的交点</li>
<li><code>fetch_intersect</code>：从指定的 GraphManager 中获取交点信息</li>
<li><code>clear_manager</code>：清空指定的 GraphManager</li>
<li><code>dispose_graph_manager</code>:销毁指定的 GraphManager</li>
</ul>
<h3 id="性能分析与改进"><a href="#性能分析与改进" class="headerlink" title="性能分析与改进"></a>性能分析与改进</h3><p>性能分析结果：</p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/03/04768924de774c46.png" alt=""></p>
<p>其中消耗最大的函数是求交点函数<code>calculate_intersect</code>：</p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/03/9192074929613e95.png" alt=""></p>
<p>　　由于改进的切入点只有交点计算的算法改进，而计算的算法没有稳定改进办法，所以性能改进上处理不多。</p>
<h2 id="三、异常处理"><a href="#三、异常处理" class="headerlink" title="三、异常处理"></a>三、异常处理</h2><p>　　这一部分是接口设计的后续内容。</p>
<p>　　异常处理是必要的，因为我们无法假设调用方的调用方式，否则调用方与被调用方将存在一定的非必要的耦合关系。</p>
<p>以下面这个接口为例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">CORE_API <span class="keyword">int</span> <span class="title">add_line</span><span class="params">(GraphManager* gm, <span class="keyword">char</span>* msg, Type type, INTTYPE x1, INTTYPE y1, INTTYPE x2, INTTYPE y2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>　　调用方在尝试调用这个接口之前，对内部实现没有了解，不清楚直线各个参数的限制（当然，库文档一般会提供，我们假设文档中没有注明），那么可能会错误地提供了两个相同的点，或者超过限制范围的坐标值等等，这些都是需要反馈的。</p>
<p>　　那么，问题就在于如何反馈异常。首先，不可能抛异常（尽管我们的库是使用 C++编写的，具有抛异常能力），不同的语言与环境的异常模型未必相同，调用方不一定能够完成异常的处理。我们依旧需要一个通用的做法，选择返回错误信息的长度与错误信息的指针（对于本接口，返回值即错误信息长度，msg 用于存储错误信息的指针），如果错误信息的长度为 0，意味着没有异常发生，这里同样只有基本类型的参与。</p>
<p>根据需求，我们设计了以下几种异常类型：</p>
<ul>
<li>直线两点重合</li>
<li>输入参数的大小不在限定范围内</li>
<li>圆半径为负</li>
<li>在计算交点之前就尝试获取交点信息</li>
<li>无交点却尝试获取交点信息</li>
<li>输入数据中具有重合或重复的图形</li>
</ul>
<p>　　对于最后一种情况，即会产生“无限多交点”的情况，我们容许它的发生，会以警告的形式反馈给用户，但是会将发生重合的图形连接成为一个图形进行计算。</p>
<h2 id="四、单元测试"><a href="#四、单元测试" class="headerlink" title="四、单元测试"></a>四、单元测试</h2><p>  先展示覆盖情况（使用 OpenCPPCoverage 生成）</p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/03/0e62fd435ee54034.png" alt=""></p>
<p>  测试的框架如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> main_ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> test_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> test_pass = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT_EQ_BASE(equality, expect, actual) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;\</span><br><span class="line">        test_count++;\</span><br><span class="line">        <span class="keyword">if</span> (equality)\</span><br><span class="line">            test_pass++;\</span><br><span class="line">        <span class="keyword">else</span> &#123;\</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">": expect: "</span> &lt;&lt; expect &lt;&lt; <span class="string">" actual: "</span> &lt;&lt; actual &lt;&lt; <span class="string">"\n"</span>; \</span><br><span class="line">            main_ret = <span class="number">1</span>;\</span><br><span class="line">        &#125;\</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT_EQ(expect, actual) EXPECT_EQ_BASE((expect) == (actual), expect, actual)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT_TRUE(actual) EXPECT_EQ_BASE((actual) != 0, <span class="meta-string">"true"</span>, <span class="meta-string">"false"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT_FALSE(actual) EXPECT_EQ_BASE((actual) == 0, <span class="meta-string">"false"</span>, <span class="meta-string">"true"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gm_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> gm = create_graph_manager();</span><br><span class="line">    ... <span class="comment">// 测试项目</span></span><br><span class="line">    dispose_graph_manager(gm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gm_test();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d/%d (%3.2f%%) passed\n"</span>, test_pass, test_count, test_pass * <span class="number">100.0</span> / test_count);</span><br><span class="line">    <span class="keyword">return</span> main_ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  测试项目有功能性测试和异常测试。</p>
<p>  首先是功能性测试，以测试两圆外切情况为例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">clear_manager(gm);                              <span class="comment">// 首先清空 GraghManager</span></span><br><span class="line">add_circle(gm, <span class="literal">nullptr</span>, Type::circle, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 加入一个圆，用空指针接收错误信息可以及时发现异常的发生</span></span><br><span class="line">add_circle(gm, <span class="literal">nullptr</span>, Type::circle, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 加入另一个圆</span></span><br><span class="line">EXPECT_EQ(<span class="number">1</span>, calculate_intersect(gm));          <span class="comment">// 计算交点数并进行比较</span></span><br></pre></td></tr></table></figure>
<p>　　测试数据的构造会考虑正负零以及在数据范围附近的情况(-100000, 100000)，分类的依据可见需求分析。</p>
<p>  然后是异常测试，大致如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两点重合</span></span><br><span class="line">clear_manager(gm);</span><br><span class="line">EXPECT_TRUE(add_line(gm, msg, Type::line_segment, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &gt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 超出数据范围</span></span><br><span class="line">clear_manager(gm);</span><br><span class="line">EXPECT_TRUE(add_line(gm, msg, Type::line_segment, <span class="number">10000000</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &gt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 超出数据范围</span></span><br><span class="line">clear_manager(gm);</span><br><span class="line">EXPECT_TRUE(add_line(gm, msg, Type::line_segment, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-10000000</span>) &gt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 超出数据范围</span></span><br><span class="line">clear_manager(gm);</span><br><span class="line">EXPECT_TRUE(add_circle(gm, msg, Type::circle, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-10000000</span>) &gt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 半径为负</span></span><br><span class="line">clear_manager(gm);</span><br><span class="line">EXPECT_TRUE(add_circle(gm, msg, Type::circle, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1000</span>) &gt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 计算交点前获取交点信息</span></span><br><span class="line">clear_manager(gm);</span><br><span class="line">EXPECT_TRUE(fetch_intersect(gm, msg, &amp;x, &amp;y) &gt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 无交点获取交点信息</span></span><br><span class="line">calculate_intersect(gm, msg, &amp;point_num);</span><br><span class="line">EXPECT_TRUE(fetch_intersect(gm, msg, &amp;x, &amp;y) &gt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 输入数据中具有重合或重复的图形</span></span><br><span class="line">add_circle(gm, <span class="literal">nullptr</span>, Type::circle, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">add_circle(gm, <span class="literal">nullptr</span>, Type::circle, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">EXPECT_TRUE(calculate_intersect(gm, msg, &amp;point_num) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="五、UI设计及与计算模块的对接"><a href="#五、UI设计及与计算模块的对接" class="headerlink" title="五、UI设计及与计算模块的对接"></a>五、UI设计及与计算模块的对接</h2><p>　　界面模块我们选取的开发框架是WPF，开发语言为C#。由于项目给出的界面模块需求为几何对象的文件导入、增删、绘制与交点求解，这些需求都可以通过按钮点击事件完成，故界面模块的总体设计为：上方用画板展示绘制内容，下方排布按钮进行控制。完成后的初始界面如下：</p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/03/b47965a4122cdf51.png" alt=""></p>
<h3 id="画布设计"><a href="#画布设计" class="headerlink" title="画布设计"></a>画布设计</h3><p>　　画布设计又分为坐标网格的绘制与几何图形的绘制，下面解释二者的实现细节。</p>
<p>　　坐标轴的绘制比较简单，只需在画布中央画两条直线，其中y轴的两端为画布上下边界的中点，x轴的两端为画布左右边界的中点。而坐标网格的绘制其实也只是坐标轴绘制的一个加强版，横纵线交错即为网格；坐标的绘制通过<code>TextBlock</code>实现。下面是展示沿X轴方向的坐标网格和坐标的绘制，y轴同理翻转即可。</p>
<h3 id="几何对象绘制设计"><a href="#几何对象绘制设计" class="headerlink" title="几何对象绘制设计"></a>几何对象绘制设计</h3><p>　　几何对象的绘制分为线绘制和圆形绘制，其中线绘制又分为无限长直线、射线和线段。</p>
<p>　　<strong>线绘制</strong>最为麻烦，因为WPF框架中给出的现有方法只支持绘制线段，不支持无限长直线。我们对于无限长直线和射线的实现办法为：添加边界点。边界点的求法为：令横坐标x为INF_X（这里取INF_X为画布宽度的一半，也就是把画布放到二维坐标系的中心时的边界值），利用直线方程求出y。需要考虑平行于坐标轴的情况，下方代码不再赘述:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// input: x1, y1, x2, y2</span></span><br><span class="line"><span class="keyword">double</span> A = y2 - y1, B = x1 - x2, C = x2 * y1 - x1 * y2;</span><br><span class="line"><span class="keyword">double</span> edge_x1, edge_x2, edge_y1, edge_y2;  <span class="comment">// 1为边界起点，2为边界终点</span></span><br><span class="line"><span class="keyword">double</span> INFX = frame_width / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x2 &lt; x1)</span><br><span class="line">&#123;</span><br><span class="line">    edge_x1 = INFX;</span><br><span class="line">    edge_x2 = -INFX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    edge_x1 = -INFX;</span><br><span class="line">    edge_x2 = INFX;</span><br><span class="line">&#125;</span><br><span class="line">edge_y1 = (-C - A * edge_x1) / B;</span><br><span class="line">edge_y2 = (-C - A * edge_x2) / B;</span><br></pre></td></tr></table></figure>
<p>　　之后即可根据线对象的类型进行绘制。需要注意的是，之前在二维坐标系中进行计算，最后绘制时应将点坐标转换到画布的坐标系（也就是二维坐标系沿x轴翻转后取第四象限）中去:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Point start;</span><br><span class="line">Point end;</span><br><span class="line"><span class="keyword">switch</span> (type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> Type.infinite_line:    <span class="comment">// 无限长直线</span></span><br><span class="line">        start = convert_point(edge_x1, edge_y1);</span><br><span class="line">        end = convert_point(edge_x2, edge_y2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Type.line_segment:     <span class="comment">// 射线</span></span><br><span class="line">        start = convert_point(x1, y1);</span><br><span class="line">        end = convert_point(edge_x2, edge_y2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Type.segment: <span class="keyword">default</span>:    <span class="comment">// 线段</span></span><br><span class="line">        start = convert_point(x1, y1);</span><br><span class="line">        end = convert_point(x2, y2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LineGeometry line = <span class="keyword">new</span> LineGeometry();</span><br><span class="line">line.StartPoint = start;</span><br><span class="line">line.EndPoint = end;</span><br><span class="line"></span><br><span class="line">Path path = <span class="keyword">new</span> Path();</span><br><span class="line">path.Stroke = Brushes.Black;</span><br><span class="line">path.StrokeThickness = <span class="number">1</span>;</span><br><span class="line">path.Data = line;</span><br><span class="line"></span><br><span class="line">mainPanel.Children.Add(path);</span><br></pre></td></tr></table></figure>
<p><code>convert_point</code>的代码如下：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Point <span class="title">convert_point</span>(<span class="params"><span class="keyword">double</span> x, <span class="keyword">double</span> y</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Point(x * SCALE + x_offset, -y * SCALE + y_offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　<strong>圆形与坐标点</strong>的绘制可以使用WPF提供的<code>EllipseGeometry</code>（椭圆）类。二者区别只有空心实心和半径大小，下面给出坐标点的绘制方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// input: x, y</span></span><br><span class="line">Point p = convert_point(x, y);</span><br><span class="line">EllipseGeometry el = <span class="keyword">new</span> EllipseGeometry();</span><br><span class="line"><span class="keyword">int</span> pointR = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">el.RadiusX = pointR;</span><br><span class="line">el.RadiusY = pointR;</span><br><span class="line">el.Center = p;</span><br><span class="line"></span><br><span class="line">Path path = <span class="keyword">new</span> Path();</span><br><span class="line">path.Stroke = Brushes.Black;</span><br><span class="line">path.StrokeThickness = <span class="number">2</span>;</span><br><span class="line">path.Fill = Brushes.Black;</span><br><span class="line">path.Data = el;</span><br><span class="line"></span><br><span class="line">mainPanel.Children.Add(path);</span><br><span class="line">intersections.Add(path);</span><br></pre></td></tr></table></figure>
<h3 id="按钮设计"><a href="#按钮设计" class="headerlink" title="按钮设计"></a>按钮设计</h3><p>按钮的功能设计如下：</p>
<ul>
<li><code>Files</code>：从文件导入几何对象的描述<strong>并绘制</strong>（不独立设置“绘制”按钮是为了更直观地展示输入的几何对象，避免用户进行重复冗余的点击操作，下面的增添/删除按钮也贯彻了这一理念）。</li>
<li><code>Intersect</code>：求解现有几何对象的交点并绘制。</li>
<li><code>Delete</code>：选择某一个几何对象，将其从画布上删除，并删除画布中的<strong>所有交点</strong>。</li>
<li><code>Add</code>：根据选择的类型及输入增添一个几何对象，并在画布上画出。</li>
<li><code>Clear</code>：清空画布上所有的几何对象及交点</li>
<li><code>Scale+/-</code>：放大/缩小画布的坐标系，将会删除图上所有的几何对象和交点。</li>
</ul>
<p>　　下面展示这些按钮触发事件的实现细节。</p>
<p>　　按钮事件函数的写法为：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button_click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>Files</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dialog = <span class="keyword">new</span> Microsoft.Win32.OpenFileDialog</span><br><span class="line">&#123;</span><br><span class="line">    Filter = <span class="string">".txt|*.txt"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (dialog.ShowDialog(<span class="keyword">this</span>) == <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">string</span> fileName = dialog.FileName;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(fileName);</span><br><span class="line"></span><br><span class="line">drawer.clearAll();      <span class="comment">// 清除画布</span></span><br><span class="line">drawer.DrawXY();        <span class="comment">// 重新绘制坐标轴</span></span><br><span class="line">drawer.ReadGraphFromFile(fileName);</span><br></pre></td></tr></table></figure>
<p> 其中<code>read_graph_from_file()</code>方法的实现流程为：</p>
<ol>
<li>读文件第一行的数字</li>
<li>根据数字按行读取并parse</li>
<li>将parse后获得的几何对象信息输入到<code>core</code>中的计算模块进行添加</li>
<li><p>调用线绘制方法进行绘制</p>
<p>其中还涉及若干错误判断，使用<code>MessageBox.show()</code>报告错误</p>
</li>
</ol>
</li>
<li><p>Intersect</p>
<p> 　　该事件主要调用<code>core</code>中的计算模块，并使用<code>core</code>中实现的取交点函数逐一获取所有交点。</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calc_and_draw_intersects</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 计算交点</span></span><br><span class="line">    <span class="keyword">int</span> r = NativeMethods.calculate_intersect(core_graph_manager, msg, <span class="keyword">ref</span> n);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(msg.ToString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从core中取一个交点坐标</span></span><br><span class="line">        r = NativeMethods.fetch_intersect(core_graph_manager, msg, <span class="keyword">ref</span> x, <span class="keyword">ref</span> y);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; <span class="number">0</span>)  <span class="comment">// 如果有错误信息</span></span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(msg.ToString());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            drawIntersectPoint(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Delete</p>
<p> 　　该事件弹出新窗口（项目中为<code>GraphsWindow</code>），获取当前所有几何对象的信息，并使用<code>ListBox</code>陈列，用户确认选择后分别删除其在<code>ListBox</code>中的描述、画布中的图形以及在<code>core</code>中的对象，并删除所有交点。</p>
<p> 　　画布中删除某一图形的逻辑如下：</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// input： graph id</span></span><br><span class="line"><span class="comment">// remove graoh on Canvas</span></span><br><span class="line">mainPanel.Children.Remove(graphs[id]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove info</span></span><br><span class="line">graphs.Remove(graphs[id]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove points on graph</span></span><br><span class="line">Path[] points = pointsOnGraph[id];</span><br><span class="line"><span class="keyword">foreach</span> (Path point <span class="keyword">in</span> points)</span><br><span class="line">&#123;</span><br><span class="line">    mainPanel.Children.Remove(point);</span><br><span class="line">&#125;</span><br><span class="line">pointsOnGraph.Remove(points);</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove intersections(all)</span></span><br><span class="line"><span class="keyword">foreach</span> (Path intersect <span class="keyword">in</span> intersections)</span><br><span class="line">&#123;</span><br><span class="line">    mainPanel.Children.Remove(intersect);</span><br><span class="line">&#125;</span><br><span class="line">intersections.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove data in core</span></span><br><span class="line">remove_graph(core_graph_manager, id);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Add</p>
<p> 　　弹出新窗口进行几何对象的添加。实现方法是使用<code>ComboBox</code>实现下拉栏选择四种几何对象类型的其中一个，并根据类型的不同给出不同数量的参数输入框（<code>TextBox</code>）。提交输入时进行正确性检测。最后将正确的输入整合为一行，利用按行处理文件输入的方法进行添加处理。</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> wrongMsg = <span class="string">""</span>;</span><br><span class="line">verify_TextInput(tbox1, tblock1, <span class="keyword">ref</span> wrongMsg);</span><br><span class="line">verify_TextInput(tbox2, tblock2, <span class="keyword">ref</span> wrongMsg);</span><br><span class="line">verify_TextInput(tbox3, tblock3, <span class="keyword">ref</span> wrongMsg);</span><br><span class="line"><span class="keyword">if</span> (combo.SelectedIndex != (<span class="keyword">int</span>)ComboItem.C)    <span class="comment">// 圆形没有第四个参数输入框，只有x, y, r</span></span><br><span class="line">&#123;</span><br><span class="line">    verify_TextInput(tbox4, tblock4, <span class="keyword">ref</span> wrongMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wrongMsg.Length != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(wrongMsg);  <span class="comment">// 输入栏的错误提醒</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">string</span> info = combo.Text + <span class="string">" "</span> + tbox1.Text + <span class="string">" "</span> + tbox2.Text + <span class="string">" "</span> + tbox3.Text;</span><br><span class="line">    <span class="keyword">if</span> (combo.SelectedIndex != (<span class="keyword">int</span>)ComboItem.C)</span><br><span class="line">    &#123;</span><br><span class="line">        info += <span class="string">" "</span> + tbox4.Text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        drawer.AddGraphFromLine(info);  <span class="comment">// 添加该行对应的几何对象信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (FormatException)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(<span class="string">"Wrong Format!"</span>);   <span class="comment">// 在执行添加逻辑时的错误报告</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Clear</p>
<p> 　　该事件包括清除画布内容、几何对象所有信息，并重新绘画坐标网格。清除的细节如下：</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">mainPanel.Children.Clear();     <span class="comment">// 清楚画布内容</span></span><br><span class="line">graphs.Clear();                 <span class="comment">// 清楚几何对象绘制信息</span></span><br><span class="line">intersections.Clear();          <span class="comment">// 清除交点绘制信息</span></span><br><span class="line">pointsOnGraph.Clear();          <span class="comment">// 清除几何对象上的点（起点、终点、圆心）的绘制信息</span></span><br><span class="line">graphsInfo.Clear();             <span class="comment">// 清除用于生成ListBox的几何对象信息</span></span><br><span class="line">core_graph_manager = IntPtr.Zero;   <span class="comment">// 清除core中的manager</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Scale+/-</p>
<p> 　　该事件由调整画布尺寸参数<code>SCALE</code>实现。坐标网格绘制中，在绘制垂直x轴的坐标网格的循环语句中，网格密度是根据<code>SCALE</code>来调整的，由此实现画布的尺寸增减：</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = SCALE; i &lt; frame_width/<span class="number">2</span>; i+=SCALE)</span><br></pre></td></tr></table></figure>
<p> 在实现中，用户每点击一次按钮Scale+/-，首先清除画布，<code>SCALE</code>增加/减少<code>5</code>，并进行设定边界，避免无限放大，然后再重新绘制坐标轴。</p>
<p> 如下是实现的大致逻辑</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (SCALE &gt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">"Reach Max Scale"</span>, <span class="string">"Note"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">clear_all();</span><br><span class="line">SCALE += <span class="number">5</span>;</span><br><span class="line">drawXY();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="六、界面模块与计算模块的对接"><a href="#六、界面模块与计算模块的对接" class="headerlink" title="六、界面模块与计算模块的对接"></a>六、界面模块与计算模块的对接</h2><blockquote>
<p>11.界面模块与计算模块的对接。详细地描述 UI 模块的设计与两个模块的对接，并在博客中截图实现的功能。（4’）</p>
</blockquote>
<p>　　计算模块生成动态链接库提供，由于界面模块使用的是WPF框架及C#进行开发，可以通过<code>DLLImport</code>语句可以导入dll中的接口进行使用。</p>
<p>　　在界面模块中导入接口函数的语句如下：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">"core.dll"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">create_graph_manager</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">"core.dll"</span>, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add_line</span>(<span class="params">IntPtr gm, StringBuilder msg, <span class="keyword">int</span> type, <span class="keyword">long</span> x1, <span class="keyword">long</span> y1, <span class="keyword">long</span> x2, <span class="keyword">long</span> y2</span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">"core.dll"</span>, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add_circle</span>(<span class="params">IntPtr gm, StringBuilder msg, <span class="keyword">int</span> type, <span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span> r</span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">"core.dll"</span>, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">calculate_intersect</span>(<span class="params">IntPtr gm, StringBuilder msg, <span class="keyword">ref</span> <span class="keyword">long</span> res</span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">"core.dll"</span>, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">fetch_intersect</span>(<span class="params">IntPtr gm, StringBuilder msg, <span class="keyword">ref</span> <span class="keyword">double</span> x, <span class="keyword">ref</span> <span class="keyword">double</span> y</span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">"core.dll"</span>, CallingConvention = CallingConvention.Cdecl)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">remove_graph</span>(<span class="params">IntPtr gm, <span class="keyword">long</span> id</span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">"core.dll"</span>, CallingConvention = CallingConvention.Cdecl)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">dispose_graph_manager</span>(<span class="params">IntPtr gm</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>　　为了达到松耦合的条件，界面模块中不涉及计算模块的类操作。通过<code>IntPtr</code>型的计算模块管理器对接各个接口。如初始时创建新的计算模块管理器：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">IntPtr graph_manager = create_graph_manager();</span><br></pre></td></tr></table></figure></p>
<p>　　之后在添加一条直线，根据输入得到的类型及坐标，即可如下添加一条直线：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">add_Line(graph_manager, msg, type, x1, y1, x2, y2);</span><br></pre></td></tr></table></figure></p>
<p>　　其中msg用于获取计算模块的错误信息，通过<code>MessageBox</code>报告给用户。</p>
<p>实现的功能如下：</p>
<ol>
<li>从文件中读取几何图形信息并画出（Files按钮）<br> <img src="https://ftp.bmp.ovh/imgs/2020/03/36bcc78b111ef97c.png" alt=""><br> <img src="2020-03-21-22-08-58.png" alt=""></li>
<li>求交点并画出（Intersect按钮）<br> <img src="https://ftp.bmp.ovh/imgs/2020/03/ae33598ccb004878.png" alt=""></li>
<li>删除一个几何图形（Delete按钮）<br> <img src="https://ftp.bmp.ovh/imgs/2020/03/797e79851cd56e05.png" alt=""><br> <img src="https://i.loli.net/2020/03/22/ICX3lvSDOEfuHdP.png" alt="2020-03-21-22-12-26.png"></li>
<li>增添一个几何图形（Add按钮）<br> <img src="https://ftp.bmp.ovh/imgs/2020/03/16f74e3beb9fe9b6.png" alt=""><br> <img src="https://ftp.bmp.ovh/imgs/2020/03/4687048e0a0cd790.png" alt=""></li>
<li>清空画布（Clear按钮）<br> <img src="https://ftp.bmp.ovh/imgs/2020/03/90c5282fcf31017b.png" alt=""><br> <img src="https://ftp.bmp.ovh/imgs/2020/03/175c22ae53049122.png" alt=""></li>
<li>画布尺寸增减（将会删除图形）<ul>
<li>Scale+按钮<br><img src="https://ftp.bmp.ovh/imgs/2020/03/ba049f016c444dad.png" alt=""></li>
<li>Scale-按钮<br><img src="https://ftp.bmp.ovh/imgs/2020/03/f3514c624dce1256.png" alt=""></li>
</ul>
</li>
</ol>
<h2 id="七、结对编程过程"><a href="#七、结对编程过程" class="headerlink" title="七、结对编程过程"></a>七、结对编程过程</h2><p>　　我们采用的结对编程方式是Live Share+语音，其中存在的问题，一方面是live share本身的不稳定，对方的修改可能经过一定延迟才能看到；另一方面是，互相不太了解可能产生一定的阻碍。但结对编程也带来一定好处，比如能够学习到队友比较良好的代码规范和新颖的编码技巧，并且有人一起review也减少了错误的产生，遇到比较纠结的问题时也能够通过沟通找到答案。队友在编码规范、设计能力以及项目管理等方面都很优秀，在交流中也能够精准地给出解答的方向，有时我可能会跟不上。我在此次项目中也用心、勤奋、认真地参与其中，但是对于代码规范、版本管理等细节问题还存在缺陷。</p>
<p>讨论图形界面时：</p>
<p><img src="https://i.loli.net/2020/03/22/dLxQ9oleyg24vPs.png" alt="2020-03-22-21-44-34.png"></p>
<p>讨论模块对接时：</p>
<p><img src="https://i.loli.net/2020/03/22/wuHMEjmPcl5yv4D.png" alt="2020-03-22-21-44-51.png"></p>
<h2 id="八、PSP表格"><a href="#八、PSP表格" class="headerlink" title="八、PSP表格"></a>八、PSP表格</h2><blockquote>
<p>2.在开始实现程序之前，在下述 PSP 表格记录下你估计将在程序的各个模块的开发上耗费的时间。（0.5’）</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>PSP2.1</th>
<th>Personal Software Process Stages</th>
<th>预估耗时（分钟）</th>
<th>实际耗时（分钟）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Planning</td>
<td>计划</td>
<td></td>
<td></td>
</tr>
<tr>
<td>· Estimate</td>
<td>估计这个任务需要多少时间</td>
<td>30</td>
<td>30</td>
</tr>
<tr>
<td>Development</td>
<td>开发</td>
<td></td>
<td></td>
</tr>
<tr>
<td>· Analysis</td>
<td>需求分析 (包括学习新技术)</td>
<td>120</td>
<td>240</td>
</tr>
<tr>
<td>· Design Spec</td>
<td>生成设计文档</td>
<td>30</td>
<td>30</td>
</tr>
<tr>
<td>· Design Review</td>
<td>设计复审 (和同事审核设计文档)</td>
<td>20</td>
<td>20</td>
</tr>
<tr>
<td>· Coding Standard</td>
<td>代码规范 (为目前的开发制定合适的规范)</td>
<td>10</td>
<td>5</td>
</tr>
<tr>
<td>· Design</td>
<td>具体设计</td>
<td>60</td>
<td>60</td>
</tr>
<tr>
<td>· Coding</td>
<td>具体编码</td>
<td>120</td>
<td>240</td>
</tr>
<tr>
<td>· Code Review</td>
<td>代码复审</td>
<td>30</td>
<td>60</td>
</tr>
<tr>
<td>· Test</td>
<td>测试（自我测试，修改代码，提交修改）</td>
<td>60</td>
<td>120</td>
</tr>
<tr>
<td>Reporting</td>
<td>报告</td>
<td></td>
<td></td>
</tr>
<tr>
<td>· Test Report</td>
<td>测试报告</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>· Size Measurement</td>
<td>计算工作量</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>· Postmortem &amp; Process Improvement Plan</td>
<td>事后总结, 并提出过程改进计划</td>
<td>60</td>
<td>30</td>
</tr>
<tr>
<td></td>
<td>合计</td>
<td>560</td>
<td>855</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>SoftWareEngineering</category>
      </categories>
      <tags>
        <tag>CourseHomework</tag>
      </tags>
  </entry>
  <entry>
    <title>《代码大全（第2版）》Part 1：打好基础</title>
    <url>/2020/03/18/Code_Complete_part_1/</url>
    <content><![CDATA[<h2 id="1-欢迎进入软件构建的世界"><a href="#1-欢迎进入软件构建的世界" class="headerlink" title="1 欢迎进入软件构建的世界"></a>1 欢迎进入软件构建的世界</h2><h3 id="1-1-什么是软件构建"><a href="#1-1-什么是软件构建" class="headerlink" title="1.1 什么是软件构建"></a>1.1 什么是软件构建</h3><p>　　构建就是软件工程中“编码”的那一部分，关心的是程序的实现与可行。构建活动主要是编码与调试，但也涉及详细设计、规划构建、单元测试、集成等其他活动。</p>
<a id="more"></a>
<blockquote>
<p>构建活动中的具体任务：</p>
<ul>
<li>验证有关基础工作是否完成</li>
<li>确定如何测试所写代码</li>
<li>设计并编写类和子程序</li>
<li>创建并命名变量和常</li>
<li>选择控制结构、组织语句块</li>
<li>单元测试与集成测试</li>
<li>评审设计与代码</li>
<li>集成</li>
<li>调整代码、性能优化</li>
</ul>
</blockquote>
<h3 id="1-2-软件构建为何如此重要"><a href="#1-2-软件构建为何如此重要" class="headerlink" title="1.2 软件构建为何如此重要"></a>1.2 软件构建为何如此重要</h3><p>　　作者给出以下几个论点（其实也是我们所熟知的）</p>
<ul>
<li>构建活动是软件开发的主要组成部分</li>
<li>构建活动是软件开发中的核心活动</li>
<li>主要精力集中于构建可提高生产率</li>
<li>构建活动的产物——源代码往往是对软件唯一精确的描述</li>
<li>构建活动是唯一一项确保会完成的工作</li>
</ul>
<h3 id="1-3-如何阅读本书"><a href="#1-3-如何阅读本书" class="headerlink" title="1.3 如何阅读本书"></a>1.3 如何阅读本书</h3><p>　　参考原书，不赘述</p>
<h2 id="2-用隐喻来更充分地理解软件开发"><a href="#2-用隐喻来更充分地理解软件开发" class="headerlink" title="2 用隐喻来更充分地理解软件开发"></a>2 用隐喻来更充分地理解软件开发</h2><p>　　本章介绍了隐喻的重要性、隐喻的启发作用以及常用的软件隐喻。</p>
<h3 id="2-1-隐喻的重要性"><a href="#2-1-隐喻的重要性" class="headerlink" title="2.1 隐喻的重要性"></a>2.1 隐喻的重要性</h3><p>　　作者用一些科学发展事迹来表达隐喻的重要性，如基于“撞球”模型提出的气体分子运动、伽利略观察挂在绳子上的小球提出钟摆模型等等。这里的“隐喻”与“建模”、“抽象化”意思相近。</p>
<blockquote>
<ul>
<li>隐喻是对概念进行内在化（internalizing）和抽象化(abstracting)的一种途径。——Fernando J. Corbato</li>
<li>科学发展的历史并不是从一系列”错误“的隐喻到”正确“的隐喻的转变，而是一些列从”不太合适“的隐喻到”更好“的隐喻的转变</li>
</ul>
</blockquote>
<h3 id="2-2-如何使用软件隐喻"><a href="#2-2-如何使用软件隐喻" class="headerlink" title="2.2 如何使用软件隐喻"></a>2.2 如何使用软件隐喻</h3><p>　　这一节主要讲软件中要怎么使用隐喻，并论述了算法与启发式方法的区别。我的理解是：编程中的问题很独特，没办法用“一个模型”去描述编程中遇到的所有问题，所以隐喻只能起到“启发”的作用，帮助发现问题的突破口。</p>
<blockquote>
<p><strong>算法</strong>直接给你解决问题的指导，而<strong>启发式方法</strong>则告诉你该如何发现这些指导信息，或者至少到哪里去寻找它们。</p>
</blockquote>
<h3 id="2-3-常见的软件隐喻"><a href="#2-3-常见的软件隐喻" class="headerlink" title="2.3 常见的软件隐喻"></a>2.3 常见的软件隐喻</h3><p>　　作者列举了常用的软件开发隐喻，由浅到深依次是：写作-培植-生长-建造。最后肯定了“建造”这一种隐喻并提出大量“建造”与软件开发的类比作为作证，比如“决定建什么样的房子”对应软件中的问题定义；“和某个建筑师探讨总体设计”对应架构设计；“准备建造地点、打地基、搭建房屋框架、砌墙砌瓦等”对应软件中的构建等等。但作者也说了，隐喻毕竟是启发式方法，个人可以有自己的见解，只要它能激发自己的思维灵感。当然，不当的隐喻可能会让你误入歧途。</p>
<h2 id="3-三思而后行：前期准备"><a href="#3-三思而后行：前期准备" class="headerlink" title="3 三思而后行：前期准备"></a>3 三思而后行：前期准备</h2><p>　　需求、架构这些前期准备非常重要。明确要做的准备工作、明确这些工作是否达标，能够有效减小后期解决问题的代价</p>
<h3 id="3-1-前期准备的重要性"><a href="#3-1-前期准备的重要性" class="headerlink" title="3.1 前期准备的重要性"></a>3.1 前期准备的重要性</h3><p>　　本节作者分析了无法做前器准备的原因，并讲述“老板不认可前期准备”时的说服办法，其实也在试图告诉我们前期准备有多重要。</p>
<blockquote>
<ul>
<li>程序员时软件食物链的最后一环。架构师吃掉需求，设计师吃掉架构，而程序员则消化设计</li>
<li>缺陷在软件食物链里面呆的时间越长，它对食物链的后级造成损害就越严重</li>
</ul>
</blockquote>
<h3 id="3-2-辨明你所从事的软件的类型"><a href="#3-2-辨明你所从事的软件的类型" class="headerlink" title="3.2 辨明你所从事的软件的类型"></a>3.2 辨明你所从事的软件的类型</h3><p>　　本节对比了软件开发的两种类型：迭代式方法和序列式方法。迭代式方法的特点是：边走边看（as-you-go，走着瞧），适用于需求理解不透彻、模糊、有挑战性、不熟悉、风险大的项目；序列式方法的特点是：各个流程按部就班，适用于需求稳定、团队对这一领域熟悉、风险小的项目。此外，本节还介绍了有无前期准备对这两种开发流程的影响。</p>
<blockquote>
<p>开发商业系统的项目往往受益于<strong>高度迭代的开发法</strong>，这种方法的“计划、需求、架构”活动与“构建、系统测试、质量保证”活动交织在一起。性命攸关的系统往往要求采用更加<strong>序列式的方法</strong>——“需求稳定”是确保“超高等级的可靠性”的必备条件之一。</p>
</blockquote>
<h3 id="3-3-问题定义的先决条件"><a href="#3-3-问题定义的先决条件" class="headerlink" title="3.3 问题定义的先决条件"></a>3.3 问题定义的先决条件</h3><p>　　本节讲的是如何辨认自己已经对一个系统要解决的问题做出了清楚的陈述。问题就是问题本身，不包含解决方案；问题要用客户的语言、站在客户的角度描述。错误的问题可能会导致错误的方向。</p>
<blockquote>
<p>如果“框框”是约束和条件的边界，那么诀窍在于找到这个“框框”……不要在“框框”之外思考——<strong>找到这个“框框”</strong>。</p>
</blockquote>
<h3 id="3-4-需求的先决条件"><a href="#3-4-需求的先决条件" class="headerlink" title="3.4 需求的先决条件"></a>3.4 需求的先决条件</h3><p>　　本节讲的是正式需求的重要性，以及如何判断是否已经很好地完成了需求分析、如何在构建期间处理需求变更。处理需求变更的方法有：确保每个人都知道需求变更的代价、建立一套变更控制程序（委员会、特定时间）、使用能适应变更的开发方法、放弃这个项目（哈哈哈）、注意项目的商业案例（考虑需求的商业价值）。</p>
<blockquote>
<ul>
<li>有些需求作为功能特色来看是不错的想法，但是当你评估“增加的商业价值”时就会觉得它是个糟透了的主意。那些记得“<strong>考虑自己的决定所带来的商业影响</strong>”的程序员的身价与黄金相当。</li>
<li>需求核对表：<br><img src="https://ftp.bmp.ovh/imgs/2020/03/8007b6639bb90374.png" alt=""><br><img src="https://ftp.bmp.ovh/imgs/2020/03/fc1da1d9d4007afb.png" alt=""></li>
</ul>
</blockquote>
<h3 id="3-5-架构的先决条件"><a href="#3-5-架构的先决条件" class="headerlink" title="3.5 架构的先决条件"></a>3.5 架构的先决条件</h3><p>　　本节讲了架构的基本概念、组织，列举了考察一个架构是否满足要求的标准，大体的思想就是：知道怎么做的同时还要知道为什么选择这种做法、巨细无遗而又不过度。架构的典型组成部分包括：程序组织、主要的类、数据设计、业务规则、用户界面设计、资源管理、安全性、性能、可伸缩性、互用性、国际化/本地化、输入输出、错误处理、容错性、架构可行性、过度工程（比要求的更好）、关于“买”还是“造”的决策、关于复用的决策、变更策略、架构整体质量</p>
<blockquote>
<ul>
<li>“架构”要区别于“高层设计”：架构是指适用于<strong>整个系统范围</strong>的设计约束，而高层设计指的是适用于子系统层次或多个类层次上的设计约束（但不是整个系统范围的设计）。</li>
<li>架构的质量决定了系统的“<strong>概念完整性</strong>”，后者继而决定了系统的最终质量。</li>
<li>在构建期间或者更晚的时候进行架构变更，代价也是高昂的。</li>
<li>“维护‘<strong>设计的缘由</strong>’”至少与“维护设计本身”一样重要。</li>
<li>在查看架构的时候，你应该很愉快，因为它给出的解决方案看上去既自然又容易。而不应该看起来像是用胶带把架构和待解决的问题硬捆绑到一起。</li>
<li>架构应该踏在对系统“<strong>欠描述（underspecifying）</strong>”和“<strong>过度描述（overspecifying）</strong>”之间的那条分界线上。</li>
<li>架构核对表<br><img src="https://ftp.bmp.ovh/imgs/2020/03/da46a0fcd9c358ef.png" alt=""><br><img src="https://ftp.bmp.ovh/imgs/2020/03/5cc9e9f3d4b0c489.png" alt=""></li>
</ul>
</blockquote>
<h3 id="3-6-花费在前期准备上的时间长度"><a href="#3-6-花费在前期准备上的时间长度" class="headerlink" title="3.6 花费在前期准备上的时间长度"></a>3.6 花费在前期准备上的时间长度</h3><p>　　花费在问题定义、需求分析、软件架构上的时间，依据项目的需要而变化。如果是需求不稳定的大项目，你需要与需求分析师合作；如果是需求不稳定的小项目，可能需要自己解决需求方面的问题；如果需求在任何项目上都不稳定，那就将需求分析工作视为独立项目来做。如果有必要，架构工作也作为独立的项目来对待。</p>
<h2 id="4-关键的“构建”决策"><a href="#4-关键的“构建”决策" class="headerlink" title="4 关键的“构建”决策"></a>4 关键的“构建”决策</h2><p>　　本章讲的是编码之前应该明确的事情，如语言的选择、编程的约束，以及认清自己在浪潮中的位置，合理地决策。应该明确“深入语言去编程”，也就是用思想引领而非被语言约束。</p>
<h3 id="4-1-选择编程语言"><a href="#4-1-选择编程语言" class="headerlink" title="4.1 选择编程语言"></a>4.1 选择编程语言</h3><p>　　选择正确的编程语言不仅可以提高生产力，还能有效表达思想。作者还介绍了一些常用编程语言的特点。</p>
<blockquote>
<p>Sapir-Whorf假说是，你思考的能力取决于你是否知道能够表达该思想的词汇。如果你不知道这些词汇，就无法表达出这种思想，甚至不可能形成这种思想。</p>
</blockquote>
<h3 id="4-2-编程约定"><a href="#4-2-编程约定" class="headerlink" title="4.2 编程约定"></a>4.2 编程约定</h3><p>　　本节讲述“架构的概念完整性”与“其底层实现”之间的关系。实现必须与架构保持已知，程序需有底层完整性（如变量的名称、类名、格式约束之类的约定）</p>
<blockquote>
<ul>
<li>成功编程的一个关键就在于避免随意地变化，这样你的大脑可以专注于那些真正需要的变化。</li>
<li>编码约定的细节要达到这样的精确度：在编写完软件之后，几乎不可能改变（翻新）软件所遵循的编码约定。</li>
</ul>
</blockquote>
<h4 id="4-3-你在技术浪潮中的位置"><a href="#4-3-你在技术浪潮中的位置" class="headerlink" title="4.3 你在技术浪潮中的位置"></a>4.3 你在技术浪潮中的位置</h4><p>　　编程实践取决于你在技术浪潮中所处的位置。技术浪潮的前期，编程语言有bug，文档少；技术浪潮的后期则相反，基础设施丰富。当处在前期时，“深入一种语言去编程”至关重要，也就是要让思想指导编程，而不是被语言限制思想。</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Code Complete</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1071：字符串的最大公因子</title>
    <url>/2020/03/18/leetcode_3_13/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://ftp.bmp.ovh/imgs/2020/03/e492b17beb0c5a02.png" alt=""></p>
<a id="more"></a>
<h2 id="标准解答-数学-O-n"><a href="#标准解答-数学-O-n" class="headerlink" title="标准解答 数学 $O(n)$"></a>标准解答 数学 $O(n)$</h2><p>首先证明：如果<code>str1+str2</code>等于<code>str2+str1</code>，则一定存在符合条件的字符串<code>X</code>。</p>
<p>必要性：</p>
<p>$str1=X+X+…+X=n<em>X,str2=X+X+…+X=m</em>X$，则$str1+str2=(n+m)<em>X=(m+n)</em>X=str2+str1$</p>
<p>充分性（证明其逆否命题成立）：</p>
<p>将str1分为长度最小的相等的n份，str2分为m份，$str1=X_1+…+X_n,str2=Y_1+…+Y_m$，则$str1+str2=X_1+…+X_n+Y_1+…+Y_m$，$str2+str1=Y_1+…+Y_m+X_1+…+X_n$。若不存在符合条件的<code>X</code>，则$X_1 ≠ Y_1, …, Y_m ≠ X_n$，也即$str1+str2 ≠ str2+str1$，从而逆否命题成立，原命题也成立。</p>
<p>满足题意的<code>X</code>的长度的最大值即为<code>gcd(str1.length(), str2.length())</code>（gcd(n, m)个<code>X</code>相连接）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b&gt;<span class="number">0</span>? gcd(b, a%b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">gcdOfStrings</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str1 + str2 != str2 + str1) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> str1.substr(<span class="number">0</span>, gcd((<span class="keyword">int</span>)str1.length(), (<span class="keyword">int</span>)str2.length()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>字符串比较$O(n)$，<code>gcd</code>开销$O(logn)$，总和为$O(n)$。</p>
<h2 id="个人解法-O-frac-n-2-m-logn"><a href="#个人解法-O-frac-n-2-m-logn" class="headerlink" title="个人解法 $O(\frac{n^2}{m}logn)$"></a>个人解法 $O(\frac{n^2}{m}logn)$</h2><p>利用gcd的思想写字符串的mod函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">gcdOfStrings</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str2 == <span class="string">""</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str1.length() &gt;= str2.length()) &#123;</span><br><span class="line">            <span class="built_in">string</span> smod = mod(str1, str2);</span><br><span class="line">            <span class="keyword">if</span> (smod == str1) &#123; </span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> gcdOfStrings(str2, smod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gcdOfStrings(str2, str1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">mod</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str1.length() == str2.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1 == str2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> str1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// l1 &gt; l2</span></span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> i, j;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; str1.length(); i+=str2.length()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; str2.length(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (str2[j] != str1[i+j]) &#123;</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> str1.substr(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>gcd开销$O(logn)$，字符串mod中的for循环外层$O(n/m)$，内层$O(n)$，相乘为$O(n^2/m)$，总共开销为$O(\frac{n^2}{m}logn)$</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/solution/zi-fu-chuan-de-zui-da-gong-yin-zi-by-leetcode-solu/" target="_blank" rel="noopener">官方题解</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1160：拼写单词</title>
    <url>/2020/03/17/leetcode_3_17/</url>
    <content><![CDATA[<p>ps：是非常非常简单的一道题，但是实现途中意识到自己代码能力太差，c++ string的用法搞的一塌糊涂，还是要拉出来总结一下</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://ftp.bmp.ovh/imgs/2020/03/5ade2ab64378432a.png" alt=""></p>
<h2 id="标准解法-哈希表计数-O-n-m"><a href="#标准解法-哈希表计数-O-n-m" class="headerlink" title="标准解法 哈希表计数 $O(n+m)$"></a>标准解法 哈希表计数 $O(n+m)$</h2><p><code>unorder_map</code>分别记录<code>chars</code>（资源）和<code>words</code>中的单词（需求）的字母出现次数，若资源大于需求则满足，否则不满足。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include &lt;unordered_map&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; chars_cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : chars) &#123;</span><br><span class="line">            chars_cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">word</span> : words) &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; word_cnt;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : <span class="keyword">word</span>) &#123;</span><br><span class="line">                word_cnt[c]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : <span class="keyword">word</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chars_cnt[c] &lt; word_cnt[c]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                ans += <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="个人解法-O-n-m"><a href="#个人解法-O-n-m" class="headerlink" title="个人解法 $O(n*m)$"></a>个人解法 $O(n*m)$</h2><p>没脑暴力的做法，对于<code>words</code>里的每个词的每个字母，在<code>chars</code>中找，找到一个删一个，如果有一个没找到，则不满足要求。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = words.<span class="built_in">begin</span>(); it != words.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="built_in">string</span> tmpchars = chars;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c = it-&gt;<span class="built_in">begin</span>(); c != it-&gt;<span class="built_in">end</span>(); c++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> pos = tmpchars.<span class="built_in">find</span>(*c);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pos != <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">                    tmpchars.erase(pos, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                ans += it-&gt;<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有一个神秘的现象时，本人的$O(n*m)$方案比题解$O(n+m)$方案的实际耗时要少，也许<code>unordered_map</code>的初始化、增添等代价要比<code>string</code>的使用代价高，或者<code>string</code>内部优化了<code>find()</code>。</p>
<p>从思路来讲，题解采用哈希表计数，通过比对资源与需求来判断单词是否可以被成果拼写，这个思路很巧妙。</p>
<h3 id="在本题中使用到的C-特性总结"><a href="#在本题中使用到的C-特性总结" class="headerlink" title="在本题中使用到的C++特性总结"></a>在本题中使用到的C++特性总结</h3><ul>
<li><code>unordered_map&lt;key, value&gt;</code><ul>
<li>正常哈希表的使用方法，重载了<code>[]</code>，可以很方便地类似数组使用</li>
</ul>
</li>
<li><code>for(it : container)</code><ul>
<li>for_each的用法太赞了，以前不知道，每次遍历都要苦苦写长长的<code>iterator</code></li>
</ul>
</li>
<li><code>string</code><ul>
<li><code>size_t str.find(substr/char)</code>：find可以用来查找子串，也可以查找单个char，返回的是该子串/字母第一次出现的位置，如果找不到,返回<code>str.npos</code>。注意<strong>不要用int型变量接收返回值</strong>（如<code>int pos = str.find(xxx)</code>，会将<code>str.npos</code>转为-1，从而<code>(pos != str.npos)</code>的判断语句就会失效。标准的接收变量是<code>size_t</code>或简便的<code>auto</code></li>
<li><code>str.erase(pos, n)</code>，从<code>pos</code>开始删除<code>n</code>个字符，如果省略<code>n</code>的话默认是到结尾。千万注意这里的<code>pos</code>是<code>size_t</code>型（也可以传入int），之前错以为可以删除特定字母<code>c</code>，从而造成错误的用法是<code>str.erase(c)</code>，这里语义是将<strong>从<code>c</code>的ASCII码位置起，到字符串结尾的字符删除</strong>，而这个ASCII码通常很大，就会造成程序出错。<ul>
<li><code>str.erase(iterator pos)</code>和<code>str.erase(iterator first, iterator last)</code>，erase的重载方法，注意区分使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 695：岛屿的最大面积</title>
    <url>/2020/03/15/leetcode_3_15/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://ftp.bmp.ovh/imgs/2020/03/2c3c48b371d8f3e1.png" alt=""></p>
<a id="more"></a>
<h2 id="标准解法：DFS-O-n-m"><a href="#标准解法：DFS-O-n-m" class="headerlink" title="标准解法：DFS $O(n*m)$"></a>标准解法：DFS $O(n*m)$</h2><p>基本思想比较简单，就是dfs走遍整个地图，记录最大的面积，走过的地标为0下次不再走。题解的代码很简洁，可以参考。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> cur_i, <span class="keyword">int</span> cur_j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur_i &lt; <span class="number">0</span> || cur_j &lt; <span class="number">0</span> || cur_i == grid.<span class="built_in">size</span>() || cur_j == grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[cur_i][cur_j] != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[cur_i][cur_j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> di[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dj[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index != <span class="number">4</span>; ++index) &#123;</span><br><span class="line">            <span class="keyword">int</span> next_i = cur_i + di[index], next_j = cur_j + dj[index];</span><br><span class="line">            ans += dfs(grid, next_i, next_j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != grid.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j)</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dfs(grid, i, j));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="个人解法-DFS菜鸡版-O-n-m"><a href="#个人解法-DFS菜鸡版-O-n-m" class="headerlink" title="个人解法 DFS菜鸡版 $O(n*m)$"></a>个人解法 DFS菜鸡版 $O(n*m)$</h2><p>我的代码就很丑，但是比较容易理解。用vis记录一块地有没有走过，<code>go</code>函数执行dfs的功能，上下左右走的每一步也很清晰。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; n &lt;&lt; " " &lt;&lt; m &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; vis;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; col;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                col.push_back(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            vis.push_back(col);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = go(i, j, n, m, vis, grid);</span><br><span class="line">                    <span class="keyword">if</span> (tmp &gt; <span class="built_in">max</span>) &#123;</span><br><span class="line">                        <span class="built_in">max</span> = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; vis, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        vis[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (grid[i][j]) &#123;</span><br><span class="line">            </span><br><span class="line">            area = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// up</span></span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !vis[i<span class="number">-1</span>][j]) &#123;</span><br><span class="line">                area += go(i<span class="number">-1</span>, j, n, m, vis, grid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// down</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; !vis[i+<span class="number">1</span>][j]) &#123;</span><br><span class="line">                area += go(i+<span class="number">1</span>, j, n, m, vis, grid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// left</span></span><br><span class="line">            <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !vis[i][j<span class="number">-1</span>]) &#123;</span><br><span class="line">                area += go(i, j<span class="number">-1</span>, n, m, vis, grid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// right</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; m &amp;&amp; !vis[i][j+<span class="number">1</span>]) &#123;</span><br><span class="line">                area += go(i, j+<span class="number">1</span>, n, m, vis, grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>题解中将1置0从而省去<code>vis</code>数组，很好地降低了空间开销，也省去了初始化。</p>
<p>此外，<strong>max函数为什么不用！！！</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 300：最长上升子序列</title>
    <url>/2020/03/14/leetcode_3_14/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://ftp.bmp.ovh/imgs/2020/03/218af1675f7358de.png" alt=""></p>
<a id="more"></a>
<h2 id="标准解法一：DP-O-n-2"><a href="#标准解法一：DP-O-n-2" class="headerlink" title="标准解法一：DP $O(n^2)$"></a>标准解法一：DP $O(n^2)$</h2><p>$d[i] = max(d[j])+1, 0 ≤ j &lt; i \&amp;\&amp; nums[j] &gt; nums[i]$</p>
<p>即$d[i]$表示以$nums[i]$结尾的最长递增子序列长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=(<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="标准解法二：贪心-二分-O-nlogn"><a href="#标准解法二：贪心-二分-O-nlogn" class="headerlink" title="标准解法二：贪心+二分 $O(nlogn)$"></a>标准解法二：贪心+二分 $O(nlogn)$</h2><p>　　思路：记录长度为<code>i</code>的LIS的最小尾元素<code>d[i]</code></p>
<p><strong>贪心贪什么？</strong></p>
<p>　　贪尾元素的最小，从而保证每个长度为<code>i</code>的递增子序列（IS，Increasing Sequence）都是最容易扩充的。</p>
<p><strong>二分分什么？</strong></p>
<p>　　分最小尾元数组<code>d</code>，当<code>num[i]</code>大于当前最大长度<code>len</code>对应的尾元<code>d[len]</code>时，秩序将<code>num[i]</code>“插入”LIS（直接令<code>d[++len]=num[i]</code>即可完成更新<code>d</code>与<code>len</code>）；而如果无法插入当前的LIS，则需要考虑更新之前的IS，因为<strong>每个IS都有可能成为LIS</strong>。所以需要找到<code>d[k] &lt; num[i] &lt; d[k+1]</code>，也就是<strong>找到第一个比<code>num[i]</code>小的尾元<code>d[k]</code></strong>，这里就用到了二分。然后把<code>num[i]</code>“插到”<code>d[k]</code>之后（更新<code>d[k+1]=num[i]</code>）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>, n = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        d[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) d[++len] = nums[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">1</span>, r = len, pos = <span class="number">0</span>; <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="个人解法-DP"><a href="#个人解法-DP" class="headerlink" title="个人解法 DP"></a>个人解法 DP</h2><p>　　思路类似<code>标准解法一</code>，用<code>map P</code>记录以<code>nums[i]</code>结尾的的最大递增子序列（LIS），每次取最大的LIS长度<code>P[nums[j]]</code>使得<code>nums[i]&gt;nums[j]</code>保留</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;    <span class="comment">// 使用map记录num[i]结尾的LIS</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            P[nums[i]] = <span class="number">1</span>; <span class="comment">// 初始化为1（也就是只有自己）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j] &amp;&amp; P[nums[i]] &lt; P[nums[j]]+<span class="number">1</span>) &#123;</span><br><span class="line">                    P[nums[i]] = P[nums[j]]+<span class="number">1</span>;  <span class="comment">// 取最大的一个</span></span><br><span class="line">                    <span class="comment">// cout &lt;&lt; nums[i] &lt;&lt; " " &lt;&lt; P[nums[i]] &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = P.<span class="built_in">begin</span>(); it != P.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).second &gt; <span class="built_in">max</span>) &#123;</span><br><span class="line">                <span class="built_in">max</span> = (*it).second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　总结一下，DP解这题的思路只需由<code>i</code>建立<code>nums[i]</code>与dp数组<code>dp[i]</code>的联系，而无需用到<code>map</code>进行具体数值的映射。此外，对<code>max</code>的处理不够简略，比较混乱</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/" target="_blank" rel="noopener">官方题解</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Next主题</title>
    <url>/2020/03/13/%E4%BD%BF%E7%94%A8Next%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p>Next主题美化个人博客</p>
<a id="more"></a>
<h2 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h2><p>在根目录下</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/theme-<span class="keyword">next</span>/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<h2 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h2><p><code>_config.yml</code>中找到<code>theme</code>，修改为<code>next</code>完成</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="标签栏"><a href="#标签栏" class="headerlink" title="标签栏"></a>标签栏</h3><ol>
<li><p>添加标签栏</p>
<p> 根目录下</p>
 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">hexo new<span class="built_in"> page </span>tags</span><br></pre></td></tr></table></figure>
<p> 此时<code>/source/</code>中生成<code>tags</code>文件夹，里面有<code>index.md</code>，内容为</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2014</span><span class="number">-12</span><span class="number">-22</span> <span class="number">12</span><span class="string">:39:04</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p> 添加<code>type: &quot;tags&quot;</code>，此时文件内容为</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2014</span><span class="number">-12</span><span class="number">-22</span> <span class="number">12</span><span class="string">:39:04</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"tags"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p> 根目录的<code>config.yml</code>中取消<code>menu: tags:</code>的的注释即可</p>
</li>
<li><p>为文章添加标签</p>
<p> 文章顶部：</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">标签测试文章</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">Test1</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">Test2</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p> 注意不要忘了末尾的<code>---</code>，否则<code>hexo generate</code>的时候会报错</p>
</li>
</ol>
<h3 id="分类栏"><a href="#分类栏" class="headerlink" title="分类栏"></a>分类栏</h3><p>类似<code>标签栏</code>的添加</p>
<ol>
<li><code>hexo new page categories</code></li>
<li>在<code>source/categories/index.md</code>中添加类型<code>type: &quot;categories&quot;</code></li>
<li>取消根目录的<code>_config.yml</code>中<code>categories:</code>的注释</li>
<li>文章中<code>categories: test</code>（可以像tag一样多分类的形式）</li>
</ol>
<h3 id="评论（Valine）"><a href="#评论（Valine）" class="headerlink" title="评论（Valine）"></a>评论（Valine）</h3><ol>
<li>在<a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">链接</a>中查看APP ID和APP Key的获取方式（需注册<a href="https://www.leancloud.cn/" target="_blank" rel="noopener">leanCloud</a>并实名认证）<br> 注：无需部署，Next主题已经内置</li>
<li>在<code>next</code>主题的<code>_config.yml</code>中找到APP ID和APP Key填入，将相关项改为<code>true</code>即可</li>
</ol>
<h3 id="访客-访问量数据统计"><a href="#访客-访问量数据统计" class="headerlink" title="访客/访问量数据统计"></a>访客/访问量数据统计</h3><p>（用的不蒜子统计）<br><code>_config.yml</code>中<code>busuanzi_count</code>把相关项<code>true</code>了</p>
<h3 id="Markdown数学支持"><a href="#Markdown数学支持" class="headerlink" title="Markdown数学支持"></a>Markdown数学支持</h3><p><a href="https://blog.csdn.net/ssjdoudou/article/details/103318019?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考链接</a></p>
<h3 id="更多定制化配置"><a href="#更多定制化配置" class="headerlink" title="更多定制化配置"></a>更多定制化配置</h3><p>如侧边社交栏、打赏功能、腾讯公益404页面，请参考<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">官方教程链接</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">官方教程链接</a></p>
<p><a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></p>
<p><a href="https://www.jianshu.com/p/c04b4f55c38c" target="_blank" rel="noopener">Hexo搭建GitHub博客—打造炫酷的NexT主题—高级(四)</a></p>
<p><a href="https://blog.csdn.net/ssjdoudou/article/details/103318019?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">Hexo-next主题支持数学公式</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <url>/2020/03/13/Hexo+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>使用Hexo与github.io部署自己的博客</p>
<blockquote>
<p>环境：win10</p>
</blockquote>
<a id="more"></a>
<h2 id="1-安装Node-JS"><a href="#1-安装Node-JS" class="headerlink" title="1 安装Node.JS"></a>1 安装Node.JS</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">链接</a></p>
<h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2 安装Hexo"></a>2 安装Hexo</h2><p>cmd中</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>
<h2 id="3-部署本地"><a href="#3-部署本地" class="headerlink" title="3 部署本地"></a>3 部署本地</h2><p>初始化</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">init &lt;folder&gt;</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">&lt;folder&gt;</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install</span></span><br></pre></td></tr></table></figure>
<p>生成</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>然后在<code>http://localhost:xxxx</code>中可以预览博客</p>
<h2 id="4-部署github"><a href="#4-部署github" class="headerlink" title="4 部署github"></a>4 部署github</h2><ol>
<li><p>新仓库</p>
<p> 创建一个新的仓库，仓库名为<code>username.github.io</code>，其中<code>username</code>必须是Github的用户名。然后就能在<code>username.github.io</code>看到你的主页了</p>
</li>
<li><p>转移</p>
<p> 然后将仓库克隆到本地，并将第三部中创建的<code>&lt;folder&gt;</code><strong>中</strong>的文件copy到仓库文件中</p>
</li>
<li><p>配置文件修改</p>
<p> 找到<code>_config.yml</code>，拖到底部找到<code>deploy</code>，按如下格式修改：</p>
 <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">    <span class="attribute">type</span>: git</span><br><span class="line">    <span class="attribute">repo</span>:</span><br><span class="line">        <span class="attribute">github</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:username/username.github.io.git（这种ssh的写法可以避免每次deploy要输入账号密码，不过如果git没配置ssh key的话上网找找教程</span><br><span class="line">    <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></li>
<li><p>部署！<br> 进入<code>username.github.io</code>文件下</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">generate</span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p> 第一次部署需要github密码，等待片刻后可以在<code>https://username.github.io/</code>中看到自己的博客。初始状态是这样的：</p>
<p> <img src="https://ftp.bmp.ovh/imgs/2020/03/49d75ff2d5a3e545.png" alt=""></p>
</li>
</ol>
<h2 id="5-发布文章"><a href="#5-发布文章" class="headerlink" title="5 发布文章"></a>5 发布文章</h2><ol>
<li>创建<br> 在<code>source/_posts/</code>中创建新的<code>markdown</code>文件，或者使用以下命令创建 <figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> &lt;<span class="built_in">title</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>预览<br> 文章撰写完成后，执行命令</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo g # 生成，即<span class="keyword">generate</span></span><br><span class="line">hexo s # 即server</span><br></pre></td></tr></table></figure>
<p> 即可预览自己的博客</p>
</li>
<li><p>发布</p>
 <figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo</span> clean <span class="comment"># 清楚缓存文件和静态生产文件</span></span><br><span class="line">hexo g -d <span class="comment"># 发布</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6 参考文献"></a>6 参考文献</h2><p><a href="https://hexo.io/zh-tw/docs/" target="_blank" rel="noopener">Hexo官方文档</a></p>
<p><a href="https://www.jianshu.com/p/71f58f4b7b30" target="_blank" rel="noopener">用 Github.io 和 Hexo 创建你的第一个博客</a></p>
<p><a href="https://segmentfault.com/a/1190000017986794" target="_blank" rel="noopener">超详细Hexo+Github Page搭建技术博客教程【持续更新】</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
