<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode 1160.拼写单词</title>
    <url>/2020/03/17/leetcode_3_17/</url>
    <content><![CDATA[<p>ps：是非常非常简单的一道题，但是实现途中意识到自己代码能力太差，c++ string的用法搞的一塌糊涂，还是要拉出来总结一下</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="assets/md_2020-03-17-12-03-23.png" alt=""></p>
<h2 id="标准解法-哈希表计数-O-n-m"><a href="#标准解法-哈希表计数-O-n-m" class="headerlink" title="标准解法 哈希表计数 $O(n+m)$"></a>标准解法 哈希表计数 $O(n+m)$</h2><p><code>unorder_map</code>分别记录<code>chars</code>（资源）和<code>words</code>中的单词（需求）的字母出现次数，若资源大于需求则满足，否则不满足。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include &lt;unordered_map&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; chars_cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : chars) &#123;</span><br><span class="line">            chars_cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">word</span> : words) &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; word_cnt;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : <span class="keyword">word</span>) &#123;</span><br><span class="line">                word_cnt[c]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : <span class="keyword">word</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chars_cnt[c] &lt; word_cnt[c]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                ans += <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="个人解法-O-n-m"><a href="#个人解法-O-n-m" class="headerlink" title="个人解法 $O(n*m)$"></a>个人解法 $O(n*m)$</h2><p>没脑暴力的做法，对于<code>words</code>里的每个词的每个字母，在<code>chars</code>中找，找到一个删一个，如果有一个没找到，则不满足要求。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = words.<span class="built_in">begin</span>(); it != words.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="built_in">string</span> tmpchars = chars;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c = it-&gt;<span class="built_in">begin</span>(); c != it-&gt;<span class="built_in">end</span>(); c++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> pos = tmpchars.<span class="built_in">find</span>(*c);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pos != <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">                    tmpchars.erase(pos, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                ans += it-&gt;<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有一个神秘的现象时，本人的$O(n*m)$方案比题解$O(n+m)$方案的实际耗时要少，也许<code>unordered_map</code>的初始化、增添等代价要比<code>string</code>的使用代价高，或者<code>string</code>内部优化了<code>find()</code>。</p>
<p>从思路来讲，题解采用哈希表计数，通过比对资源与需求来判断单词是否可以被成果拼写，这个思路很巧妙。</p>
<h3 id="在本题中使用到的C-特性总结"><a href="#在本题中使用到的C-特性总结" class="headerlink" title="在本题中使用到的C++特性总结"></a>在本题中使用到的C++特性总结</h3><ul>
<li><code>unordered_map&lt;key, value&gt;</code><ul>
<li>正常哈希表的使用方法，重载了<code>[]</code>，可以很方便地类似数组使用</li>
</ul>
</li>
<li><code>for(it : container)</code><ul>
<li>for_each的用法太赞了，以前不知道，每次遍历都要苦苦写长长的<code>iterator</code></li>
</ul>
</li>
<li><code>string</code><ul>
<li><code>size_t str.find(substr/char)</code>：find可以用来查找子串，也可以查找单个char，返回的是该子串/字母第一次出现的位置，如果找不到,返回<code>str.npos</code>。注意<strong>不要用int型变量接收返回值</strong>（如<code>int pos = str.find(xxx)</code>，会将<code>str.npos</code>转为-1，从而<code>(pos != str.npos)</code>的判断语句就会失效。标准的接收变量是<code>size_t</code>或简便的<code>auto</code></li>
<li><code>str.erase(pos, n)</code>，从<code>pos</code>开始删除<code>n</code>个字符，如果省略<code>n</code>的话默认是到结尾。千万注意这里的<code>pos</code>是<code>size_t</code>型（也可以传入int），之前错以为可以删除特定字母<code>c</code>，从而造成错误的用法是<code>str.erase(c)</code>，这里语义是将<strong>从<code>c</code>的ASCII码位置起，到字符串结尾的字符删除</strong>，而这个ASCII码通常很大，就会造成程序出错。<ul>
<li><code>str.erase(iterator pos)</code>和<code>str.erase(iterator first, iterator last)</code>，erase的重载方法，注意区分使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 695：岛屿的最大面积</title>
    <url>/2020/03/15/leetcode_3_15/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://ftp.bmp.ovh/imgs/2020/03/2c3c48b371d8f3e1.png" alt=""></p>
<a id="more"></a>
<h2 id="标准解法：DFS-O-n-m"><a href="#标准解法：DFS-O-n-m" class="headerlink" title="标准解法：DFS $O(n*m)$"></a>标准解法：DFS $O(n*m)$</h2><p>基本思想比较简单，就是dfs走遍整个地图，记录最大的面积，走过的地标为0下次不再走。题解的代码很简洁，可以参考。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> cur_i, <span class="keyword">int</span> cur_j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur_i &lt; <span class="number">0</span> || cur_j &lt; <span class="number">0</span> || cur_i == grid.<span class="built_in">size</span>() || cur_j == grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[cur_i][cur_j] != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[cur_i][cur_j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> di[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dj[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index != <span class="number">4</span>; ++index) &#123;</span><br><span class="line">            <span class="keyword">int</span> next_i = cur_i + di[index], next_j = cur_j + dj[index];</span><br><span class="line">            ans += dfs(grid, next_i, next_j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != grid.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j)</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dfs(grid, i, j));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="个人解法-DFS菜鸡版-O-n-m"><a href="#个人解法-DFS菜鸡版-O-n-m" class="headerlink" title="个人解法 DFS菜鸡版 $O(n*m)$"></a>个人解法 DFS菜鸡版 $O(n*m)$</h2><p>我的代码就很丑，但是比较容易理解。用vis记录一块地有没有走过，<code>go</code>函数执行dfs的功能，上下左右走的每一步也很清晰。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; n &lt;&lt; " " &lt;&lt; m &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; vis;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; col;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                col.push_back(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            vis.push_back(col);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = go(i, j, n, m, vis, grid);</span><br><span class="line">                    <span class="keyword">if</span> (tmp &gt; <span class="built_in">max</span>) &#123;</span><br><span class="line">                        <span class="built_in">max</span> = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">const</span> <span class="keyword">int</span>&amp; n, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; vis, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        vis[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (grid[i][j]) &#123;</span><br><span class="line">            </span><br><span class="line">            area = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// up</span></span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !vis[i<span class="number">-1</span>][j]) &#123;</span><br><span class="line">                area += go(i<span class="number">-1</span>, j, n, m, vis, grid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// down</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; !vis[i+<span class="number">1</span>][j]) &#123;</span><br><span class="line">                area += go(i+<span class="number">1</span>, j, n, m, vis, grid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// left</span></span><br><span class="line">            <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !vis[i][j<span class="number">-1</span>]) &#123;</span><br><span class="line">                area += go(i, j<span class="number">-1</span>, n, m, vis, grid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// right</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; m &amp;&amp; !vis[i][j+<span class="number">1</span>]) &#123;</span><br><span class="line">                area += go(i, j+<span class="number">1</span>, n, m, vis, grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>题解中将1置0从而省去<code>vis</code>数组，很好地降低了空间开销，也省去了初始化。</p>
<p>此外，<strong>max函数为什么不用！！！</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 300：最长上升子序列</title>
    <url>/2020/03/14/leetcode_3_14/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://ftp.bmp.ovh/imgs/2020/03/218af1675f7358de.png" alt=""></p>
<a id="more"></a>
<h2 id="标准解法一：DP-O-n-2"><a href="#标准解法一：DP-O-n-2" class="headerlink" title="标准解法一：DP $O(n^2)$"></a>标准解法一：DP $O(n^2)$</h2><p>$d[i] = max(d[j])+1, 0 ≤ j &lt; i \&amp;\&amp; nums[j] &gt; nums[i]$</p>
<p>即$d[i]$表示以$nums[i]$结尾的最长递增子序列长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=(<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="标准解法二：贪心-二分-O-nlogn"><a href="#标准解法二：贪心-二分-O-nlogn" class="headerlink" title="标准解法二：贪心+二分 $O(nlogn)$"></a>标准解法二：贪心+二分 $O(nlogn)$</h2><p>　　思路：记录长度为<code>i</code>的LIS的最小尾元素<code>d[i]</code></p>
<p><strong>贪心贪什么？</strong></p>
<p>　　贪尾元素的最小，从而保证每个长度为<code>i</code>的递增子序列（IS，Increasing Sequence）都是最容易扩充的。</p>
<p><strong>二分分什么？</strong></p>
<p>　　分最小尾元数组<code>d</code>，当<code>num[i]</code>大于当前最大长度<code>len</code>对应的尾元<code>d[len]</code>时，秩序将<code>num[i]</code>“插入”LIS（直接令<code>d[++len]=num[i]</code>即可完成更新<code>d</code>与<code>len</code>）；而如果无法插入当前的LIS，则需要考虑更新之前的IS，因为<strong>每个IS都有可能成为LIS</strong>。所以需要找到<code>d[k] &lt; num[i] &lt; d[k+1]</code>，也就是<strong>找到第一个比<code>num[i]</code>小的尾元<code>d[k]</code></strong>，这里就用到了二分。然后把<code>num[i]</code>“插到”<code>d[k]</code>之后（更新<code>d[k+1]=num[i]</code>）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>, n = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        d[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) d[++len] = nums[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">1</span>, r = len, pos = <span class="number">0</span>; <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="个人解法-DP"><a href="#个人解法-DP" class="headerlink" title="个人解法 DP"></a>个人解法 DP</h2><p>　　思路类似<code>标准解法一</code>，用<code>map P</code>记录以<code>nums[i]</code>结尾的的最大递增子序列（LIS），每次取最大的LIS长度<code>P[nums[j]]</code>使得<code>nums[i]&gt;nums[j]</code>保留</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;    <span class="comment">// 使用map记录num[i]结尾的LIS</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            P[nums[i]] = <span class="number">1</span>; <span class="comment">// 初始化为1（也就是只有自己）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j] &amp;&amp; P[nums[i]] &lt; P[nums[j]]+<span class="number">1</span>) &#123;</span><br><span class="line">                    P[nums[i]] = P[nums[j]]+<span class="number">1</span>;  <span class="comment">// 取最大的一个</span></span><br><span class="line">                    <span class="comment">// cout &lt;&lt; nums[i] &lt;&lt; " " &lt;&lt; P[nums[i]] &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = P.<span class="built_in">begin</span>(); it != P.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).second &gt; <span class="built_in">max</span>) &#123;</span><br><span class="line">                <span class="built_in">max</span> = (*it).second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　总结一下，DP解这题的思路只需由<code>i</code>建立<code>nums[i]</code>与dp数组<code>dp[i]</code>的联系，而无需用到<code>map</code>进行具体数值的映射。此外，对<code>max</code>的处理不够简略，比较混乱</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/" target="_blank" rel="noopener">官方题解</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Next主题</title>
    <url>/2020/03/13/%E4%BD%BF%E7%94%A8Next%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p>Next主题美化个人博客</p>
<a id="more"></a>
<h2 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h2><p>在根目录下</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/theme-<span class="keyword">next</span>/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<h2 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h2><p><code>_config.yml</code>中找到<code>theme</code>，修改为<code>next</code>完成</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="标签栏"><a href="#标签栏" class="headerlink" title="标签栏"></a>标签栏</h3><ol>
<li><p>添加标签栏</p>
<p> 根目录下</p>
 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">hexo new<span class="built_in"> page </span>tags</span><br></pre></td></tr></table></figure>
<p> 此时<code>/source/</code>中生成<code>tags</code>文件夹，里面有<code>index.md</code>，内容为</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2014</span><span class="number">-12</span><span class="number">-22</span> <span class="number">12</span><span class="string">:39:04</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p> 添加<code>type: &quot;tags&quot;</code>，此时文件内容为</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2014</span><span class="number">-12</span><span class="number">-22</span> <span class="number">12</span><span class="string">:39:04</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"tags"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p> 根目录的<code>config.yml</code>中取消<code>menu: tags:</code>的的注释即可</p>
</li>
<li><p>为文章添加标签</p>
<p> 文章顶部：</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">标签测试文章</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">Test1</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">Test2</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p> 注意不要忘了末尾的<code>---</code>，否则<code>hexo generate</code>的时候会报错</p>
</li>
</ol>
<h3 id="分类栏"><a href="#分类栏" class="headerlink" title="分类栏"></a>分类栏</h3><p>类似<code>标签栏</code>的添加</p>
<ol>
<li><code>hexo new page categories</code></li>
<li>在<code>source/categories/index.md</code>中添加类型<code>type: &quot;categories&quot;</code></li>
<li>取消根目录的<code>_config.yml</code>中<code>categories:</code>的注释</li>
<li>文章中<code>categories: test</code>（可以像tag一样多分类的形式）</li>
</ol>
<h3 id="评论（Valine）"><a href="#评论（Valine）" class="headerlink" title="评论（Valine）"></a>评论（Valine）</h3><ol>
<li>在<a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">链接</a>中查看APP ID和APP Key的获取方式（需注册<a href="https://www.leancloud.cn/" target="_blank" rel="noopener">leanCloud</a>并实名认证）<br> 注：无需部署，Next主题已经内置</li>
<li>在<code>next</code>主题的<code>_config.yml</code>中找到APP ID和APP Key填入，将相关项改为<code>true</code>即可</li>
</ol>
<h3 id="访客-访问量数据统计"><a href="#访客-访问量数据统计" class="headerlink" title="访客/访问量数据统计"></a>访客/访问量数据统计</h3><p>（用的不蒜子统计）<br><code>_config.yml</code>中<code>busuanzi_count</code>把相关项<code>true</code>了</p>
<h3 id="Markdown数学支持"><a href="#Markdown数学支持" class="headerlink" title="Markdown数学支持"></a>Markdown数学支持</h3><p><a href="https://blog.csdn.net/ssjdoudou/article/details/103318019?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考链接</a></p>
<h3 id="更多定制化配置"><a href="#更多定制化配置" class="headerlink" title="更多定制化配置"></a>更多定制化配置</h3><p>如侧边社交栏、打赏功能、腾讯公益404页面，请参考<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">官方教程链接</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">官方教程链接</a></p>
<p><a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></p>
<p><a href="https://www.jianshu.com/p/c04b4f55c38c" target="_blank" rel="noopener">Hexo搭建GitHub博客—打造炫酷的NexT主题—高级(四)</a></p>
<p><a href="https://blog.csdn.net/ssjdoudou/article/details/103318019?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">Hexo-next主题支持数学公式</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <url>/2020/03/13/Hexo+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>使用Hexo与github.io部署自己的博客</p>
<blockquote>
<p>环境：win10</p>
</blockquote>
<a id="more"></a>
<h2 id="1-安装Node-JS"><a href="#1-安装Node-JS" class="headerlink" title="1 安装Node.JS"></a>1 安装Node.JS</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">链接</a></p>
<h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2 安装Hexo"></a>2 安装Hexo</h2><p>cmd中</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>
<h2 id="3-部署本地"><a href="#3-部署本地" class="headerlink" title="3 部署本地"></a>3 部署本地</h2><p>初始化</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">init &lt;folder&gt;</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">&lt;folder&gt;</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install</span></span><br></pre></td></tr></table></figure>
<p>生成</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>然后在<code>http://localhost:xxxx</code>中可以预览博客</p>
<h2 id="4-部署github"><a href="#4-部署github" class="headerlink" title="4 部署github"></a>4 部署github</h2><ol>
<li><p>新仓库</p>
<p> 创建一个新的仓库，仓库名为<code>username.github.io</code>，其中<code>username</code>必须是Github的用户名。然后就能在<code>username.github.io</code>看到你的主页了</p>
</li>
<li><p>转移</p>
<p> 然后将仓库克隆到本地，并将第三部中创建的<code>&lt;folder&gt;</code><strong>中</strong>的文件copy到仓库文件中</p>
</li>
<li><p>配置文件修改</p>
<p> 找到<code>_config.yml</code>，拖到底部找到<code>deploy</code>，按如下格式修改：</p>
 <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">    <span class="attribute">type</span>: git</span><br><span class="line">    <span class="attribute">repo</span>:</span><br><span class="line">        <span class="attribute">github</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:username/username.github.io.git（这种ssh的写法可以避免每次deploy要输入账号密码，不过如果git没配置ssh key的话上网找找教程</span><br><span class="line">    <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></li>
<li><p>部署！<br> 进入<code>username.github.io</code>文件下</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">generate</span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p> 第一次部署需要github密码，等待片刻后可以在<code>https://username.github.io/</code>中看到自己的博客。初始状态是这样的：</p>
<p> <img src="https://ftp.bmp.ovh/imgs/2020/03/49d75ff2d5a3e545.png" alt=""></p>
</li>
</ol>
<h2 id="5-发布文章"><a href="#5-发布文章" class="headerlink" title="5 发布文章"></a>5 发布文章</h2><ol>
<li>创建<br> 在<code>source/_posts/</code>中创建新的<code>markdown</code>文件，或者使用以下命令创建 <figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> &lt;<span class="built_in">title</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>预览<br> 文章撰写完成后，执行命令</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo g # 生成，即<span class="keyword">generate</span></span><br><span class="line">hexo s # 即server</span><br></pre></td></tr></table></figure>
<p> 即可预览自己的博客</p>
</li>
<li><p>发布</p>
 <figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo</span> clean <span class="comment"># 清楚缓存文件和静态生产文件</span></span><br><span class="line">hexo g -d <span class="comment"># 发布</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6 参考文献"></a>6 参考文献</h2><p><a href="https://hexo.io/zh-tw/docs/" target="_blank" rel="noopener">Hexo官方文档</a></p>
<p><a href="https://www.jianshu.com/p/71f58f4b7b30" target="_blank" rel="noopener">用 Github.io 和 Hexo 创建你的第一个博客</a></p>
<p><a href="https://segmentfault.com/a/1190000017986794" target="_blank" rel="noopener">超详细Hexo+Github Page搭建技术博客教程【持续更新】</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
