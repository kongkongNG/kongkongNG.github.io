<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode 300：最长上升子序列</title>
    <url>/2020/03/14/leetcode_3_14/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="assets/md_2020-03-14-16-26-32.png" alt=""></p>
<a id="more"></a>
<h2 id="标准解法一：DP-O-n-2"><a href="#标准解法一：DP-O-n-2" class="headerlink" title="标准解法一：DP $O(n^2)$"></a>标准解法一：DP $O(n^2)$</h2><p>$d[i] = max(d[j])+1, 0 ≤ j &lt; i \&amp;\&amp; nums[j] &gt; nums[i]$</p>
<p>即$d[i]$表示以$nums[i]$结尾的最长递增子序列长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n&#x3D;(int)nums.size();</span><br><span class="line">        if (n &#x3D;&#x3D; 0) return 0;</span><br><span class="line">        vector&lt;int&gt; dp(n, 0);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] &#x3D; 1;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; i; ++j) &#123;</span><br><span class="line">                if (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] &#x3D; max(dp[i], dp[j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return *max_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="标准解法二：贪心-二分-O-nlogn"><a href="#标准解法二：贪心-二分-O-nlogn" class="headerlink" title="标准解法二：贪心+二分 $O(nlogn)$"></a>标准解法二：贪心+二分 $O(nlogn)$</h2><p>　　思路：记录长度为<code>i</code>的LIS的最小尾元素<code>d[i]</code></p>
<p><strong>贪心贪什么？</strong></p>
<p>　　贪尾元素的最小，从而保证每个长度为<code>i</code>的递增子序列（IS，Increasing Sequence）都是最容易扩充的。</p>
<p><strong>二分分什么？</strong></p>
<p>　　分最小尾元数组<code>d</code>，当<code>num[i]</code>大于当前最大长度<code>len</code>对应的尾元<code>d[len]</code>时，秩序将<code>num[i]</code>“插入”LIS（直接令<code>d[++len]=num[i]</code>即可完成更新<code>d</code>与<code>len</code>）；而如果无法插入当前的LIS，则需要考虑更新之前的IS，因为<strong>每个IS都有可能成为LIS</strong>。所以需要找到<code>d[k] &lt; num[i] &lt; d[k+1]</code>，也就是<strong>找到第一个比<code>num[i]</code>小的尾元<code>d[k]</code></strong>，这里就用到了二分。然后把<code>num[i]</code>“插到”<code>d[k]</code>之后（更新<code>d[k+1]=num[i]</code>）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len &#x3D; 1, n &#x3D; (int)nums.size();</span><br><span class="line">        if (n &#x3D;&#x3D; 0) return 0;</span><br><span class="line">        vector&lt;int&gt; d(n + 1, 0);</span><br><span class="line">        d[len] &#x3D; nums[0];</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] &gt; d[len]) d[++len] &#x3D; nums[i];</span><br><span class="line">            else&#123;</span><br><span class="line">                int l &#x3D; 1, r &#x3D; len, pos &#x3D; 0; &#x2F;&#x2F; 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span><br><span class="line">                while (l &lt;&#x3D; r) &#123;</span><br><span class="line">                    int mid &#x3D; (l + r) &gt;&gt; 1;</span><br><span class="line">                    if (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos &#x3D; mid;</span><br><span class="line">                        l &#x3D; mid + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else r &#x3D; mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + 1] &#x3D; nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="个人解法-DP"><a href="#个人解法-DP" class="headerlink" title="个人解法 DP"></a>个人解法 DP</h2><p>　　思路类似<code>标准解法一</code>，用<code>map P</code>记录以<code>nums[i]</code>结尾的的最大递增子序列（LIS），每次取最大的LIS长度<code>P[nums[j]]</code>使得<code>nums[i]&gt;nums[j]</code>保留</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        map&lt;int, int&gt; P;    &#x2F;&#x2F; 使用map记录num[i]结尾的LIS</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            P[nums[i]] &#x3D; 1; &#x2F;&#x2F; 初始化为1（也就是只有自己）</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            int j;</span><br><span class="line">            for (j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">                if (nums[i] &gt; nums[j] &amp;&amp; P[nums[i]] &lt; P[nums[j]]+1) &#123;</span><br><span class="line">                    P[nums[i]] &#x3D; P[nums[j]]+1;  &#x2F;&#x2F; 取最大的一个</span><br><span class="line">                    &#x2F;&#x2F; cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot; &lt;&lt; P[nums[i]] &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int max &#x3D; 0;</span><br><span class="line">        for (auto it &#x3D; P.begin(); it !&#x3D; P.end(); it++) &#123;</span><br><span class="line">            if ((*it).second &gt; max) &#123;</span><br><span class="line">                max &#x3D; (*it).second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　总结一下，DP解这题的思路只需由<code>i</code>建立<code>nums[i]</code>与dp数组<code>dp[i]</code>的联系，而无需用到<code>map</code>进行具体数值的映射。此外，对<code>max</code>的处理不够简略，比较混乱</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/" target="_blank" rel="noopener">官方题解</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Next主题</title>
    <url>/2020/03/13/%E4%BD%BF%E7%94%A8Next%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p>Next主题美化个人博客</p>
<a id="more"></a>
<h2 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h2><p>在根目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<h2 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h2><p><code>_config.yml</code>中找到<code>theme</code>，修改为<code>next</code>完成</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="标签栏"><a href="#标签栏" class="headerlink" title="标签栏"></a>标签栏</h3><ol>
<li><p>添加标签栏</p>
<p> 根目录下</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p> 此时<code>/source/</code>中生成<code>tags</code>文件夹，里面有<code>index.md</code>，内容为</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p> 添加<code>type: &quot;tags&quot;</code>，此时文件内容为</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p> 根目录的<code>config.yml</code>中取消<code>menu: tags:</code>的的注释即可</p>
</li>
<li><p>为文章添加标签</p>
<p> 文章顶部：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签测试文章</span><br><span class="line">tags:</span><br><span class="line">   - Test1</span><br><span class="line">   - Test2</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p> 注意不要忘了末尾的<code>---</code>，否则<code>hexo generate</code>的时候会报错</p>
</li>
</ol>
<h3 id="分类栏"><a href="#分类栏" class="headerlink" title="分类栏"></a>分类栏</h3><p>类似<code>标签栏</code>的添加</p>
<ol>
<li><code>hexo new page categories</code></li>
<li>在<code>source/categories/index.md</code>中添加类型<code>type: &quot;categories&quot;</code></li>
<li>取消根目录的<code>_config.yml</code>中<code>categories:</code>的注释</li>
<li>文章中<code>categories: test</code>（可以像tag一样多分类的形式）</li>
</ol>
<h3 id="评论（Valine）"><a href="#评论（Valine）" class="headerlink" title="评论（Valine）"></a>评论（Valine）</h3><ol>
<li>在<a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">链接</a>中查看APP ID和APP Key的获取方式（需注册<a href="https://www.leancloud.cn/" target="_blank" rel="noopener">leanCloud</a>并实名认证）<br> 注：无需部署，Next主题已经内置</li>
<li>在<code>next</code>主题的<code>_config.yml</code>中找到APP ID和APP Key填入，将相关项改为<code>true</code>即可</li>
</ol>
<h3 id="访客-访问量数据统计"><a href="#访客-访问量数据统计" class="headerlink" title="访客/访问量数据统计"></a>访客/访问量数据统计</h3><p>（用的不蒜子统计）<br><code>_config.yml</code>中<code>busuanzi_count</code>把相关项<code>true</code>了</p>
<h3 id="Markdown数学支持"><a href="#Markdown数学支持" class="headerlink" title="Markdown数学支持"></a>Markdown数学支持</h3><p><a href="https://blog.csdn.net/ssjdoudou/article/details/103318019?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考链接</a></p>
<h3 id="更多定制化配置"><a href="#更多定制化配置" class="headerlink" title="更多定制化配置"></a>更多定制化配置</h3><p>如侧边社交栏、打赏功能、腾讯公益404页面，请参考<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">官方教程链接</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">官方教程链接</a></p>
<p><a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></p>
<p><a href="https://www.jianshu.com/p/c04b4f55c38c" target="_blank" rel="noopener">Hexo搭建GitHub博客—打造炫酷的NexT主题—高级(四)</a></p>
<p><a href="https://blog.csdn.net/ssjdoudou/article/details/103318019?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">Hexo-next主题支持数学公式</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <url>/2020/03/13/Hexo+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>使用Hexo与github.io部署自己的博客</p>
<blockquote>
<p>环境：win10</p>
</blockquote>
<a id="more"></a>
<h2 id="1-安装Node-JS"><a href="#1-安装Node-JS" class="headerlink" title="1 安装Node.JS"></a>1 安装Node.JS</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">链接</a></p>
<h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2 安装Hexo"></a>2 安装Hexo</h2><p>cmd中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h2 id="3-部署本地"><a href="#3-部署本地" class="headerlink" title="3 部署本地"></a>3 部署本地</h2><p>初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>然后在<code>http://localhost:xxxx</code>中可以预览博客</p>
<h2 id="4-部署github"><a href="#4-部署github" class="headerlink" title="4 部署github"></a>4 部署github</h2><ol>
<li><p>新仓库</p>
<p> 创建一个新的仓库，仓库名为<code>username.github.io</code>，其中<code>username</code>必须是Github的用户名。然后就能在<code>username.github.io</code>看到你的主页了</p>
</li>
<li><p>转移</p>
<p> 然后将仓库克隆到本地，并将第三部中创建的<code>&lt;folder&gt;</code><strong>中</strong>的文件copy到仓库文件中</p>
</li>
<li><p>配置文件修改</p>
<p> 找到<code>_config.yml</code>，拖到底部找到<code>deploy</code>，按如下格式修改：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo:</span><br><span class="line">        github: git@github.com:username&#x2F;username.github.io.git（这种ssh的写法可以避免每次deploy要输入账号密码，不过如果git没配置ssh key的话上网找找教程</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure></li>
<li><p>部署！<br> 进入<code>username.github.io</code>文件下</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p> 第一次部署需要github密码，等待片刻后可以在<code>https://username.github.io/</code>中看到自己的博客。初始状态是这样的：</p>
<p> <img src="https://ftp.bmp.ovh/imgs/2020/03/49d75ff2d5a3e545.png" alt=""></p>
</li>
</ol>
<h2 id="5-发布文章"><a href="#5-发布文章" class="headerlink" title="5 发布文章"></a>5 发布文章</h2><ol>
<li>创建<br> 在<code>source/_posts/</code>中创建新的<code>markdown</code>文件，或者使用以下命令创建 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &lt;title&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>预览<br> 文章撰写完成后，执行命令</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g # 生成，即generate</span><br><span class="line">hexo s # 即server</span><br></pre></td></tr></table></figure>
<p> 即可预览自己的博客</p>
</li>
<li><p>发布</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean # 清楚缓存文件和静态生产文件</span><br><span class="line">hexo g -d # 发布</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6 参考文献"></a>6 参考文献</h2><p><a href="https://hexo.io/zh-tw/docs/" target="_blank" rel="noopener">Hexo官方文档</a></p>
<p><a href="https://www.jianshu.com/p/71f58f4b7b30" target="_blank" rel="noopener">用 Github.io 和 Hexo 创建你的第一个博客</a></p>
<p><a href="https://segmentfault.com/a/1190000017986794" target="_blank" rel="noopener">超详细Hexo+Github Page搭建技术博客教程【持续更新】</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
